{
  "task_id": "taco_17485",
  "entry_point": "calculate_G_of_n",
  "mutant_count": 321,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "n -= 1",
      "mutated_line": "n += 1",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n += 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_G_of_n(n: int, MOD: int = 1000000007) -> int:",
      "mutated_line": "def calculate_G_of_n(n: int, MOD: int=1000000008) -> int:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000008) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_G_of_n(n: int, MOD: int = 1000000007) -> int:",
      "mutated_line": "def calculate_G_of_n(n: int, MOD: int=1000000006) -> int:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000006) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_G_of_n(n: int, MOD: int = 1000000007) -> int:",
      "mutated_line": "def calculate_G_of_n(n: int, MOD: int=0) -> int:",
      "code": "def calculate_G_of_n(n: int, MOD: int=0) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_G_of_n(n: int, MOD: int = 1000000007) -> int:",
      "mutated_line": "def calculate_G_of_n(n: int, MOD: int=1) -> int:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_G_of_n(n: int, MOD: int = 1000000007) -> int:",
      "mutated_line": "def calculate_G_of_n(n: int, MOD: int=-1000000007) -> int:",
      "code": "def calculate_G_of_n(n: int, MOD: int=-1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "n -= 1",
      "mutated_line": "n -= 2",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 2\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "n -= 1",
      "mutated_line": "n -= 0",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 0\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "n -= 1",
      "mutated_line": "n -= 0",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 0\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "n -= 1",
      "mutated_line": "n -= -1",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= -1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while n > 0:",
      "mutated_line": "while n >= 0:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n >= 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while n > 0:",
      "mutated_line": "while n <= 0:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n <= 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while n > 0:",
      "mutated_line": "while n != 0:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n != 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) * MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) * MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0] + MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0] + MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) * MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) * MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1] + MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1] + MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) * MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) * MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0] + MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0] + MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) * MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) * MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1] + MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1] + MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) * MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) * MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = A[0][0] * v[0] + A[0][1] * v[1] + MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = A[0][0] * v[0] + A[0][1] * v[1] + MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) * MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) * MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = A[1][0] * v[0] + A[1][1] * v[1] + MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = A[1][0] * v[0] + A[1][1] * v[1] + MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "v = [1, 1]",
      "mutated_line": "v = [2, 1]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [2, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "v = [1, 1]",
      "mutated_line": "v = [0, 1]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [0, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "v = [1, 1]",
      "mutated_line": "v = [0, 1]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [0, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "v = [1, 1]",
      "mutated_line": "v = [-1, 1]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [-1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "v = [1, 1]",
      "mutated_line": "v = [1, 2]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 2]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "v = [1, 1]",
      "mutated_line": "v = [1, 0]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 0]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "v = [1, 1]",
      "mutated_line": "v = [1, 0]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 0]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "v = [1, 1]",
      "mutated_line": "v = [1, -1]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, -1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while n > 0:",
      "mutated_line": "while n > 1:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 1:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while n > 0:",
      "mutated_line": "while n > -1:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > -1:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while n > 0:",
      "mutated_line": "while n > 1:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 1:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if n % 2:",
      "mutated_line": "if n * 2:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n * 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if n % 2:",
      "mutated_line": "if n + 2:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n + 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "n //= 2",
      "mutated_line": "n //= 3",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 3\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "n //= 2",
      "mutated_line": "n //= 1",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 1\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "n //= 2",
      "mutated_line": "n //= 0",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 0\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "n //= 2",
      "mutated_line": "n //= 1",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 1\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "n //= 2",
      "mutated_line": "n //= -2",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= -2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return v[0]",
      "mutated_line": "return v[1]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return v[0]",
      "mutated_line": "return v[-1]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return v[0]",
      "mutated_line": "return v[1]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][1] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][-1] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][-1] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][1] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] - a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] - a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = a[1][0] * b[0][0] * (a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = a[1][0] * b[0][0] * (a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][2] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][2] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][0] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][0] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][-1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][-1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] - a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] - a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = a[1][0] * b[0][1] * (a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = a[1][0] * b[0][1] * (a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][1] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][-1] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][-1] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][1] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] - a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] - a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = a[0][0] * b[0][0] * (a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = a[0][0] * b[0][0] * (a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][2] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][2] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][0] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][0] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][-1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][-1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] - a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] - a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = a[0][0] * b[0][1] * (a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = a[0][0] * b[0][1] * (a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = [0, 0]",
      "mutated_line": "res = [1, 0]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [1, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = [0, 0]",
      "mutated_line": "res = [-1, 0]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [-1, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = [0, 0]",
      "mutated_line": "res = [1, 0]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [1, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = [0, 0]",
      "mutated_line": "res = [0, 1]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 1]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = [0, 0]",
      "mutated_line": "res = [0, -1]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, -1]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = [0, 0]",
      "mutated_line": "res = [0, 1]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 1]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[1] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[-1] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[-1] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[1] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] - A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] - A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = A[0][0] * v[0] * (A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = A[0][0] * v[0] * (A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[2] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[2] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[0] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[0] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[-1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[-1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] - A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] - A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = A[1][0] * v[0] * (A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = A[1][0] * v[0] * (A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[2, 1], [1, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[2, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[0, 1], [1, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[0, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[0, 1], [1, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[0, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[-1, 1], [1, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[-1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[1, 2], [1, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 2], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[1, 0], [1, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 0], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[1, 0], [1, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 0], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[1, -1], [1, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, -1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[1, 1], [2, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [2, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[1, 1], [0, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [0, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[1, 1], [0, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [0, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[1, 1], [-1, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [-1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[1, 1], [1, 1]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 1]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[1, 1], [1, -1]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, -1]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mat = [[1, 1], [1, 0]]",
      "mutated_line": "mat = [[1, 1], [1, 1]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 1]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if n % 2:",
      "mutated_line": "if n % 3:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 3:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if n % 2:",
      "mutated_line": "if n % 1:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 1:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if n % 2:",
      "mutated_line": "if n % 0:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 0:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if n % 2:",
      "mutated_line": "if n % 1:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 1:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if n % 2:",
      "mutated_line": "if n % -2:",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % -2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = [[0, 0], [0, 0]]",
      "mutated_line": "res = [[1, 0], [0, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[1, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = [[0, 0], [0, 0]]",
      "mutated_line": "res = [[-1, 0], [0, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[-1, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = [[0, 0], [0, 0]]",
      "mutated_line": "res = [[1, 0], [0, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[1, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = [[0, 0], [0, 0]]",
      "mutated_line": "res = [[0, 1], [0, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 1], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = [[0, 0], [0, 0]]",
      "mutated_line": "res = [[0, -1], [0, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, -1], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = [[0, 0], [0, 0]]",
      "mutated_line": "res = [[0, 1], [0, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 1], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = [[0, 0], [0, 0]]",
      "mutated_line": "res = [[0, 0], [1, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [1, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = [[0, 0], [0, 0]]",
      "mutated_line": "res = [[0, 0], [-1, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [-1, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = [[0, 0], [0, 0]]",
      "mutated_line": "res = [[0, 0], [1, 0]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [1, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = [[0, 0], [0, 0]]",
      "mutated_line": "res = [[0, 0], [0, 1]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 1]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = [[0, 0], [0, 0]]",
      "mutated_line": "res = [[0, 0], [0, -1]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, -1]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "res = [[0, 0], [0, 0]]",
      "mutated_line": "res = [[0, 0], [0, 1]]",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 1]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[2][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[2][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[0][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[0][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[-1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[-1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] / b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] / b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] + b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] + b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] ** b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] ** b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] / b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] / b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + (a[1][1] + b[1][0])) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + (a[1][1] + b[1][0])) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] ** b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] ** b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[2][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[2][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[0][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[0][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[-1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[-1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] / b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] / b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] + b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] + b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] ** b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] ** b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] / b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] / b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + (a[1][1] + b[1][1])) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + (a[1][1] + b[1][1])) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] ** b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] ** b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[1][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[-1][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[-1][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[1][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] / b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] / b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] + b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] + b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] ** b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] ** b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] / b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] / b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + (a[0][1] + b[1][0])) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + (a[0][1] + b[1][0])) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] ** b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] ** b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[1][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[-1][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[-1][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[1][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] / b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] / b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] + b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] + b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] ** b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] ** b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] / b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] / b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + (a[0][1] + b[1][1])) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + (a[0][1] + b[1][1])) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] ** b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] ** b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] / v[0] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] / v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] + v[0] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] + v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] ** v[0] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] ** v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + A[0][1] / v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] / v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + (A[0][1] + v[1])) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + (A[0][1] + v[1])) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + A[0][1] ** v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] ** v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] / v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] / v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] + v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] + v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] ** v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] ** v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[1][1] / v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] / v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + (A[1][1] + v[1])) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + (A[1][1] + v[1])) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[1][1] ** v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] ** v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][1] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][1] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][-1] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][-1] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][1] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][1] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][1] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][1] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][-1] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][-1] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][1] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][1] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][2] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][2] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][0] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][0] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][0] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][0] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][-1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][-1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][1]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][-1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][-1]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][1]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][1] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][1] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][-1] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][-1] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][1] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][1] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][2] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][2] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][0] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][0] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][0] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][0] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][-1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][-1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][2] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][2] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][0] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][0] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][0] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][0] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][-1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][-1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][2]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][2]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][0]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][0]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][-1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][-1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][1] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][1] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][-1] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][-1] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][1] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][1] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][1] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][1] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][-1] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][-1] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][1] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][1] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][2] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][2] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][0] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][0] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][0] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][0] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][-1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][-1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][1]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][-1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][-1]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][1]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][1] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][1] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][-1] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][-1] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][1] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][1] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][2] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][2] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][0] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][0] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][0] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][0] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][-1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][-1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][2] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][2] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][0] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][0] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][0] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][0] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][-1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][-1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][2]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][2]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][0]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][0]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][-1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][-1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][1] * v[0] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][1] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][-1] * v[0] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][-1] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][1] * v[0] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][1] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[1] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[1] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[-1] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[-1] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[1] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[1] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + A[0][2] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][2] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + A[0][0] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][0] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + A[0][0] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][0] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + A[0][-1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][-1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[2]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[2]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[0]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[0]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[-1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[-1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][1] * v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][1] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][-1] * v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][-1] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][1] * v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][1] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[1] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[1] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[-1] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[-1] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[1] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[1] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[1][2] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][2] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[1][0] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][0] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[1][0] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][0] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[1][-1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][-1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[2]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[2]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[0]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[0]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[-1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[-1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[2][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[2][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[0][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[0][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[0][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[0][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[-1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[-1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[1][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[1][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[-1][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[-1][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[1][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[1][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[2][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[2][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[-1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[-1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[2][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[2][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[0][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[0][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[0][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[0][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "mutated_line": "res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[-1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[-1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[2][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[2][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[0][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[0][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[0][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[0][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[-1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[-1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[1][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[1][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[-1][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[-1][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[1][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[1][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[2][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[2][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[-1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[-1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[2][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[2][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[0][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[0][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[0][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[0][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "mutated_line": "res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[-1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[-1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[1][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[1][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[-1][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[-1][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[1][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[1][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[1][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[1][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[-1][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[-1][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[1][0] + a[0][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[1][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[-1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[-1][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[1][1] * b[1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[2][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[2][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[0][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[0][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[0][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[0][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD",
      "mutated_line": "res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[-1][0]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[-1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[1][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[1][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[-1][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[-1][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[1][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[1][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[1][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[1][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[-1][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[-1][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[1][1] + a[0][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[1][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[-1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[-1][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[1][1] * b[1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[2][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[2][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[0][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[0][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[0][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[0][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD",
      "mutated_line": "res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[-1][1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[-1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[1][0] * v[0] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[1][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[-1][0] * v[0] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[-1][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[1][0] * v[0] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[1][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[1][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + A[-1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[-1][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD",
      "mutated_line": "res[0] = (A[0][0] * v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[1][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[2][0] * v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[2][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[0][0] * v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[0][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[0][0] * v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[0][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[-1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[-1][0] * v[0] + A[1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[2][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[2][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[0][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[0][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[0][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res[1] = (A[1][0] * v[0] + A[1][1] * v[1]) % MOD",
      "mutated_line": "res[1] = (A[1][0] * v[0] + A[-1][1] * v[1]) % MOD",
      "code": "def calculate_G_of_n(n: int, MOD: int=1000000007) -> int:\n\n    def mMult(a, b):\n        res = [[0, 0], [0, 0]]\n        res[1][0] = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD\n        res[1][1] = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD\n        res[0][0] = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD\n        res[0][1] = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD\n        return res\n\n    def mVec(A, v):\n        res = [0, 0]\n        res[0] = (A[0][0] * v[0] + A[0][1] * v[1]) % MOD\n        res[1] = (A[1][0] * v[0] + A[-1][1] * v[1]) % MOD\n        return res\n    mat = [[1, 1], [1, 0]]\n    v = [1, 1]\n    n -= 1\n    while n > 0:\n        if n % 2:\n            v = mVec(mat, v)\n        mat = mMult(mat, mat)\n        n //= 2\n    return v[0]"
    }
  ]
}