{
  "task_id": "taco_15295",
  "entry_point": "calculate_max_beauty_sum",
  "mutant_count": 82,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "result = 0",
      "mutated_line": "result = 1",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 1\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "result = 0",
      "mutated_line": "result = -1",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = -1\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "result = 0",
      "mutated_line": "result = 1",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 1\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if v != 1:",
      "mutated_line": "if v == 1:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v == 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if u != 1:",
      "mutated_line": "if u == 1:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u == 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if v != 1:",
      "mutated_line": "if v != 2:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 2:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if v != 1:",
      "mutated_line": "if v != 0:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 0:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if v != 1:",
      "mutated_line": "if v != 0:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 0:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if v != 1:",
      "mutated_line": "if v != -1:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != -1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if u != 1:",
      "mutated_line": "if u != 2:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 2:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if u != 1:",
      "mutated_line": "if u != 0:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 0:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if u != 1:",
      "mutated_line": "if u != 0:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 0:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if u != 1:",
      "mutated_line": "if u != -1:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != -1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(2, 0, adjacency_list[0], values[0], 0, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(2, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(0, 0, adjacency_list[0], values[0], 0, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(0, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(0, 0, adjacency_list[0], values[0], 0, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(0, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(-1, 0, adjacency_list[0], values[0], 0, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(-1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, 1, adjacency_list[0], values[0], 0, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 1, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, -1, adjacency_list[0], values[0], 0, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, -1, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, 1, adjacency_list[0], values[0], 0, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 1, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, 0, adjacency_list[0], values[0], 1, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 1, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, 0, adjacency_list[0], values[0], -1, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], -1, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, 0, adjacency_list[0], values[0], 1, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 1, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 1)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 1)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, -1)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, -1)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 1)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 1)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "a, b, cc, gnode, gsum, best = stack[-1]",
      "mutated_line": "(a, b, cc, gnode, gsum, best) = stack[+1]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[+1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if c == b:",
      "mutated_line": "if c != b:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c != b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, 0, adjacency_list[1], values[0], 0, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[1], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, 0, adjacency_list[-1], values[0], 0, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[-1], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, 0, adjacency_list[1], values[0], 0, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[1], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, 0, adjacency_list[0], values[1], 0, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[1], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, 0, adjacency_list[0], values[-1], 0, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[-1], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]",
      "mutated_line": "stack = [(1, 0, adjacency_list[0], values[1], 0, 0)]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[1], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a, b, cc, gnode, gsum, best = stack[-1]",
      "mutated_line": "(a, b, cc, gnode, gsum, best) = stack[-2]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-2]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a, b, cc, gnode, gsum, best = stack[-1]",
      "mutated_line": "(a, b, cc, gnode, gsum, best) = stack[-0]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-0]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a, b, cc, gnode, gsum, best = stack[-1]",
      "mutated_line": "(a, b, cc, gnode, gsum, best) = stack[-0]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-0]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a, b, cc, gnode, gsum, best = stack[-1]",
      "mutated_line": "(a, b, cc, gnode, gsum, best) = stack[--1]",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[--1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s = max(gsum, gsum + best)",
      "mutated_line": "s = max(gsum, gsum - best)",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum - best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s = max(gsum, gsum + best)",
      "mutated_line": "s = max(gsum, gsum * best)",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum * best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "diff = s - g",
      "mutated_line": "diff = s + g",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s + g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "diff = s - g",
      "mutated_line": "diff = s * g",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s * g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if gsum != 0 and diff < best:",
      "mutated_line": "if gsum != 0 or diff < best:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 or diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 1, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 1, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], -1, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], -1, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 1, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 1, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 1))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 1))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, -1))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, -1))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 1))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 1))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if gsum != 0 and diff < best:",
      "mutated_line": "if gsum == 0 and diff < best:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum == 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if gsum != 0 and diff < best:",
      "mutated_line": "if gsum != 0 and diff <= best:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff <= best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if gsum != 0 and diff < best:",
      "mutated_line": "if gsum != 0 and diff >= best:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff >= best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if gsum != 0 and diff < best:",
      "mutated_line": "if gsum != 0 and diff != best:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff != best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "adjacency_list[u - 1].append(v)",
      "mutated_line": "adjacency_list[u + 1].append(v)",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u + 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "adjacency_list[u - 1].append(v)",
      "mutated_line": "adjacency_list[u * 1].append(v)",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u * 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "adjacency_list[v - 1].append(u)",
      "mutated_line": "adjacency_list[v + 1].append(u)",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v + 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "adjacency_list[v - 1].append(u)",
      "mutated_line": "adjacency_list[v * 1].append(u)",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v * 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c + 1], values[c - 1], 0, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c + 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c * 1], values[c - 1], 0, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c * 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 1], values[c + 1], 0, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c + 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 1], values[c * 1], 0, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c * 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if gsum != 0 and diff < best:",
      "mutated_line": "if gsum != 1 and diff < best:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 1 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if gsum != 0 and diff < best:",
      "mutated_line": "if gsum != -1 and diff < best:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != -1 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if gsum != 0 and diff < best:",
      "mutated_line": "if gsum != 1 and diff < best:",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 1 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))",
      "mutated_line": "stack.append((a, b, cc, math.gcd(gnode, g), gsum - g, diff))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum - g, diff))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))",
      "mutated_line": "stack.append((a, b, cc, math.gcd(gnode, g), gsum * g, diff))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum * g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adjacency_list[u - 1].append(v)",
      "mutated_line": "adjacency_list[u - 2].append(v)",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 2].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adjacency_list[u - 1].append(v)",
      "mutated_line": "adjacency_list[u - 0].append(v)",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 0].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adjacency_list[u - 1].append(v)",
      "mutated_line": "adjacency_list[u - 0].append(v)",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 0].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adjacency_list[u - 1].append(v)",
      "mutated_line": "adjacency_list[u - -1].append(v)",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - -1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "adjacency_list[v - 1].append(u)",
      "mutated_line": "adjacency_list[v - 2].append(u)",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 2].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "adjacency_list[v - 1].append(u)",
      "mutated_line": "adjacency_list[v - 0].append(u)",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 0].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "adjacency_list[v - 1].append(u)",
      "mutated_line": "adjacency_list[v - 0].append(u)",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 0].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "adjacency_list[v - 1].append(u)",
      "mutated_line": "adjacency_list[v - -1].append(u)",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - -1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 2], values[c - 1], 0, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 2], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 0], values[c - 1], 0, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 0], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 0], values[c - 1], 0, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 0], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - -1], values[c - 1], 0, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - -1], values[c - 1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 2], 0, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 2], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 0], 0, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 0], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 0], 0, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - 0], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.append((c, a, adjacency_list[c - 1], values[c - 1], 0, 0))",
      "mutated_line": "stack.append((c, a, adjacency_list[c - 1], values[c - -1], 0, 0))",
      "code": "import math\n\ndef calculate_max_beauty_sum(n, values, edges):\n    adjacency_list = [[] for _ in range(n)]\n    for (u, v) in edges:\n        if v != 1:\n            adjacency_list[u - 1].append(v)\n        if u != 1:\n            adjacency_list[v - 1].append(u)\n    stack = [(1, 0, adjacency_list[0], values[0], 0, 0)]\n    result = 0\n    while stack:\n        (a, b, cc, gnode, gsum, best) = stack[-1]\n        if cc:\n            c = cc.pop()\n            if c == b:\n                continue\n            stack.append((c, a, adjacency_list[c - 1], values[c - -1], 0, 0))\n        else:\n            stack.pop()\n            g = gnode\n            s = max(gsum, gsum + best)\n            if not stack:\n                result = s\n            else:\n                (a, b, cc, gnode, gsum, best) = stack.pop()\n                diff = s - g\n                if gsum != 0 and diff < best:\n                    diff = best\n                stack.append((a, b, cc, math.gcd(gnode, g), gsum + g, diff))\n    return result"
    }
  ]
}