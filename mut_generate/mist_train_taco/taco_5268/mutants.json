{
  "task_id": "taco_5268",
  "entry_point": "find_largest_good_sequence",
  "mutant_count": 28,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(sm) > len(bg):",
      "mutated_line": "if len(sm) >= len(bg):",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) >= len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(sm) > len(bg):",
      "mutated_line": "if len(sm) <= len(bg):",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) <= len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(sm) > len(bg):",
      "mutated_line": "if len(sm) != len(bg):",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) != len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if a < b:",
      "mutated_line": "if a <= b:",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a <= b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if a < b:",
      "mutated_line": "if a >= b:",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a >= b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if a < b:",
      "mutated_line": "if a != b:",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a != b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sm.sort(reverse=True)",
      "mutated_line": "sm.sort(reverse=False)",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=False)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "indices = [sm[i][1] for i in range(t)]",
      "mutated_line": "indices = [sm[i][2] for i in range(t)]",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][2] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "indices = [sm[i][1] for i in range(t)]",
      "mutated_line": "indices = [sm[i][0] for i in range(t)]",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][0] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "indices = [sm[i][1] for i in range(t)]",
      "mutated_line": "indices = [sm[i][0] for i in range(t)]",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][0] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "indices = [sm[i][1] for i in range(t)]",
      "mutated_line": "indices = [sm[i][-1] for i in range(t)]",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][-1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "indices = [bg[i][1] for i in range(t)]",
      "mutated_line": "indices = [bg[i][2] for i in range(t)]",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][2] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "indices = [bg[i][1] for i in range(t)]",
      "mutated_line": "indices = [bg[i][0] for i in range(t)]",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][0] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "indices = [bg[i][1] for i in range(t)]",
      "mutated_line": "indices = [bg[i][0] for i in range(t)]",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][0] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "indices = [bg[i][1] for i in range(t)]",
      "mutated_line": "indices = [bg[i][-1] for i in range(t)]",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][-1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sm.append((b, i + 1))",
      "mutated_line": "sm.append((b, i - 1))",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i - 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sm.append((b, i + 1))",
      "mutated_line": "sm.append((b, i * 1))",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i * 1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "bg.append((b, i + 1))",
      "mutated_line": "bg.append((b, i - 1))",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i - 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "bg.append((b, i + 1))",
      "mutated_line": "bg.append((b, i * 1))",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i * 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sm.append((b, i + 1))",
      "mutated_line": "sm.append((b, i + 2))",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 2))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sm.append((b, i + 1))",
      "mutated_line": "sm.append((b, i + 0))",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 0))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sm.append((b, i + 1))",
      "mutated_line": "sm.append((b, i + 0))",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 0))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sm.append((b, i + 1))",
      "mutated_line": "sm.append((b, i + -1))",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + -1))\n        else:\n            bg.append((b, i + 1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "bg.append((b, i + 1))",
      "mutated_line": "bg.append((b, i + 2))",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 2))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "bg.append((b, i + 1))",
      "mutated_line": "bg.append((b, i + 0))",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 0))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "bg.append((b, i + 1))",
      "mutated_line": "bg.append((b, i + 0))",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + 0))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "bg.append((b, i + 1))",
      "mutated_line": "bg.append((b, i + -1))",
      "code": "def find_largest_good_sequence(n, pairs):\n    \"\"\"\n    Finds the largest subset of indices such that the sequence formed by the pairs is good.\n\n    Parameters:\n    n (int): The number of pairs.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing a pair.\n\n    Returns:\n    tuple: A tuple containing:\n           - t (int): The number of pairs in the answer.\n           - indices (list of int): The list of indices of pairs in the corresponding order.\n    \"\"\"\n    sm = []\n    bg = []\n    for i in range(n):\n        (a, b) = pairs[i]\n        if a < b:\n            sm.append((b, i + 1))\n        else:\n            bg.append((b, i + -1))\n    if len(sm) > len(bg):\n        sm.sort(reverse=True)\n        t = len(sm)\n        indices = [sm[i][1] for i in range(t)]\n    else:\n        bg.sort()\n        t = len(bg)\n        indices = [bg[i][1] for i in range(t)]\n    return (t, indices)"
    }
  ]
}