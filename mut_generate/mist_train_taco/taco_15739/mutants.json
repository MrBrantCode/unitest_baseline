{
  "task_id": "taco_15739",
  "entry_point": "minimum_possible_score",
  "mutant_count": 61,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l >= 1:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l >= 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l <= 1:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l <= 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l != 1:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l != 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return False\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (+1, 10 ** 12 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (+1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 10 ** 12 - 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 - 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 10 ** 12 * 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 * 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r + l > 1:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r + l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r * l > 1:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r * l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 2:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 2:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 0:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 0:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 0:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 0:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > -1:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > -1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) / 2",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) / 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) * 2",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) * 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "F.sort(reverse=True)",
      "mutated_line": "F.sort(reverse=False)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=False)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if mid < i * j:",
      "mutated_line": "if mid <= i * j:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid <= i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if mid < i * j:",
      "mutated_line": "if mid >= i * j:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid >= i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if mid < i * j:",
      "mutated_line": "if mid != i * j:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid != i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "s -= i - mid // j",
      "mutated_line": "s += i - mid // j",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s += i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if s < 0:",
      "mutated_line": "if s <= 0:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s <= 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if s < 0:",
      "mutated_line": "if s >= 0:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s >= 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if s < 0:",
      "mutated_line": "if s != 0:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s != 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-2, 10 ** 12 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-2, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-0, 10 ** 12 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-0, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-0, 10 ** 12 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-0, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (--1, 10 ** 12 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (--1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 10 * 12 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 * 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 10 + 12 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 + 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 10 ** 12 + 2)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 2)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 10 ** 12 + 0)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 0)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 10 ** 12 + 0)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 0)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 10 ** 12 + -1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + -1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l - r) // 2",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l - r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = l * r // 2",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = l * r // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // 3",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 3\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // 1",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 1\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // 0",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 0\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // 1",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 1\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mid = (l + r) // 2",
      "mutated_line": "mid = (l + r) // -2",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // -2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if mid < i * j:",
      "mutated_line": "if mid < i / j:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i / j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if mid < i * j:",
      "mutated_line": "if mid < i + j:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i + j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if mid < i * j:",
      "mutated_line": "if mid < i ** j:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i ** j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "s -= i - mid // j",
      "mutated_line": "s -= i + mid // j",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i + mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "s -= i - mid // j",
      "mutated_line": "s -= i * (mid // j)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i * (mid // j)\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if s < 0:",
      "mutated_line": "if s < 1:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 1:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if s < 0:",
      "mutated_line": "if s < -1:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < -1:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if s < 0:",
      "mutated_line": "if s < 1:",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 1:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return True\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 11 ** 12 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 11 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 9 ** 12 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 9 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 0 ** 12 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 0 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 1 ** 12 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 1 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, -10 ** 12 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, -10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 10 ** 13 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 13 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 10 ** 11 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 11 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 10 ** 0 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 0 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 10 ** 1 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 1 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l, r = -1, 10**12 + 1",
      "mutated_line": "(l, r) = (-1, 10 ** -12 + 1)",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid // j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** -12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "s -= i - mid // j",
      "mutated_line": "s -= i - mid / j",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid / j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "s -= i - mid // j",
      "mutated_line": "s -= i - mid * j",
      "code": "def minimum_possible_score(N, K, A, F):\n    A.sort()\n    F.sort(reverse=True)\n\n    def can_achieve_score(mid):\n        s = K\n        for (i, j) in zip(A, F):\n            if mid < i * j:\n                s -= i - mid * j\n            if s < 0:\n                return False\n        return True\n    (l, r) = (-1, 10 ** 12 + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if can_achieve_score(mid):\n            r = mid\n        else:\n            l = mid\n    return r"
    }
  ]
}