{
  "task_id": "taco_9686",
  "entry_point": "find_minimum_palindrome_cost",
  "mutant_count": 88,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "INF = 10 ** 30",
      "mutated_line": "INF = 10 * 30",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 * 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "INF = 10 ** 30",
      "mutated_line": "INF = 10 + 30",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 + 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 10 ** 30",
      "mutated_line": "INF = 11 ** 30",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 11 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 10 ** 30",
      "mutated_line": "INF = 9 ** 30",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 9 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 10 ** 30",
      "mutated_line": "INF = 0 ** 30",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 0 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 10 ** 30",
      "mutated_line": "INF = 1 ** 30",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 1 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 10 ** 30",
      "mutated_line": "INF = -10 ** 30",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = -10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 10 ** 30",
      "mutated_line": "INF = 10 ** 31",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 31\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 10 ** 30",
      "mutated_line": "INF = 10 ** 29",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 29\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 10 ** 30",
      "mutated_line": "INF = 10 ** 0",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 0\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 10 ** 30",
      "mutated_line": "INF = 10 ** 1",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 1\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 10 ** 30",
      "mutated_line": "INF = 10 ** -30",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** -30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (l, r) in dp:",
      "mutated_line": "if (l, r) not in dp:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) not in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if l and l == l[::-1]:",
      "mutated_line": "if l or l == l[::-1]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l or l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if r and r == r[::-1]:",
      "mutated_line": "if r or r == r[::-1]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r or r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if s == s[::-1]:",
      "mutated_line": "if s != s[::-1]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s != s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "return -1 if m == INF else m",
      "mutated_line": "return -1 if m != INF else m",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m != INF else m"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "return -1 if m == INF else m",
      "mutated_line": "return +1 if m == INF else m",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return +1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if l and l == l[::-1]:",
      "mutated_line": "if l and l != l[::-1]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l != l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[l, r] = 0",
      "mutated_line": "dp[l, r] = 1",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 1\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[l, r] = 0",
      "mutated_line": "dp[l, r] = -1",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = -1\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[l, r] = 0",
      "mutated_line": "dp[l, r] = 1",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 1\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if r and r == r[::-1]:",
      "mutated_line": "if r and r != r[::-1]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r != r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[l, r] = 0",
      "mutated_line": "dp[l, r] = 1",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 1\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[l, r] = 0",
      "mutated_line": "dp[l, r] = -1",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = -1\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[l, r] = 0",
      "mutated_line": "dp[l, r] = 1",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 1\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return -1 if m == INF else m",
      "mutated_line": "return -2 if m == INF else m",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -2 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return -1 if m == INF else m",
      "mutated_line": "return -0 if m == INF else m",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -0 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return -1 if m == INF else m",
      "mutated_line": "return -0 if m == INF else m",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -0 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return -1 if m == INF else m",
      "mutated_line": "return --1 if m == INF else m",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return --1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(s) > len(r):",
      "mutated_line": "if len(s) >= len(r):",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) >= len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(s) > len(r):",
      "mutated_line": "if len(s) <= len(r):",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) <= len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(s) > len(r):",
      "mutated_line": "if len(s) != len(r):",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) != len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(s) > len(l):",
      "mutated_line": "if len(s) >= len(l):",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) >= len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(s) > len(l):",
      "mutated_line": "if len(s) <= len(l):",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) <= len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(s) > len(l):",
      "mutated_line": "if len(s) != len(l):",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) != len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "S.append(tuple((ord(char) - ord('a') for char in s)))",
      "mutated_line": "S.append(tuple((ord(char) + ord('a') for char in s)))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) + ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "S.append(tuple((ord(char) - ord('a') for char in s)))",
      "mutated_line": "S.append(tuple((ord(char) * ord('a') for char in s)))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) * ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if s[len(s) - len(r):] == r:",
      "mutated_line": "if s[len(s) - len(r):] != r:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] != r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "elif len(s) == len(r):",
      "mutated_line": "elif len(s) != len(r):",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) != len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if s[:len(l)] == l:",
      "mutated_line": "if s[:len(l)] != l:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] != l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "elif len(s) == len(l):",
      "mutated_line": "elif len(s) != len(l):",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) != len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "UOI",
      "lineno": 45,
      "original_line": "if s == s[::-1]:",
      "mutated_line": "if s == s[::+1]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::+1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "if l and l == l[::-1]:",
      "mutated_line": "if l and l == l[::+1]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::+1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "if r and r == r[::-1]:",
      "mutated_line": "if r and r == r[::+1]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::+1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if s == r:",
      "mutated_line": "if s != r:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s != r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "elif s == r[len(r) - len(s):]:",
      "mutated_line": "elif s != r[len(r) - len(s):]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s != r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if s == l:",
      "mutated_line": "if s != l:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s != l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif s == l[:len(s)]:",
      "mutated_line": "elif s != l[:len(s)]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s != l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if s == s[::-1]:",
      "mutated_line": "if s == s[::-2]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-2]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if s == s[::-1]:",
      "mutated_line": "if s == s[::-0]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-0]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if s == s[::-1]:",
      "mutated_line": "if s == s[::-0]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-0]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if s == s[::-1]:",
      "mutated_line": "if s == s[::--1]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::--1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "S.append(tuple((ord(char) - ord('a') for char in s)))",
      "mutated_line": "S.append(tuple((ord(char) - ord('') for char in s)))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if l and l == l[::-1]:",
      "mutated_line": "if l and l == l[::-2]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-2]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if l and l == l[::-1]:",
      "mutated_line": "if l and l == l[::-0]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-0]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if l and l == l[::-1]:",
      "mutated_line": "if l and l == l[::-0]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-0]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if l and l == l[::-1]:",
      "mutated_line": "if l and l == l[::--1]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::--1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if r and r == r[::-1]:",
      "mutated_line": "if r and r == r[::-2]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-2]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if r and r == r[::-1]:",
      "mutated_line": "if r and r == r[::-0]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-0]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if r and r == r[::-1]:",
      "mutated_line": "if r and r == r[::-0]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-0]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if r and r == r[::-1]:",
      "mutated_line": "if r and r == r[::--1]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::--1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c - min_cost(s[:len(s) - len(r)][::-1], ()))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c - min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c * min_cost(s[:len(s) - len(r)][::-1], ()))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c * min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c - min_cost((), s[len(l):][::-1]))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c - min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c * min_cost((), s[len(l):][::-1]))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c * min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if s[len(s) - len(r):] == r:",
      "mutated_line": "if s[len(s) + len(r):] == r:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) + len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if s[len(s) - len(r):] == r:",
      "mutated_line": "if s[len(s) * len(r):] == r:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) * len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c - min_cost((), r[:len(r) - len(s)]))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c - min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c * min_cost((), r[:len(r) - len(s)]))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c * min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c - min_cost(l[len(s):], ()))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c - min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c * min_cost(l[len(s):], ()))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c * min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "elif s == r[len(r) - len(s):]:",
      "mutated_line": "elif s == r[len(r) + len(s):]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) + len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "elif s == r[len(r) - len(s):]:",
      "mutated_line": "elif s == r[len(r) * len(s):]:",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) * len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::+1], ()))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::+1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::+1]))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::+1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) + len(r)][::-1], ()))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) + len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) * len(r)][::-1], ()))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) * len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-2], ()))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-2], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-0], ()))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-0], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-0], ()))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-0], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::--1], ()))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::--1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) + len(s)]))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) + len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) * len(s)]))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) * len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-2]))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-2]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-0]))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-0]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-0]))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-0]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::-1]))",
      "mutated_line": "dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::--1]))",
      "code": "def find_minimum_palindrome_cost(N, strings_with_costs):\n    S = []\n    C = []\n    for (s, c) in strings_with_costs:\n        C.append(int(c))\n        S.append(tuple((ord(char) - ord('a') for char in s)))\n    INF = 10 ** 30\n    dp = {}\n\n    def min_cost(l, r):\n        if (l, r) in dp:\n            return dp[l, r]\n        if l and l == l[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        if r and r == r[::-1]:\n            dp[l, r] = 0\n            return dp[l, r]\n        dp[l, r] = INF\n        if not l:\n            for (c, s) in zip(C, S):\n                if len(s) > len(r):\n                    if s[len(s) - len(r):] == r:\n                        dp[l, r] = min(dp[l, r], c + min_cost(s[:len(s) - len(r)][::-1], ()))\n                elif len(s) == len(r):\n                    if s == r:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == r[len(r) - len(s):]:\n                    dp[l, r] = min(dp[l, r], c + min_cost((), r[:len(r) - len(s)]))\n        if not r:\n            for (c, s) in zip(C, S):\n                if len(s) > len(l):\n                    if s[:len(l)] == l:\n                        dp[l, r] = min(dp[l, r], c + min_cost((), s[len(l):][::--1]))\n                elif len(s) == len(l):\n                    if s == l:\n                        dp[l, r] = min(dp[l, r], c)\n                elif s == l[:len(s)]:\n                    dp[l, r] = min(dp[l, r], c + min_cost(l[len(s):], ()))\n        return dp[l, r]\n    m = min_cost((), ())\n    for (s, c) in zip(S, C):\n        if s == s[::-1]:\n            m = min(m, c)\n    return -1 if m == INF else m"
    }
  ]
}