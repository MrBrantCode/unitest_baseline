{
  "task_id": "taco_17543",
  "entry_point": "find_longest_subsequence",
  "mutant_count": 157,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "Q = R(N + 1)",
      "mutated_line": "Q = R(N - 1)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N - 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "Q = R(N + 1)",
      "mutated_line": "Q = R(N * 1)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N * 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "d = [[0] / 2 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] / 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "d = [[0] + 2 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] + 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "d = [[0] ** 2 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] ** 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "f = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "f = [[0] / 2 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] / 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "f = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "f = [[0] + 2 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] + 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "f = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "f = [[0] ** 2 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] ** 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in R(1, N + 1):",
      "mutated_line": "for i in R(2, N + 1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(2, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in R(1, N + 1):",
      "mutated_line": "for i in R(0, N + 1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(0, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in R(1, N + 1):",
      "mutated_line": "for i in R(0, N + 1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(0, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in R(1, N + 1):",
      "mutated_line": "for i in R(-1, N + 1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(-1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in R(1, N + 1):",
      "mutated_line": "for i in R(1, N - 1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N - 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in R(1, N + 1):",
      "mutated_line": "for i in R(1, N * 1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N * 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "I, J = 0, 0",
      "mutated_line": "(I, J) = (1, 0)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (1, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "I, J = 0, 0",
      "mutated_line": "(I, J) = (-1, 0)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (-1, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "I, J = 0, 0",
      "mutated_line": "(I, J) = (1, 0)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (1, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "I, J = 0, 0",
      "mutated_line": "(I, J) = (0, 1)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 1)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "I, J = 0, 0",
      "mutated_line": "(I, J) = (0, -1)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, -1)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "I, J = 0, 0",
      "mutated_line": "(I, J) = (0, 1)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 1)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "result = '' if I == J == 0 else bin(J)[2:].zfill(I)",
      "mutated_line": "result = '' if I != J == 0 else bin(J)[2:].zfill(I)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I != J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result = '' if I == J == 0 else bin(J)[2:].zfill(I)",
      "mutated_line": "result = 'MUTATED' if I == J == 0 else bin(J)[2:].zfill(I)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = 'MUTATED' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "Q = R(N + 1)",
      "mutated_line": "Q = R(N + 2)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 2)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "Q = R(N + 1)",
      "mutated_line": "Q = R(N + 0)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 0)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "Q = R(N + 1)",
      "mutated_line": "Q = R(N + 0)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 0)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "Q = R(N + 1)",
      "mutated_line": "Q = R(N + -1)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + -1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "d = [[0] * (2 * N) for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * (2 * N) for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "d = [[0] * (2 + N) for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * (2 + N) for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "f = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "f = [[0] * (2 * N) for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * (2 * N) for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "f = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "f = [[0] * (2 + N) for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * (2 + N) for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in R(1, N + 1):",
      "mutated_line": "for i in R(1, N + 2):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 2):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in R(1, N + 1):",
      "mutated_line": "for i in R(1, N + 0):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 0):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in R(1, N + 1):",
      "mutated_line": "for i in R(1, N + 0):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 0):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in R(1, N + 1):",
      "mutated_line": "for i in R(1, N + -1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + -1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t = j >> i - 1 & 1",
      "mutated_line": "t = j >> i - 1 | 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 | 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 1\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = 0",
      "mutated_line": "r = -1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = -1\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 1\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i or j >> i - 1 - r & 1 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i or j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "r += 1",
      "mutated_line": "r -= 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r -= 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for k in R(i + 1, N + 1):",
      "mutated_line": "for k in R(i - 1, N + 1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i - 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for k in R(i + 1, N + 1):",
      "mutated_line": "for k in R(i * 1, N + 1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i * 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for k in R(i + 1, N + 1):",
      "mutated_line": "for k in R(i + 1, N - 1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N - 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for k in R(i + 1, N + 1):",
      "mutated_line": "for k in R(i + 1, N * 1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N * 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "z = k - i",
      "mutated_line": "z = k + i",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k + i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "z = k - i",
      "mutated_line": "z = k * i",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k * i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "m = (1 << z) - 1",
      "mutated_line": "m = (1 << z) + 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) + 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "m = (1 << z) - 1",
      "mutated_line": "m = (1 << z) * 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) * 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "d[i][j >> z] += d[k][j]",
      "mutated_line": "d[i][j >> z] -= d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] -= d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if d[i][j] >= K:",
      "mutated_line": "if d[i][j] > K:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] > K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if d[i][j] >= K:",
      "mutated_line": "if d[i][j] < K:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] < K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if d[i][j] >= K:",
      "mutated_line": "if d[i][j] == K:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] == K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result = '' if I == J == 0 else bin(J)[2:].zfill(I)",
      "mutated_line": "result = '' if I == J == 1 else bin(J)[2:].zfill(I)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 1 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result = '' if I == J == 0 else bin(J)[2:].zfill(I)",
      "mutated_line": "result = '' if I == J == -1 else bin(J)[2:].zfill(I)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == -1 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result = '' if I == J == 0 else bin(J)[2:].zfill(I)",
      "mutated_line": "result = '' if I == J == 1 else bin(J)[2:].zfill(I)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 1 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "d = [[1] * 2 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[1] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "d = [[-1] * 2 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[-1] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "d = [[1] * 2 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[1] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "d = [[0] * 3 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 3 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "d = [[0] * 1 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 1 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "d = [[0] * 0 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 0 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "d = [[0] * 1 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 1 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "d = [[0] * -2 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * -2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "f = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "f = [[1] * 2 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[1] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "f = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "f = [[-1] * 2 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[-1] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "f = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "f = [[1] * 2 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[1] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "f = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "f = [[0] * 3 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 3 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "f = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "f = [[0] * 1 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 1 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "f = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "f = [[0] * 0 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 0 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "f = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "f = [[0] * 1 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 1 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "f = [[0] * 2 ** N for _ in Q]",
      "mutated_line": "f = [[0] * -2 ** N for _ in Q]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * -2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in R(1 << i):",
      "mutated_line": "for j in R(2 << i):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(2 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in R(1 << i):",
      "mutated_line": "for j in R(0 << i):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(0 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in R(1 << i):",
      "mutated_line": "for j in R(0 << i):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(0 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in R(1 << i):",
      "mutated_line": "for j in R(-1 << i):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(-1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t = j >> i - 1 & 1",
      "mutated_line": "t = j >> i - 1 & 2",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 2\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t = j >> i - 1 & 1",
      "mutated_line": "t = j >> i - 1 & 0",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 0\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t = j >> i - 1 & 1",
      "mutated_line": "t = j >> i - 1 & 0",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 0\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t = j >> i - 1 & 1",
      "mutated_line": "t = j >> i - 1 & -1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & -1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r <= i and j >> i - 1 - r & 1 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r <= i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r >= i and j >> i - 1 - r & 1 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r >= i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r != i and j >> i - 1 - r & 1 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r != i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i and j >> i - 1 - r & 1 != t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 != t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "r += 1",
      "mutated_line": "r += 2",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 2\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "r += 1",
      "mutated_line": "r += 0",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 0\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "r += 1",
      "mutated_line": "r += 0",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 0\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "r += 1",
      "mutated_line": "r += -1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += -1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for k in R(i + 1, N + 1):",
      "mutated_line": "for k in R(i + 2, N + 1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 2, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for k in R(i + 1, N + 1):",
      "mutated_line": "for k in R(i + 0, N + 1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 0, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for k in R(i + 1, N + 1):",
      "mutated_line": "for k in R(i + 0, N + 1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 0, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for k in R(i + 1, N + 1):",
      "mutated_line": "for k in R(i + -1, N + 1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + -1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for k in R(i + 1, N + 1):",
      "mutated_line": "for k in R(i + 1, N + 2):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 2):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for k in R(i + 1, N + 1):",
      "mutated_line": "for k in R(i + 1, N + 0):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 0):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for k in R(i + 1, N + 1):",
      "mutated_line": "for k in R(i + 1, N + 0):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 0):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for k in R(i + 1, N + 1):",
      "mutated_line": "for k in R(i + 1, N + -1):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + -1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "m = (1 << z) - 1",
      "mutated_line": "m = (1 << z) - 2",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 2\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "m = (1 << z) - 1",
      "mutated_line": "m = (1 << z) - 0",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 0\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "m = (1 << z) - 1",
      "mutated_line": "m = (1 << z) - 0",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 0\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "m = (1 << z) - 1",
      "mutated_line": "m = (1 << z) - -1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - -1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if r != z:",
      "mutated_line": "if r == z:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r == z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] -= d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] -= d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in R(1 << i):",
      "mutated_line": "for j in R(2 << i):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(2 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in R(1 << i):",
      "mutated_line": "for j in R(0 << i):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(0 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in R(1 << i):",
      "mutated_line": "for j in R(0 << i):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(0 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in R(1 << i):",
      "mutated_line": "for j in R(-1 << i):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(-1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t = j >> i - 1 & 1",
      "mutated_line": "t = j >> i + 1 & 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i + 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t = j >> i - 1 & 1",
      "mutated_line": "t = j >> i * 1 & 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i * 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i and j >> i - 1 - r | 1 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r | 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "m = (1 << z) - 1",
      "mutated_line": "m = (2 << z) - 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (2 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "m = (1 << z) - 1",
      "mutated_line": "m = (0 << z) - 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (0 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "m = (1 << z) - 1",
      "mutated_line": "m = (0 << z) - 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (0 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "m = (1 << z) - 1",
      "mutated_line": "m = (-1 << z) - 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (-1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in R(1 << k):",
      "mutated_line": "for j in R(2 << k):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(2 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in R(1 << k):",
      "mutated_line": "for j in R(0 << k):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(0 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in R(1 << k):",
      "mutated_line": "for j in R(0 << k):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(0 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in R(1 << k):",
      "mutated_line": "for j in R(-1 << k):",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(-1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "r = f[z][j & m]",
      "mutated_line": "r = f[z][j | m]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j | m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t = j >> i - 1 & 1",
      "mutated_line": "t = j >> i - 2 & 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 2 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t = j >> i - 1 & 1",
      "mutated_line": "t = j >> i - 0 & 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 0 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t = j >> i - 1 & 1",
      "mutated_line": "t = j >> i - 0 & 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 0 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t = j >> i - 1 & 1",
      "mutated_line": "t = j >> i - -1 & 1",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - -1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i and j >> i - 1 - r & 2 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 2 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i and j >> i - 1 - r & 0 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 0 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i and j >> i - 1 - r & 0 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 0 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i and j >> i - 1 - r & -1 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & -1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r & (j & (1 << z - r) - 1)] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r & (j & (1 << z - r) - 1)] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r ^ j & (1 << z - r) - 1] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r ^ j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result = '' if I == J == 0 else bin(J)[2:].zfill(I)",
      "mutated_line": "result = '' if I == J == 0 else bin(J)[3:].zfill(I)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[3:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result = '' if I == J == 0 else bin(J)[2:].zfill(I)",
      "mutated_line": "result = '' if I == J == 0 else bin(J)[1:].zfill(I)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[1:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result = '' if I == J == 0 else bin(J)[2:].zfill(I)",
      "mutated_line": "result = '' if I == J == 0 else bin(J)[0:].zfill(I)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[0:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result = '' if I == J == 0 else bin(J)[2:].zfill(I)",
      "mutated_line": "result = '' if I == J == 0 else bin(J)[1:].zfill(I)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[1:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result = '' if I == J == 0 else bin(J)[2:].zfill(I)",
      "mutated_line": "result = '' if I == J == 0 else bin(J)[-2:].zfill(I)",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[-2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i and j >> i - 1 + r & 1 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 + r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i and j >> (i - 1) * r & 1 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> (i - 1) * r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k + r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k + r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k * r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k * r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r | (j | (1 << z - r) - 1)] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | (j | (1 << z - r) - 1)] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i and j >> i + 1 - r & 1 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i + 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i and j >> i * 1 - r & 1 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i * 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z + r | j & (1 << z - r) - 1] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z + r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z * r | j & (1 << z - r) - 1] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z * r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r | j & (1 << z - r) + 1] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) + 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r | j & (1 << z - r) * 1] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) * 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i and j >> i - 2 - r & 1 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 2 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i and j >> i - 0 - r & 1 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 0 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i and j >> i - 0 - r & 1 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 0 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while r < i and j >> i - 1 - r & 1 == t:",
      "mutated_line": "while r < i and j >> i - -1 - r & 1 == t:",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - -1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 2] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 2] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 0] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 0] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 0] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - 0] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - -1] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z - r) - -1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r | j & (2 << z - r) - 1] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (2 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r | j & (0 << z - r) - 1] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (0 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r | j & (0 << z - r) - 1] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (0 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r | j & (-1 << z - r) - 1] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (-1 << z - r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r | j & (1 << z + r) - 1] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z + r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d[k - r][j >> z << z - r | j & (1 << z - r) - 1] += d[k][j]",
      "mutated_line": "d[k - r][j >> z << z - r | j & (1 << z * r) - 1] += d[k][j]",
      "code": "def find_longest_subsequence(N, K, strings):\n    R = range\n    Q = R(N + 1)\n    d = [[0] * 2 ** N for _ in Q]\n    f = [[0] * 2 ** N for _ in Q]\n    for i in Q:\n        for (j, c) in enumerate(strings[i]):\n            d[i][j] = int(c)\n    for i in R(1, N + 1):\n        for j in R(1 << i):\n            t = j >> i - 1 & 1\n            r = 0\n            while r < i and j >> i - 1 - r & 1 == t:\n                r += 1\n            f[i][j] = r\n    for i in Q:\n        for k in R(i + 1, N + 1):\n            z = k - i\n            m = (1 << z) - 1\n            for j in R(1 << k):\n                d[i][j >> z] += d[k][j]\n                r = f[z][j & m]\n                if r != z:\n                    d[k - r][j >> z << z - r | j & (1 << z * r) - 1] += d[k][j]\n    (I, J) = (0, 0)\n    for i in Q:\n        for j in R(1 << i):\n            if d[i][j] >= K:\n                I = i\n                J = j\n                break\n    result = '' if I == J == 0 else bin(J)[2:].zfill(I)\n    return result"
    }
  ]
}