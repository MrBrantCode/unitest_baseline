{
  "task_id": "taco_10492",
  "entry_point": "sort_permutation",
  "mutant_count": 186,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def sort_permutation(n, p):\n    i = 1\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def sort_permutation(n, p):\n    i = -1\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def sort_permutation(n, p):\n    i = 1\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while i < n:",
      "mutated_line": "while i <= n:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i <= n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while i < n:",
      "mutated_line": "while i >= n:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i >= n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while i < n:",
      "mutated_line": "while i != n:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i != n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if p[i] - 1 == i:",
      "mutated_line": "if p[i] - 1 != i:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 != i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i -= 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if p[i] - 1 == i:",
      "mutated_line": "if p[i] + 1 == i:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] + 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if p[i] - 1 == i:",
      "mutated_line": "if p[i] * 1 == i:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] * 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 2\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 0\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 0\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += -1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "pos2 = p[i] - 1",
      "mutated_line": "pos2 = p[i] + 1",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] + 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "pos2 = p[i] - 1",
      "mutated_line": "pos2 = p[i] * 1",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] * 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if abs(pos2 - i) >= n // 2:",
      "mutated_line": "if abs(pos2 - i) > n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) > n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if abs(pos2 - i) >= n // 2:",
      "mutated_line": "if abs(pos2 - i) < n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) < n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if abs(pos2 - i) >= n // 2:",
      "mutated_line": "if abs(pos2 - i) == n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) == n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if p[i] - 1 == i:",
      "mutated_line": "if p[i] - 2 == i:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 2 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if p[i] - 1 == i:",
      "mutated_line": "if p[i] - 0 == i:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 0 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if p[i] - 1 == i:",
      "mutated_line": "if p[i] - 0 == i:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 0 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if p[i] - 1 == i:",
      "mutated_line": "if p[i] - -1 == i:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - -1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos2 = p[i] - 1",
      "mutated_line": "pos2 = p[i] - 2",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 2\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos2 = p[i] - 1",
      "mutated_line": "pos2 = p[i] - 0",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 0\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos2 = p[i] - 1",
      "mutated_line": "pos2 = p[i] - 0",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 0\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos2 = p[i] - 1",
      "mutated_line": "pos2 = p[i] - -1",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - -1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if abs(pos2 - i) >= n // 2:",
      "mutated_line": "if abs(pos2 - i) >= n / 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n / 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if abs(pos2 - i) >= n // 2:",
      "mutated_line": "if abs(pos2 - i) >= n * 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n * 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 2 or pos2 < n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 or pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if abs(pos2 - i) >= n // 2:",
      "mutated_line": "if abs(pos2 + i) >= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 + i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if abs(pos2 - i) >= n // 2:",
      "mutated_line": "if abs(pos2 * i) >= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 * i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if abs(pos2 - i) >= n // 2:",
      "mutated_line": "if abs(pos2 - i) >= n // 3:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 3:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if abs(pos2 - i) >= n // 2:",
      "mutated_line": "if abs(pos2 - i) >= n // 1:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 1:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if abs(pos2 - i) >= n // 2:",
      "mutated_line": "if abs(pos2 - i) >= n // 0:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 0:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if abs(pos2 - i) >= n // 2:",
      "mutated_line": "if abs(pos2 - i) >= n // 1:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 1:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if abs(pos2 - i) >= n // 2:",
      "mutated_line": "if abs(pos2 - i) >= n // -2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // -2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i <= n // 2 and pos2 < n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i <= n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i >= n // 2 and pos2 < n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i >= n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i != n // 2 and pos2 < n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i != n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 <= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 <= n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 >= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 != n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 != n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 2 or pos2 >= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 or pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n / 2 and pos2 < n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n / 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n * 2 and pos2 < n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n * 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 < n / 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n / 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 < n * 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n * 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i <= n // 2 and pos2 >= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i <= n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i >= n // 2 and pos2 >= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i >= n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i != n // 2 and pos2 >= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i != n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 > n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 > n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 < n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 == n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 == n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i - 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i - 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i * 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i * 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 - 1), max(i + 1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 - 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 * 1), max(i + 1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 * 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 1), max(i - 1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i - 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 1), max(i * 1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i * 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 - 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 - 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 * 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 * 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 3 and pos2 < n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 3 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 1 and pos2 < n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 1 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 0 and pos2 < n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 0 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 1 and pos2 < n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 1 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // -2 and pos2 < n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // -2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 < n // 3:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 3:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 < n // 1:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 1:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 < n // 0:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 0:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 < n // 1:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 1:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif i < n // 2 and pos2 < n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 < n // -2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // -2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i - 1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i - 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i * 1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i * 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "res.append((pos2 + 1, n))",
      "mutated_line": "res.append((pos2 - 1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 - 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "res.append((pos2 + 1, n))",
      "mutated_line": "res.append((pos2 * 1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 * 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i - 1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i - 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i * 1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i * 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n / 2 and pos2 >= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n / 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n * 2 and pos2 >= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n * 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 >= n / 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n / 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 >= n * 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n * 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 2, pos2 + 1), max(i + 1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 2, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 0, pos2 + 1), max(i + 1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 0, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 0, pos2 + 1), max(i + 1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 0, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + -1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + -1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 2), max(i + 1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 2), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 0), max(i + 1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 0), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 0), max(i + 1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 0), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + -1), max(i + 1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + -1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 1), max(i + 2, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 2, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 1), max(i + 0, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 0, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 1), max(i + 0, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 0, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 1), max(i + -1, pos2 + 1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + -1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 2)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 2)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 0)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 0)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 0)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 0)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))",
      "mutated_line": "res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + -1)))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + -1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + 2, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 2, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + 0, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 0, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + 0, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 0, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + -1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + -1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res.append((pos2 + 1, n))",
      "mutated_line": "res.append((pos2 + 2, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 2, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res.append((pos2 + 1, n))",
      "mutated_line": "res.append((pos2 + 0, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 0, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res.append((pos2 + 1, n))",
      "mutated_line": "res.append((pos2 + 0, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 0, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res.append((pos2 + 1, n))",
      "mutated_line": "res.append((pos2 + -1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + -1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + 2, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 2, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + 0, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 0, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + 0, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 0, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + -1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + -1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 3 and pos2 >= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 3 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 1 and pos2 >= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 1 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 0 and pos2 >= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 0 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 1 and pos2 >= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 1 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // -2 and pos2 >= n // 2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // -2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 >= n // 3:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 3:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 >= n // 1:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 1:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 >= n // 0:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 0:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 >= n // 1:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 1:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif i < n // 2 and pos2 >= n // 2:",
      "mutated_line": "elif i < n // 2 and pos2 >= n // -2:",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // -2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i - 1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i - 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i * 1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i * 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((2, pos2 + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((2, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((0, pos2 + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((0, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((0, pos2 + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((0, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((-1, pos2 + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((-1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 - 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 - 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 * 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 * 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res.append((1, n))",
      "mutated_line": "res.append((2, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((2, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res.append((1, n))",
      "mutated_line": "res.append((0, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((0, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res.append((1, n))",
      "mutated_line": "res.append((0, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((0, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res.append((1, n))",
      "mutated_line": "res.append((-1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((-1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((2, pos2 + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((2, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((0, pos2 + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((0, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((0, pos2 + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((0, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((-1, pos2 + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((-1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 - 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 - 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 * 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 * 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i - 1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i - 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i * 1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i * 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((2, i + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((2, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((0, i + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((0, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((0, i + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((0, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((-1, i + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((-1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((1, i - 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i - 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((1, i * 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i * 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((2, pos2 + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((2, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((0, pos2 + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((0, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((0, pos2 + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((0, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((-1, pos2 + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((-1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 - 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 - 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 * 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 * 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((2, i + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((2, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((0, i + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((0, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((0, i + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((0, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((-1, i + 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((-1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((1, i - 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i - 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((1, i * 1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i * 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + 2, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 2, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + 0, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 0, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + 0, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 0, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + -1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + -1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 + 2))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 2))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 + 0))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 0))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 + 0))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 0))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 + -1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + -1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 + 2))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 2))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 + 0))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 0))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 + 0))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 0))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 + -1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + -1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + 2, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 2, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + 0, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 0, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + 0, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 0, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res.append((i + 1, n))",
      "mutated_line": "res.append((i + -1, n))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + -1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((1, i + 2))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 2))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((1, i + 0))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 0))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((1, i + 0))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 0))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((1, i + -1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + -1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 + 2))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 2))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 + 0))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 0))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 + 0))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 0))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res.append((1, pos2 + 1))",
      "mutated_line": "res.append((1, pos2 + -1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + -1))\n                res.append((1, i + 1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((1, i + 2))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 2))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((1, i + 0))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 0))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((1, i + 0))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + 0))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res.append((1, i + 1))",
      "mutated_line": "res.append((1, i + -1))",
      "code": "def sort_permutation(n, p):\n    i = 0\n    res = []\n    while i < n:\n        if p[i] - 1 == i:\n            i += 1\n        else:\n            pos2 = p[i] - 1\n            if abs(pos2 - i) >= n // 2:\n                res.append((min(i + 1, pos2 + 1), max(i + 1, pos2 + 1)))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 < n // 2:\n                res.append((i + 1, n))\n                res.append((pos2 + 1, n))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            elif i < n // 2 and pos2 >= n // 2:\n                res.append((i + 1, n))\n                res.append((1, pos2 + 1))\n                res.append((1, n))\n                res.append((1, pos2 + 1))\n                res.append((i + 1, n))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n            else:\n                res.append((1, i + 1))\n                res.append((1, pos2 + 1))\n                res.append((1, i + -1))\n                (p[i], p[pos2]) = (p[pos2], p[i])\n    return (len(res), res)"
    }
  ]
}