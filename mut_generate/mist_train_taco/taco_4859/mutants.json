{
  "task_id": "taco_4859",
  "entry_point": "process_sequence_operations",
  "mutant_count": 183,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "i += self.n - 1",
      "mutated_line": "i -= self.n - 1",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i -= self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 + 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 + 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 * 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 * 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if com == 0:",
      "mutated_line": "if com != 0:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com != 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "n = 1",
      "mutated_line": "n = 2",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 2\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "n = 1",
      "mutated_line": "n = 0",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 0\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "n = 1",
      "mutated_line": "n = 0",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 0\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "n = 1",
      "mutated_line": "n = -1",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = -1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while n < N:",
      "mutated_line": "while n <= N:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n <= N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while n < N:",
      "mutated_line": "while n >= N:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n >= N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while n < N:",
      "mutated_line": "while n != N:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n != N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] / (2 * n - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] / (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] + (2 * n - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] + (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] ** (2 * n - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] ** (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i += self.n - 1",
      "mutated_line": "i += self.n + 1",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n + 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i += self.n - 1",
      "mutated_line": "i += self.n * 1",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n * 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while i > 0:",
      "mutated_line": "while i >= 0:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i >= 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while i > 0:",
      "mutated_line": "while i <= 0:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i <= 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while i > 0:",
      "mutated_line": "while i != 0:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i != 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if t <= l or s >= r:",
      "mutated_line": "if t <= l and s >= r:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l and s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if s <= l and t >= r:",
      "mutated_line": "if s <= l or t >= r:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l or t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 2 * 31 - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 * 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 2 + 31 - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 + 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 2)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 0)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 0)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 0)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 0)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - -1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - -1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if com == 0:",
      "mutated_line": "if com == 1:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 1:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if com == 0:",
      "mutated_line": "if com == -1:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == -1:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if com == 0:",
      "mutated_line": "if com == 1:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 1:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "elif com == 1:",
      "mutated_line": "elif com != 1:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com != 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n <<= 1",
      "mutated_line": "n <<= 2",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 2\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n <<= 1",
      "mutated_line": "n <<= 0",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 0\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n <<= 1",
      "mutated_line": "n <<= 0",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 0\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n <<= 1",
      "mutated_line": "n <<= -1",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= -1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] * (2 * n + 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n + 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] * (2 * n * 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n * 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += self.n - 1",
      "mutated_line": "i += self.n - 2",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 2\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += self.n - 1",
      "mutated_line": "i += self.n - 0",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 0\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += self.n - 1",
      "mutated_line": "i += self.n - 0",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 0\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += self.n - 1",
      "mutated_line": "i += self.n - -1",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - -1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 1:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while i > 0:",
      "mutated_line": "while i > -1:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > -1:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 1:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "i = (i - 1) // 2",
      "mutated_line": "i = (i - 1) / 2",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) / 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "i = (i - 1) // 2",
      "mutated_line": "i = (i - 1) * 2",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) * 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return self.__find(s, t, 0, 0, self.n)",
      "mutated_line": "return self.__find(s, t, 1, 0, self.n)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 1, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return self.__find(s, t, 0, 0, self.n)",
      "mutated_line": "return self.__find(s, t, -1, 0, self.n)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, -1, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return self.__find(s, t, 0, 0, self.n)",
      "mutated_line": "return self.__find(s, t, 1, 0, self.n)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 1, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return self.__find(s, t, 0, 0, self.n)",
      "mutated_line": "return self.__find(s, t, 0, 1, self.n)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 1, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return self.__find(s, t, 0, 0, self.n)",
      "mutated_line": "return self.__find(s, t, 0, -1, self.n)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, -1, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return self.__find(s, t, 0, 0, self.n)",
      "mutated_line": "return self.__find(s, t, 0, 1, self.n)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 1, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if t <= l or s >= r:",
      "mutated_line": "if t < l or s >= r:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t < l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if t <= l or s >= r:",
      "mutated_line": "if t > l or s >= r:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t > l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if t <= l or s >= r:",
      "mutated_line": "if t == l or s >= r:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t == l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if t <= l or s >= r:",
      "mutated_line": "if t <= l or s > r:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s > r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if t <= l or s >= r:",
      "mutated_line": "if t <= l or s < r:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s < r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if t <= l or s >= r:",
      "mutated_line": "if t <= l or s == r:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s == r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if s <= l and t >= r:",
      "mutated_line": "if s < l and t >= r:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s < l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if s <= l and t >= r:",
      "mutated_line": "if s > l and t >= r:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s > l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if s <= l and t >= r:",
      "mutated_line": "if s == l and t >= r:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s == l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if s <= l and t >= r:",
      "mutated_line": "if s <= l and t > r:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t > r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if s <= l and t >= r:",
      "mutated_line": "if s <= l and t < r:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t < r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if s <= l and t >= r:",
      "mutated_line": "if s <= l and t == r:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t == r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k - 1, l, (l + r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k - 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k * 1, l, (l + r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k * 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) / 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) / 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) * 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) * 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k - 2, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k - 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k * 2, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k * 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) / 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) / 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) * 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) * 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 3 ** 31 - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 3 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 1 ** 31 - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 1 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 0 ** 31 - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 0 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 1 ** 31 - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 1 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), -2 ** 31 - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), -2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 32 - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 32 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 30 - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 30 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 0 - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 0 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 1 - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 1 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)",
      "mutated_line": "st = SegTree(n, lambda x, y: min(x, y), 2 ** -31 - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** -31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "elif com == 1:",
      "mutated_line": "elif com == 2:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 2:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "elif com == 1:",
      "mutated_line": "elif com == 0:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 0:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "elif com == 1:",
      "mutated_line": "elif com == 0:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 0:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "elif com == 1:",
      "mutated_line": "elif com == -1:",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == -1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] * (2 / n - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 / n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] * (2 + n - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 + n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] * (2 ** n - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 ** n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] * (2 * n - 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 2)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] * (2 * n - 0)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 0)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] * (2 * n - 0)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 0)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] * (2 * n - -1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - -1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "i = (i - 1) // 2",
      "mutated_line": "i = (i + 1) // 2",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i + 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "i = (i - 1) // 2",
      "mutated_line": "i = i * 1 // 2",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = i * 1 // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = (i - 1) // 2",
      "mutated_line": "i = (i - 1) // 3",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 3\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = (i - 1) // 2",
      "mutated_line": "i = (i - 1) // 1",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 1\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = (i - 1) // 2",
      "mutated_line": "i = (i - 1) // 0",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 0\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = (i - 1) // 2",
      "mutated_line": "i = (i - 1) // 1",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 1\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = (i - 1) // 2",
      "mutated_line": "i = (i - 1) // -2",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // -2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 / k + 1, l, (l + r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 / k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 + k + 1, l, (l + r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 + k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 ** k + 1, l, (l + r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 ** k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k + 2, l, (l + r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 2, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k + 0, l, (l + r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 0, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k + 0, l, (l + r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 0, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k + -1, l, (l + r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + -1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k + 1, l, (l - r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l - r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k + 1, l, l * r // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, l * r // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 3)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 3)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 1)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 0)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 0)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 1)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // -2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // -2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 / k + 2, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 / k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 + k + 2, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 + k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 ** k + 2, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 ** k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k + 3, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 3, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k + 1, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 1, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k + 0, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 0, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k + 1, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 1, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k + -2, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + -2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k + 2, (l - r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l - r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k + 2, l * r // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, l * r // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 3, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 3, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 1, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 1, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 0, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 0, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 1, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 1, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // -2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // -2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] * (3 * n - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (3 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] * (1 * n - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (1 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] * (0 * n - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (0 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] * (1 * n - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (1 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.arr = [ini] * (2 * n - 1)",
      "mutated_line": "self.arr = [ini] * (-2 * n - 1)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (-2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = (i - 1) // 2",
      "mutated_line": "i = (i - 2) // 2",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 2) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = (i - 1) // 2",
      "mutated_line": "i = (i - 0) // 2",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 0) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = (i - 1) // 2",
      "mutated_line": "i = (i - 0) // 2",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 0) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i = (i - 1) // 2",
      "mutated_line": "i = (i - -1) // 2",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - -1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i - 1], self.arr[2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i - 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i * 1], self.arr[2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i * 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i - 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i - 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i * 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i * 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 3 * k + 1, l, (l + r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 3 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 1 * k + 1, l, (l + r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 1 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 0 * k + 1, l, (l + r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 0 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, 1 * k + 1, l, (l + r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 1 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)",
      "mutated_line": "vl = self.__find(s, t, -2 * k + 1, l, (l + r) // 2)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, -2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 3 * k + 2, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 3 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 1 * k + 2, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 1 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 0 * k + 2, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 0 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, 1 * k + 2, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 1 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)",
      "mutated_line": "vr = self.__find(s, t, -2 * k + 2, (l + r) // 2, r)",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, -2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "results.append(st.find(x, y + 1))",
      "mutated_line": "results.append(st.find(x, y - 1))",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "results.append(st.find(x, y + 1))",
      "mutated_line": "results.append(st.find(x, y * 1))",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y * 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 / i + 1], self.arr[2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 / i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 + i + 1], self.arr[2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 + i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 ** i + 1], self.arr[2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 ** i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 2], self.arr[2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 2], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 0], self.arr[2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 0], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 0], self.arr[2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 0], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + -1], self.arr[2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + -1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 / i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 / i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 + i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 + i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 ** i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 ** i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 3])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 3])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 1])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 1])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 0])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 0])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 1])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 1])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + -2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + -2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "results.append(st.find(x, y + 1))",
      "mutated_line": "results.append(st.find(x, y + 2))",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 2))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "results.append(st.find(x, y + 1))",
      "mutated_line": "results.append(st.find(x, y + 0))",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 0))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "results.append(st.find(x, y + 1))",
      "mutated_line": "results.append(st.find(x, y + 0))",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 0))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "results.append(st.find(x, y + 1))",
      "mutated_line": "results.append(st.find(x, y + -1))",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[3 * i + 1], self.arr[2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[3 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[1 * i + 1], self.arr[2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[1 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[0 * i + 1], self.arr[2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[0 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[1 * i + 1], self.arr[2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[1 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[-2 * i + 1], self.arr[2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[-2 * i + 1], self.arr[2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[3 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[3 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[1 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[1 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[0 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[0 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[1 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[1 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[2 * i + 2])",
      "mutated_line": "self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[-2 * i + 2])",
      "code": "def process_sequence_operations(n, q, queries):\n\n    class SegTree:\n\n        def __init__(self, N, f, ini):\n            n = 1\n            while n < N:\n                n <<= 1\n            self.n = n\n            self.arr = [ini] * (2 * n - 1)\n            (self.f, self.ini) = (f, ini)\n\n        def update(self, i, val):\n            i += self.n - 1\n            self.arr[i] = val\n            while i > 0:\n                i = (i - 1) // 2\n                self.arr[i] = self.f(self.arr[2 * i + 1], self.arr[-2 * i + 2])\n\n        def find(self, s, t):\n            return self.__find(s, t, 0, 0, self.n)\n\n        def __find(self, s, t, k, l, r):\n            if t <= l or s >= r:\n                return self.ini\n            if s <= l and t >= r:\n                return self.arr[k]\n            vl = self.__find(s, t, 2 * k + 1, l, (l + r) // 2)\n            vr = self.__find(s, t, 2 * k + 2, (l + r) // 2, r)\n            return self.f(vl, vr)\n    st = SegTree(n, lambda x, y: min(x, y), 2 ** 31 - 1)\n    results = []\n    for (com, x, y) in queries:\n        if com == 0:\n            st.update(x, y)\n        elif com == 1:\n            results.append(st.find(x, y + 1))\n    return results"
    }
  ]
}