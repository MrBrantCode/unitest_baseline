{
  "task_id": "taco_8041",
  "entry_point": "build",
  "mutant_count": 68,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "base = 1",
      "mutated_line": "base = 2",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 2\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "base = 1",
      "mutated_line": "base = 0",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 0\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "base = 1",
      "mutated_line": "base = 0",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 0\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "base = 1",
      "mutated_line": "base = -1",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = -1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "base *= x - xi",
      "mutated_line": "base /= x - xi",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base /= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "N = d + 3",
      "mutated_line": "N = d - 3",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d - 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "N = d + 3",
      "mutated_line": "N = d * 3",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d * 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cnts = [0] * N",
      "mutated_line": "cnts = [0] / N",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] / N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cnts = [0] * N",
      "mutated_line": "cnts = [0] + N",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] + N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cnts = [0] * N",
      "mutated_line": "cnts = [0] ** N",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] ** N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = 1",
      "mutated_line": "res = 2",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 2\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 0\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 0\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = 1",
      "mutated_line": "res = -1",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = -1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "res *= x - xi",
      "mutated_line": "res /= x - xi",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res /= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "base *= x - xi",
      "mutated_line": "base *= x + xi",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x + xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "base *= x - xi",
      "mutated_line": "base *= x * xi",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x * xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "N = d + 3",
      "mutated_line": "N = d + 4",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 4\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "N = d + 3",
      "mutated_line": "N = d + 2",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 2\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "N = d + 3",
      "mutated_line": "N = d + 0",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 0\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "N = d + 3",
      "mutated_line": "N = d + 1",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 1\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "N = d + 3",
      "mutated_line": "N = d + -3",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + -3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for X in combinations(range(N), d + 1):",
      "mutated_line": "for X in combinations(range(N), d - 1):",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d - 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for X in combinations(range(N), d + 1):",
      "mutated_line": "for X in combinations(range(N), d * 1):",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d * 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [0] / N",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] / N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [0] + N",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] + N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [0] ** N",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] ** N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x == xi:",
      "mutated_line": "if x != xi:",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x != xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res *= x - xi",
      "mutated_line": "res *= x + xi",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x + xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res *= x - xi",
      "mutated_line": "res *= x * xi",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x * xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A.append(Y[x] / res)",
      "mutated_line": "A.append(Y[x] * res)",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] * res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A.append(Y[x] / res)",
      "mutated_line": "A.append(Y[x] // res)",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] // res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))",
      "mutated_line": "return sum((base / (x - xi) / a for (xi, a) in zip(X, A)))",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) / a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))",
      "mutated_line": "return sum((base / (x - xi) + a for (xi, a) in zip(X, A)))",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) + a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))",
      "mutated_line": "return sum(((base / (x - xi)) ** a for (xi, a) in zip(X, A)))",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum(((base / (x - xi)) ** a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cnts = [0] * N",
      "mutated_line": "cnts = [1] * N",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [1] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cnts = [0] * N",
      "mutated_line": "cnts = [-1] * N",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [-1] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cnts = [0] * N",
      "mutated_line": "cnts = [1] * N",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [1] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for X in combinations(range(N), d + 1):",
      "mutated_line": "for X in combinations(range(N), d + 2):",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 2):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for X in combinations(range(N), d + 1):",
      "mutated_line": "for X in combinations(range(N), d + 0):",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 0):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for X in combinations(range(N), d + 1):",
      "mutated_line": "for X in combinations(range(N), d + 0):",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 0):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for X in combinations(range(N), d + 1):",
      "mutated_line": "for X in combinations(range(N), d + -1):",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + -1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "U[x] = 1",
      "mutated_line": "U[x] = 2",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 2\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "U[x] = 1",
      "mutated_line": "U[x] = 0",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 0\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "U[x] = 1",
      "mutated_line": "U[x] = 0",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 0\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "U[x] = 1",
      "mutated_line": "U[x] = -1",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = -1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if abs(Y[i] - res) > 0.5:",
      "mutated_line": "if abs(Y[i] - res) >= 0.5:",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) >= 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if abs(Y[i] - res) > 0.5:",
      "mutated_line": "if abs(Y[i] - res) <= 0.5:",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) <= 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if abs(Y[i] - res) > 0.5:",
      "mutated_line": "if abs(Y[i] - res) != 0.5:",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) != 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "cnts[i] += 1",
      "mutated_line": "cnts[i] -= 1",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] -= 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))",
      "mutated_line": "return sum((base * (x - xi) * a for (xi, a) in zip(X, A)))",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base * (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))",
      "mutated_line": "return sum((base // (x - xi) * a for (xi, a) in zip(X, A)))",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base // (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [1] * N",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [1] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [-1] * N",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [-1] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [1] * N",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [1] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if abs(Y[i] - res) > 0.5:",
      "mutated_line": "if abs(Y[i] - res) > 1.5:",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 1.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if abs(Y[i] - res) > 0.5:",
      "mutated_line": "if abs(Y[i] - res) > -0.5:",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > -0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if abs(Y[i] - res) > 0.5:",
      "mutated_line": "if abs(Y[i] - res) > 0:",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if abs(Y[i] - res) > 0.5:",
      "mutated_line": "if abs(Y[i] - res) > 1:",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 1:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if abs(Y[i] - res) > 0.5:",
      "mutated_line": "if abs(Y[i] - res) > -0.5:",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > -0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cnts[i] += 1",
      "mutated_line": "cnts[i] += 2",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 2\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cnts[i] += 1",
      "mutated_line": "cnts[i] += 0",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 0\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cnts[i] += 1",
      "mutated_line": "cnts[i] += 0",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 0\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cnts[i] += 1",
      "mutated_line": "cnts[i] += -1",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += -1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))",
      "mutated_line": "return sum((base / (x + xi) * a for (xi, a) in zip(X, A)))",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x + xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))",
      "mutated_line": "return sum((base / (x * xi) * a for (xi, a) in zip(X, A)))",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x * xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] - res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if abs(Y[i] - res) > 0.5:",
      "mutated_line": "if abs(Y[i] + res) > 0.5:",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] + res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if abs(Y[i] - res) > 0.5:",
      "mutated_line": "if abs(Y[i] * res) > 0.5:",
      "code": "from itertools import combinations\n\ndef build(X, Y):\n    A = []\n    for x in X:\n        res = 1\n        for xi in X:\n            if x == xi:\n                continue\n            res *= x - xi\n        A.append(Y[x] / res)\n    return A\n\ndef calc(X, A, x):\n    base = 1\n    for xi in X:\n        base *= x - xi\n    return sum((base / (x - xi) * a for (xi, a) in zip(X, A)))\n\ndef identify_faulty_value(d, Y):\n    N = d + 3\n    cnts = [0] * N\n    for X in combinations(range(N), d + 1):\n        U = [0] * N\n        for x in X:\n            U[x] = 1\n        A = build(X, Y)\n        for i in range(N):\n            if U[i]:\n                continue\n            res = calc(X, A, i)\n            if abs(Y[i] * res) > 0.5:\n                cnts[i] += 1\n    return cnts.index(max(cnts))"
    }
  ]
}