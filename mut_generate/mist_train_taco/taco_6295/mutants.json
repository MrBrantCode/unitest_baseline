{
  "task_id": "taco_6295",
  "entry_point": "count_ways_to_cover_land",
  "mutant_count": 294,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 - 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 * 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D[1][L[0]] = 1",
      "mutated_line": "D[1][L[0]] = 2",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 2\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D[1][L[0]] = 1",
      "mutated_line": "D[1][L[0]] = 0",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 0\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D[1][L[0]] = 1",
      "mutated_line": "D[1][L[0]] = 0",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 0\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D[1][L[0]] = 1",
      "mutated_line": "D[1][L[0]] = -1",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = -1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 * 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 + 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 8\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 6\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 0\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 1\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + -7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] / (X + 1) for i in range(N // 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] / (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] + (X + 1) for i in range(N // 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] + (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] ** (X + 1) for i in range(N // 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] ** (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 11 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 9 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 0 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 1 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = -10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 10 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 8 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 0 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 1 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** -9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "L = sorted(L, reverse=True)",
      "mutated_line": "L = sorted(L, reverse=False)",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=False)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X - 1) for i in range(N // 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X - 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X * 1) for i in range(N // 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X * 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D[1][L[0]] = 1",
      "mutated_line": "D[2][L[0]] = 1",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[2][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D[1][L[0]] = 1",
      "mutated_line": "D[0][L[0]] = 1",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[0][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D[1][L[0]] = 1",
      "mutated_line": "D[0][L[0]] = 1",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[0][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D[1][L[0]] = 1",
      "mutated_line": "D[-1][L[0]] = 1",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[-1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D[1][L[0]] = 1",
      "mutated_line": "D[1][L[1]] = 1",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[1]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D[1][L[0]] = 1",
      "mutated_line": "D[1][L[-1]] = 1",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[-1]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "D[1][L[0]] = 1",
      "mutated_line": "D[1][L[1]] = 1",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[1]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for l in L[1:]:",
      "mutated_line": "for l in L[2:]:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[2:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for l in L[1:]:",
      "mutated_line": "for l in L[0:]:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[0:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for l in L[1:]:",
      "mutated_line": "for l in L[0:]:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[0:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for l in L[1:]:",
      "mutated_line": "for l in L[-1:]:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[-1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] / (X + 1) for i in range(N // 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] / (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] + (X + 1) for i in range(N // 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] + (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] ** (X + 1) for i in range(N // 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] ** (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(2, N // 2 + 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(2, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(0, N // 2 + 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(0, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(0, N // 2 + 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(0, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(-1, N // 2 + 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(-1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(1, N // 2 - 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 - 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(1, N // 2 * 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 * 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return D[1][X]",
      "mutated_line": "return D[2][X]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[2][X]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return D[1][X]",
      "mutated_line": "return D[0][X]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[0][X]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return D[1][X]",
      "mutated_line": "return D[0][X]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[0][X]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return D[1][X]",
      "mutated_line": "return D[-1][X]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[-1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[1] * (X + 1) for i in range(N // 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[1] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[-1] * (X + 1) for i in range(N // 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[-1] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[1] * (X + 1) for i in range(N // 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[1] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 2) for i in range(N // 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 2) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 0) for i in range(N // 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 0) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 0) for i in range(N // 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 0) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + -1) for i in range(N // 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + -1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 1) for i in range(N // 2 - 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 - 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 1) for i in range(N // 2 * 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 * 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X - 1) for i in range(N // 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X - 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X * 1) for i in range(N // 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X * 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(1, N / 2 + 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N / 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(1, N * 2 + 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N * 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(1, N // 2 + 2):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 2):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(1, N // 2 + 0):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 0):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(1, N // 2 + 0):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 0):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(1, N // 2 + -1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + -1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for s in range(X + 1):",
      "mutated_line": "for s in range(X - 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X - 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for s in range(X + 1):",
      "mutated_line": "for s in range(X * 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X * 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if D[c][s] == 0:",
      "mutated_line": "if D[c][s] != 0:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] != 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X or c + 1 <= N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X or c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) * mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) * mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = ND[c][s] + k * (s - c * (l - 1)) + mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = ND[c][s] + k * (s - c * (l - 1)) + mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if c == 1:",
      "mutated_line": "if c != 1:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c != 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 1) for i in range(N / 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N / 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 1) for i in range(N * 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N * 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 1) for i in range(N // 2 + 3)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 3)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 1)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 1) for i in range(N // 2 + 0)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 0)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 1)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 1) for i in range(N // 2 + -2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + -2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[1] * (X + 1) for i in range(N // 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[1] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[-1] * (X + 1) for i in range(N // 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[-1] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[1] * (X + 1) for i in range(N // 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[1] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 2) for i in range(N // 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 2) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 0) for i in range(N // 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 0) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 0) for i in range(N // 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 0) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + -1) for i in range(N // 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + -1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 1) for i in range(N // 2 - 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 - 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 1) for i in range(N // 2 * 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 * 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(1, N // 3 + 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 3 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(1, N // 1 + 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 1 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(1, N // 0 + 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 0 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(1, N // 1 + 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 1 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for c in range(1, N // 2 + 1):",
      "mutated_line": "for c in range(1, N // -2 + 1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // -2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for s in range(X + 1):",
      "mutated_line": "for s in range(X + 2):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 2):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for s in range(X + 1):",
      "mutated_line": "for s in range(X + 0):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 0):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for s in range(X + 1):",
      "mutated_line": "for s in range(X + 0):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 0):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for s in range(X + 1):",
      "mutated_line": "for s in range(X + -1):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + -1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if D[c][s] == 0:",
      "mutated_line": "if D[c][s] == 1:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 1:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if D[c][s] == 0:",
      "mutated_line": "if D[c][s] == -1:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == -1:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if D[c][s] == 0:",
      "mutated_line": "if D[c][s] == 1:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 1:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c < X and c + 1 <= N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c < X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c > X and c + 1 <= N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c > X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c == X and c + 1 <= N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c == X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c + 1 < N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 < N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c + 1 > N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 > N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c + 1 == N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 == N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) * mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) * mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = ND[c + 1][s + l] + k * (c + 1) + mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = ND[c + 1][s + l] + k * (c + 1) + mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] - k * (s - c * (l - 1))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] - k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = ND[c][s] * (k * (s - c * (l - 1))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = ND[c][s] * (k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(2, min(X - s - c + 2, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(2, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(0, min(X - s - c + 2, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(0, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(0, min(X - s - c + 2, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(0, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(-1, min(X - s - c + 2, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(-1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) * mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) * mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = ND[c][s + i] + k * 2 * c + mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = ND[c][s + i] + k * 2 * c + mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c == 1:",
      "mutated_line": "if c == 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 2:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c == 1:",
      "mutated_line": "if c == 0:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 0:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c == 1:",
      "mutated_line": "if c == 0:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 0:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c == 1:",
      "mutated_line": "if c == -1:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == -1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(2, min(X - s - c + 3, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(2, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(0, min(X - s - c + 3, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(0, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(0, min(X - s - c + 3, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(0, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(-1, min(X - s - c + 3, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(-1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) * mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) * mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = ND[c - 1][s + i] + k * (c - 1) * (l - i + 1) + mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = ND[c - 1][s + i] + k * (c - 1) * (l - i + 1) + mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 1) for i in range(N // 3 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 3 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 1) for i in range(N // 1 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 1 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 1) for i in range(N // 0 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 0 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 1) for i in range(N // 1 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 1 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "mutated_line": "D = [[0] * (X + 1) for i in range(N // -2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // -2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 1) for i in range(N / 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N / 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 1) for i in range(N * 2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N * 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 2)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 2)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 0)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 0)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 0)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 0)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 1) for i in range(N // 2 + -1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + -1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l - c <= X and c + 1 <= N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l - c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if (s + l) * c <= X and c + 1 <= N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if (s + l) * c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c - 1 <= N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c - 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c * 1 <= N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c * 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c + 1 <= N / 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N / 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c + 1 <= N * 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N * 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s - l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s - l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s * l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s * l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] - k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] - k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = ND[c + 1][s + l] * (k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = ND[c + 1][s + l] * (k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + k / (s - c * (l - 1))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k / (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + (k + (s - c * (l - 1)))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + (k + (s - c * (l - 1)))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + k ** (s - c * (l - 1))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k ** (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c - 2, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c - 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min((X - s - c) * 2, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min((X - s - c) * 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 2, l - 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l - 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 2, l * 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l * 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s - i] = (ND[c][s + i] + k * 2 * c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s - i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s * i] = (ND[c][s + i] + k * 2 * c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s * i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s + i] - k * 2 * c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] - k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = ND[c][s + i] * (k * 2 * c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = ND[c][s + i] * (k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c - 3, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c - 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min((X - s - c) * 3, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min((X - s - c) * 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 3, l - 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l - 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 3, l * 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l * 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s - i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s - i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s * i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s * i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] - k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] - k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = ND[c - 1][s + i] * (k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = ND[c - 1][s + i] * (k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 1) for i in range(N // 3 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 3 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 1) for i in range(N // 1 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 1 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 1) for i in range(N // 0 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 0 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 1) for i in range(N // 1 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 1 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ND = [[0] * (X + 1) for i in range(N // 2 + 1)]",
      "mutated_line": "ND = [[0] * (X + 1) for i in range(N // -2 + 1)]",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // -2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s - l + c <= X and c + 1 <= N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s - l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s * l + c <= X and c + 1 <= N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s * l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c + 2 <= N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 2 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c + 0 <= N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 0 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c + 0 <= N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 0 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c + -1 <= N // 2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + -1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c + 1 <= N // 3:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 3:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c + 1 <= N // 1:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 1:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c + 1 <= N // 0:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 0:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c + 1 <= N // 1:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 1:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if s + l + c <= X and c + 1 <= N // 2:",
      "mutated_line": "if s + l + c <= X and c + 1 <= N // -2:",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // -2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c - 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c - 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c * 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c * 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k / (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k / (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + (k + (c + 1))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + (k + (c + 1))) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k ** (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k ** (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + k * (s + c * (l - 1))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s + c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + k * (s * (c * (l - 1)))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s * (c * (l - 1)))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s + c + 2, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s + c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min((X - s) * c + 2, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min((X - s) * c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 1, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 1, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 0, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 0, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 1, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 1, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + -2, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + -2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 2, l + 2)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 2)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 2, l + 0)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 0)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 2, l + 0)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 0)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 2, l + -1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + -1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 / c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 / c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s + i] + (k * 2 + c)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + (k * 2 + c)) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s + i] + (k * 2) ** c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + (k * 2) ** c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s + c + 3, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s + c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min((X - s) * c + 3, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min((X - s) * c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 4, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 4, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 0, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 0, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 1, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 1, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + -3, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + -3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 3, l + 2)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 2)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 3, l + 0)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 0)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 3, l + 0)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 0)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X - s - c + 3, l + -1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + -1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c + 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c + 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c * 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c * 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) / (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) / (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + (k * (c - 1) + (l - i + 1))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + (k * (c - 1) + (l - i + 1))) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + (k * (c - 1)) ** (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + (k * (c - 1)) ** (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 2][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 2][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 0][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 0][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 0][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 0][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + -1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + -1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 1][s - l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s - l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 1][s * l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s * l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c - 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c - 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c * 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c * 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + k * (s - c / (l - 1))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c / (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + k * (s - (c + (l - 1)))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - (c + (l - 1)))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + k * (s - c ** (l - 1))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c ** (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X + s - c + 2, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X + s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(1, min(X - s - c + 2, l + 1)):",
      "mutated_line": "for i in range(1, min(X * s - c + 2, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X * s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s - i] + k * 2 * c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s - i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s * i] + k * 2 * c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s * i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s + i] + k / 2 * c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k / 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s + i] + (k + 2) * c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + (k + 2) * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s + i] + k ** 2 * c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k ** 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X + s - c + 3, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X + s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(1, min(X - s - c + 3, l + 1)):",
      "mutated_line": "for i in range(1, min(X * s - c + 3, l + 1)):",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X * s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 2][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 2][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 0][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 0][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 0][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 0][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - -1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - -1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s - i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s - i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s * i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s * i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k / (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k / (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + (k + (c - 1)) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + (k + (c - 1)) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k ** (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k ** (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i - 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i - 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * ((l - i) * 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * ((l - i) * 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c - 1][s + l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c - 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c * 1][s + l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c * 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 2)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 2)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 0)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 0)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 0)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 0)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + -1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + -1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l + 1))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l + 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l * 1))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l * 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s + i] + k * 3 * c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 3 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s + i] + k * 1 * c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 1 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s + i] + k * 0 * c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 0 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s + i] + k * 1 * c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 1 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod",
      "mutated_line": "ND[c][s + i] = (ND[c][s + i] + k * -2 * c) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * -2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c + 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c + 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c * 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c * 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c + 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c + 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c * 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c * 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l + i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l + i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l * i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l * i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 2)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 2)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 0)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 0)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 0)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 0)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + -1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + -1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 2][s + l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 2][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 0][s + l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 0][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + 0][s + l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 0][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod",
      "mutated_line": "ND[c + 1][s + l] = (ND[c + -1][s + l] + k * (c + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + -1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 2))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 2))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 0))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 0))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 0))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 0))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod",
      "mutated_line": "ND[c][s] = (ND[c][s] + k * (s - c * (l - -1))) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - -1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 2][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 2][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 0][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 0][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 0][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 0][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - -1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - -1][s + i] + k * (c - 1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 2) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 2) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 0) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 0) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 0) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 0) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - 1) * (l - i + 1)) % mod",
      "mutated_line": "ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - -1) * (l - i + 1)) % mod",
      "code": "def count_ways_to_cover_land(N, X, L):\n    mod = 10 ** 9 + 7\n    L = sorted(L, reverse=True)\n    D = [[0] * (X + 1) for i in range(N // 2 + 2)]\n    D[1][L[0]] = 1\n    for l in L[1:]:\n        ND = [[0] * (X + 1) for i in range(N // 2 + 1)]\n        for c in range(1, N // 2 + 1):\n            for s in range(X + 1):\n                if D[c][s] == 0:\n                    continue\n                k = D[c][s]\n                if s + l + c <= X and c + 1 <= N // 2:\n                    ND[c + 1][s + l] = (ND[c + 1][s + l] + k * (c + 1)) % mod\n                ND[c][s] = (ND[c][s] + k * (s - c * (l - 1))) % mod\n                for i in range(1, min(X - s - c + 2, l + 1)):\n                    ND[c][s + i] = (ND[c][s + i] + k * 2 * c) % mod\n                if c == 1:\n                    continue\n                for i in range(1, min(X - s - c + 3, l + 1)):\n                    ND[c - 1][s + i] = (ND[c - 1][s + i] + k * (c - -1) * (l - i + 1)) % mod\n        D = ND\n    return D[1][X]"
    }
  ]
}