{
  "task_id": "taco_9146",
  "entry_point": "find_min_time_to_reach_bottom_right",
  "mutant_count": 79,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "return -1  # This should never be reached given the problem constraints",
      "mutated_line": "return +1",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return +1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if (r, c) == (N-1, N-1):",
      "mutated_line": "if (r, c) != (N - 1, N - 1):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) != (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (r, c) in visited:",
      "mutated_line": "if (r, c) not in visited:",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) not in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return -1  # This should never be reached given the problem constraints",
      "mutated_line": "return -2",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return -1  # This should never be reached given the problem constraints",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return -1  # This should never be reached given the problem constraints",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return -1  # This should never be reached given the problem constraints",
      "mutated_line": "return --1",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(-1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(-1, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(1, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 2), (1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 2), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 0), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, -1), (1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, -1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (2, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (2, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (0, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (-1, 0), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (-1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, -1), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 1), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (-1, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (1, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, +1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, +1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (+1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (+1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, -1)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, -1)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 1)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_heap = [(grid[0][0], 0, 0)]  # (elevation, row, col)",
      "mutated_line": "min_heap = [(grid[0][0], 1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 1, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_heap = [(grid[0][0], 0, 0)]  # (elevation, row, col)",
      "mutated_line": "min_heap = [(grid[0][0], -1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], -1, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_heap = [(grid[0][0], 0, 0)]  # (elevation, row, col)",
      "mutated_line": "min_heap = [(grid[0][0], 1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 1, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_heap = [(grid[0][0], 0, 0)]  # (elevation, row, col)",
      "mutated_line": "min_heap = [(grid[0][0], 0, 1)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 1)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_heap = [(grid[0][0], 0, 0)]  # (elevation, row, col)",
      "mutated_line": "min_heap = [(grid[0][0], 0, -1)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, -1)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_heap = [(grid[0][0], 0, 0)]  # (elevation, row, col)",
      "mutated_line": "min_heap = [(grid[0][0], 0, 1)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 1)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:",
      "mutated_line": "if 0 <= nr < N or 0 <= nc < N or (nr, nc) not in visited:",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N or 0 <= nc < N or (nr, nc) not in visited:\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -2), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -2), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -0), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, --1), (-1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, --1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-2, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-2, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-0, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (0, -1), (--1, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (--1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_heap = [(grid[0][0], 0, 0)]  # (elevation, row, col)",
      "mutated_line": "min_heap = [(grid[0][1], 0, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][1], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_heap = [(grid[0][0], 0, 0)]  # (elevation, row, col)",
      "mutated_line": "min_heap = [(grid[0][-1], 0, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][-1], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_heap = [(grid[0][0], 0, 0)]  # (elevation, row, col)",
      "mutated_line": "min_heap = [(grid[0][1], 0, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][1], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (r, c) == (N-1, N-1):",
      "mutated_line": "if (r, c) == (N + 1, N - 1):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N + 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (r, c) == (N-1, N-1):",
      "mutated_line": "if (r, c) == (N * 1, N - 1):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N * 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (r, c) == (N-1, N-1):",
      "mutated_line": "if (r, c) == (N - 1, N + 1):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N + 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (r, c) == (N-1, N-1):",
      "mutated_line": "if (r, c) == (N - 1, N * 1):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N * 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nr, nc = r + dr, c + dc",
      "mutated_line": "if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r - dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nr, nc = r + dr, c + dc",
      "mutated_line": "if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r * dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nr, nc = r + dr, c + dc",
      "mutated_line": "if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c - dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nr, nc = r + dr, c + dc",
      "mutated_line": "if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c * dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:",
      "mutated_line": "if 0 < nr < N and 0 <= nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 < nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:",
      "mutated_line": "if 0 > nr < N and 0 <= nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 > nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:",
      "mutated_line": "if 0 == nr < N and 0 <= nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 == nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:",
      "mutated_line": "if 0 <= nr < N and 0 < nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 < nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:",
      "mutated_line": "if 0 <= nr < N and 0 > nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 > nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:",
      "mutated_line": "if 0 <= nr < N and 0 == nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 == nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:",
      "mutated_line": "if 0 <= nr < N and 0 <= nc < N and ((nr, nc) in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_heap = [(grid[0][0], 0, 0)]  # (elevation, row, col)",
      "mutated_line": "min_heap = [(grid[1][0], 0, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[1][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_heap = [(grid[0][0], 0, 0)]  # (elevation, row, col)",
      "mutated_line": "min_heap = [(grid[-1][0], 0, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[-1][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_heap = [(grid[0][0], 0, 0)]  # (elevation, row, col)",
      "mutated_line": "min_heap = [(grid[1][0], 0, 0)]",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[1][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (N-1, N-1):",
      "mutated_line": "if (r, c) == (N - 2, N - 1):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 2, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (N-1, N-1):",
      "mutated_line": "if (r, c) == (N - 0, N - 1):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 0, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (N-1, N-1):",
      "mutated_line": "if (r, c) == (N - 0, N - 1):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 0, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (N-1, N-1):",
      "mutated_line": "if (r, c) == (N - -1, N - 1):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - -1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (N-1, N-1):",
      "mutated_line": "if (r, c) == (N - 1, N - 2):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 2):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (N-1, N-1):",
      "mutated_line": "if (r, c) == (N - 1, N - 0):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 0):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (N-1, N-1):",
      "mutated_line": "if (r, c) == (N - 1, N - 0):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 0):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (r, c) == (N-1, N-1):",
      "mutated_line": "if (r, c) == (N - 1, N - -1):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - -1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:",
      "mutated_line": "if 1 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 1 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:",
      "mutated_line": "if -1 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if -1 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:",
      "mutated_line": "if 1 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 1 <= nr < N and 0 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:",
      "mutated_line": "if 0 <= nr < N and 1 <= nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 1 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:",
      "mutated_line": "if 0 <= nr < N and -1 <= nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and -1 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:",
      "mutated_line": "if 0 <= nr < N and 1 <= nc < N and ((nr, nc) not in visited):",
      "code": "import heapq\n\ndef find_min_time_to_reach_bottom_right(grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_heap = [(grid[0][0], 0, 0)]\n    visited = set()\n    while min_heap:\n        (t, r, c) = heapq.heappop(min_heap)\n        if (r, c) == (N - 1, N - 1):\n            return t\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < N and 1 <= nc < N and ((nr, nc) not in visited):\n                heapq.heappush(min_heap, (max(t, grid[nr][nc]), nr, nc))\n    return -1"
    }
  ]
}