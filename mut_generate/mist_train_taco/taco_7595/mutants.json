{
  "task_id": "taco_7595",
  "entry_point": "calculate_minimum_physical_strength",
  "mutant_count": 97,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) // 2 + dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 + dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) // 2 * dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 * dp.query(n - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i < self.N:",
      "mutated_line": "while i <= self.N:",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i <= self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i < self.N:",
      "mutated_line": "while i >= self.N:",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i >= self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i < self.N:",
      "mutated_line": "while i != self.N:",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i != self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 1\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ret = 0",
      "mutated_line": "ret = -1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = -1\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 1\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while n >= 0:",
      "mutated_line": "while n > 0:",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n > 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while n >= 0:",
      "mutated_line": "while n < 0:",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n < 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while n >= 0:",
      "mutated_line": "while n == 0:",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n == 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)",
      "mutated_line": "dp = FenwickTree([0] / n, lambda x, y: max(x, y), 0)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] / n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)",
      "mutated_line": "dp = FenwickTree([0] + n, lambda x, y: max(x, y), 0)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] + n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)",
      "mutated_line": "dp = FenwickTree([0] ** n, lambda x, y: max(x, y), 0)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] ** n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)",
      "mutated_line": "dp = FenwickTree([0] * n, lambda x, y: max(x, y), 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 1)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)",
      "mutated_line": "dp = FenwickTree([0] * n, lambda x, y: max(x, y), -1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), -1)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)",
      "mutated_line": "dp = FenwickTree([0] * n, lambda x, y: max(x, y), 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 1)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) / 2 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) / 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) * 2 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) * 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(self.N - 1):",
      "mutated_line": "for i in range(self.N + 1):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N + 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(self.N - 1):",
      "mutated_line": "for i in range(self.N * 1):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N * 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "i |= i + 1",
      "mutated_line": "i |= i - 1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i - 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "i |= i + 1",
      "mutated_line": "i |= i * 1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i * 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while n >= 0:",
      "mutated_line": "while n >= 1:",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 1:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while n >= 0:",
      "mutated_line": "while n >= -1:",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= -1:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while n >= 0:",
      "mutated_line": "while n >= 1:",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 1:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "n = (n & n + 1) - 1",
      "mutated_line": "n = (n & n + 1) + 1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) + 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "n = (n & n + 1) - 1",
      "mutated_line": "n = (n & n + 1) * 1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) * 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp.update(i, dp.query(i) + x)",
      "mutated_line": "dp.update(i, dp.query(i) - x)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) - x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp.update(i, dp.query(i) + x)",
      "mutated_line": "dp.update(i, dp.query(i) * x)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) * x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n / (n + 1) // 2 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n / (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return (n + (n + 1)) // 2 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return (n + (n + 1)) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n ** (n + 1) // 2 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n ** (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) // 3 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 3 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) // 1 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 1 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) // 0 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 0 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) // 1 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 1 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) // -2 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // -2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) // 2 - dp.query(n + 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) // 2 - dp.query(n * 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n * 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):",
      "mutated_line": "for _ in range(self.N, 2 << math.ceil(math.log(self.N, 2))):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 2 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):",
      "mutated_line": "for _ in range(self.N, 0 << math.ceil(math.log(self.N, 2))):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 0 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):",
      "mutated_line": "for _ in range(self.N, 0 << math.ceil(math.log(self.N, 2))):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 0 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):",
      "mutated_line": "for _ in range(self.N, -1 << math.ceil(math.log(self.N, 2))):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, -1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(self.N - 1):",
      "mutated_line": "for i in range(self.N - 2):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 2):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(self.N - 1):",
      "mutated_line": "for i in range(self.N - 0):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 0):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(self.N - 1):",
      "mutated_line": "for i in range(self.N - 0):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 0):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(self.N - 1):",
      "mutated_line": "for i in range(self.N - -1):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - -1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i & i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i & i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i ^ i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i ^ i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i |= i + 1",
      "mutated_line": "i |= i + 2",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 2\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i |= i + 1",
      "mutated_line": "i |= i + 0",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 0\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i |= i + 1",
      "mutated_line": "i |= i + 0",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 0\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i |= i + 1",
      "mutated_line": "i |= i + -1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + -1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "n = (n & n + 1) - 1",
      "mutated_line": "n = (n | n + 1) - 1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n | n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "n = (n & n + 1) - 1",
      "mutated_line": "n = (n & n + 1) - 2",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 2\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "n = (n & n + 1) - 1",
      "mutated_line": "n = (n & n + 1) - 0",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 0\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "n = (n & n + 1) - 1",
      "mutated_line": "n = (n & n + 1) - 0",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 0\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "n = (n & n + 1) - 1",
      "mutated_line": "n = (n & n + 1) - -1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - -1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)",
      "mutated_line": "dp = FenwickTree([1] * n, lambda x, y: max(x, y), 0)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([1] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)",
      "mutated_line": "dp = FenwickTree([-1] * n, lambda x, y: max(x, y), 0)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([-1] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)",
      "mutated_line": "dp = FenwickTree([1] * n, lambda x, y: max(x, y), 0)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([1] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n - 1) // 2 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n - 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n * 1) // 2 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n * 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) // 2 - dp.query(n - 2)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) // 2 - dp.query(n - 0)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) // 2 - dp.query(n - 0)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 1) // 2 - dp.query(n - -1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - -1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i | i - 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i - 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i | i * 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i * 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i | i + 1] = self.f(self.bit[i & i + 1], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i & i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i | i + 1] = self.f(self.bit[i ^ i + 1], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i ^ i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "n = (n & n + 1) - 1",
      "mutated_line": "n = (n & n - 1) - 1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n - 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "n = (n & n + 1) - 1",
      "mutated_line": "n = (n & n * 1) - 1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n * 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 2) // 2 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 2) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 0) // 2 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 0) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + 0) // 2 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 0) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return n * (n + 1) // 2 - dp.query(n - 1)",
      "mutated_line": "return n * (n + -1) // 2 - dp.query(n - 1)",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + -1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):",
      "mutated_line": "for _ in range(self.N, 1 << math.ceil(math.log(self.N, 3))):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 3))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):",
      "mutated_line": "for _ in range(self.N, 1 << math.ceil(math.log(self.N, 1))):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 1))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):",
      "mutated_line": "for _ in range(self.N, 1 << math.ceil(math.log(self.N, 0))):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 0))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):",
      "mutated_line": "for _ in range(self.N, 1 << math.ceil(math.log(self.N, 1))):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 1))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):",
      "mutated_line": "for _ in range(self.N, 1 << math.ceil(math.log(self.N, -2))):",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, -2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i | i + 2] = self.f(self.bit[i | i + 1], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 2] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i | i + 0] = self.f(self.bit[i | i + 1], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 0] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i | i + 0] = self.f(self.bit[i | i + 1], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 0] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i | i + -1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + -1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i | i + 1] = self.f(self.bit[i | i - 1], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i - 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i | i + 1] = self.f(self.bit[i | i * 1], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i * 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "n = (n & n + 1) - 1",
      "mutated_line": "n = (n & n + 2) - 1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 2) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "n = (n & n + 1) - 1",
      "mutated_line": "n = (n & n + 0) - 1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 0) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "n = (n & n + 1) - 1",
      "mutated_line": "n = (n & n + 0) - 1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 0) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "n = (n & n + 1) - 1",
      "mutated_line": "n = (n & n + -1) - 1",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + -1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 2], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 2], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 0], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 0], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 0], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + 0], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + 1], self.bit[i])",
      "mutated_line": "self.bit[i | i + 1] = self.f(self.bit[i | i + -1], self.bit[i])",
      "code": "import math\n\nclass FenwickTree:\n\n    def __init__(self, a_list, f, default):\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << math.ceil(math.log(self.N, 2))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | i + 1] = self.f(self.bit[i | i + -1], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & n + 1) - 1\n        return ret\n\ndef calculate_minimum_physical_strength(n, weights):\n    dp = FenwickTree([0] * n, lambda x, y: max(x, y), 0)\n    for (x, i) in sorted(((x, i) for (i, x) in enumerate(weights))):\n        dp.update(i, dp.query(i) + x)\n    return n * (n + 1) // 2 - dp.query(n - 1)"
    }
  ]
}