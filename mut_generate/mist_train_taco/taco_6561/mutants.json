{
  "task_id": "taco_6561",
  "entry_point": "eq",
  "mutant_count": 176,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EPS = 1e-10",
      "mutated_line": "EPS = 1.0000000001",
      "code": "import math\nEPS = 1.0000000001\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EPS = 1e-10",
      "mutated_line": "EPS = -0.9999999999",
      "code": "import math\nEPS = -0.9999999999\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EPS = 1e-10",
      "mutated_line": "EPS = 0",
      "code": "import math\nEPS = 0\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EPS = 1e-10",
      "mutated_line": "EPS = 1",
      "code": "import math\nEPS = 1\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "EPS = 1e-10",
      "mutated_line": "EPS = -1e-10",
      "code": "import math\nEPS = -1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "return abs(a - b) < EPS",
      "mutated_line": "return abs(a - b) <= EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) <= EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "return abs(a - b) < EPS",
      "mutated_line": "return abs(a - b) >= EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) >= EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "return abs(a - b) < EPS",
      "mutated_line": "return abs(a - b) != EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) != EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "return eq(a.real, b.real) and eq(a.imag, b.imag)",
      "mutated_line": "return eq(a.real, b.real) or eq(a.imag, b.imag)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) or eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag + a.imag * b.real",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag + a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag * (a.imag * b.real)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag * (a.imag * b.real)\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS or cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS or cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = a2 - a1",
      "mutated_line": "a = a2 + a1",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 + a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = a2 - a1",
      "mutated_line": "a = a2 * a1",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 * a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "b = b2 - b1",
      "mutated_line": "b = b2 + b1",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 + b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "b = b2 - b1",
      "mutated_line": "b = b2 * b1",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 * b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return a1 + a * cross(b, b1 - a1) / cross(b, a)",
      "mutated_line": "return a1 - a * cross(b, b1 - a1) / cross(b, a)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 - a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return a1 + a * cross(b, b1 - a1) / cross(b, a)",
      "mutated_line": "return a1 * (a * cross(b, b1 - a1) / cross(b, a))",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 * (a * cross(b, b1 - a1) / cross(b, a))\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if n == 0:",
      "mutated_line": "if n != 0:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n != 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 2",
      "mutated_line": "ans = 3",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 3\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 2",
      "mutated_line": "ans = 1",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 1\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 2",
      "mutated_line": "ans = 0",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 0\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 2",
      "mutated_line": "ans = 1",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 1\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 2",
      "mutated_line": "ans = -2",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = -2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "ans += 1 + cnt",
      "mutated_line": "ans -= 1 + cnt",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans -= 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real / b.imag - a.imag * b.real",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real / b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real + b.imag - a.imag * b.real",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real + b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real ** b.imag - a.imag * b.real",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real ** b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag - a.imag / b.real",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag / b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag - (a.imag + b.real)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - (a.imag + b.real)\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag - a.imag ** b.real",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag ** b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) <= EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) <= EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) >= EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) >= EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) != EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) != EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) <= EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) <= EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) >= EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) >= EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) != EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) != EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return a1 + a * cross(b, b1 - a1) / cross(b, a)",
      "mutated_line": "return a1 + a * cross(b, b1 - a1) * cross(b, a)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) * cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return a1 + a * cross(b, b1 - a1) / cross(b, a)",
      "mutated_line": "return a1 + a * cross(b, b1 - a1) // cross(b, a)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) // cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 1:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n == 0:",
      "mutated_line": "if n == -1:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == -1:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 1:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 1  # No lines means the square is not divided",
      "mutated_line": "return 2",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 2\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 1  # No lines means the square is not divided",
      "mutated_line": "return 0",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 0\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 1  # No lines means the square is not divided",
      "mutated_line": "return 0",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 0\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 1  # No lines means the square is not divided",
      "mutated_line": "return -1",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return -1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(2, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(0, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(0, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(-1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans += 1 + cnt",
      "mutated_line": "ans += 1 - cnt",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 - cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans += 1 + cnt",
      "mutated_line": "ans += 1 * cnt",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 * cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return abs(a - b) < EPS",
      "mutated_line": "return abs(a + b) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a + b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return abs(a - b) < EPS",
      "mutated_line": "return abs(a * b) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a * b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) / cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) / cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) + cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) + cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) ** cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) ** cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) / cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) / cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) + cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) + cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) ** cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) ** cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return a1 + a * cross(b, b1 - a1) / cross(b, a)",
      "mutated_line": "return a1 + a / cross(b, b1 - a1) / cross(b, a)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a / cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return a1 + a * cross(b, b1 - a1) / cross(b, a)",
      "mutated_line": "return a1 + (a + cross(b, b1 - a1)) / cross(b, a)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + (a + cross(b, b1 - a1)) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return a1 + a * cross(b, b1 - a1) / cross(b, a)",
      "mutated_line": "return a1 + a ** cross(b, b1 - a1) / cross(b, a)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a ** cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(0, i):",
      "mutated_line": "for j in range(1, i):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(1, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(0, i):",
      "mutated_line": "for j in range(-1, i):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(-1, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(0, i):",
      "mutated_line": "for j in range(1, i):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(1, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt = min(len(cross_point), 1)",
      "mutated_line": "cnt = min(len(cross_point), 2)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 2)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt = min(len(cross_point), 1)",
      "mutated_line": "cnt = min(len(cross_point), 0)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 0)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt = min(len(cross_point), 1)",
      "mutated_line": "cnt = min(len(cross_point), 0)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 0)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt = min(len(cross_point), 1)",
      "mutated_line": "cnt = min(len(cross_point), -1)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), -1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(1, len(cross_point)):",
      "mutated_line": "for i in range(2, len(cross_point)):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(2, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(1, len(cross_point)):",
      "mutated_line": "for i in range(0, len(cross_point)):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(0, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(1, len(cross_point)):",
      "mutated_line": "for i in range(0, len(cross_point)):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(0, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(1, len(cross_point)):",
      "mutated_line": "for i in range(-1, len(cross_point)):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(-1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "flag = 0",
      "mutated_line": "flag = 1",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 1\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "flag = 0",
      "mutated_line": "flag = -1",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = -1\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "flag = 0",
      "mutated_line": "flag = 1",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 1\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt -= 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans += 1 + cnt",
      "mutated_line": "ans += 2 + cnt",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 2 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans += 1 + cnt",
      "mutated_line": "ans += 0 + cnt",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 0 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans += 1 + cnt",
      "mutated_line": "ans += 0 + cnt",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 0 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans += 1 + cnt",
      "mutated_line": "ans += -1 + cnt",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += -1 + cnt\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS or -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS or -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(0, i):",
      "mutated_line": "for j in range(1, i):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(1, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(0, i):",
      "mutated_line": "for j in range(-1, i):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(-1, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(0, i):",
      "mutated_line": "for j in range(1, i):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(1, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 2\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 0\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 0\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += -1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 + a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 + a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 * a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 * a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 + a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 + a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 * a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 * a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 + a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 + a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 * a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 * a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 + a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 + a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 * a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 * a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 + b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 + b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 * b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 * b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 + b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 + b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 * b1) * cross(b2 - b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 * b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 + b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 + b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 * b1, a2 - b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 * b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 + b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 + b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS",
      "mutated_line": "return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 * b1) < EPS",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 * b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return a1 + a * cross(b, b1 - a1) / cross(b, a)",
      "mutated_line": "return a1 + a * cross(b, b1 + a1) / cross(b, a)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 + a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return a1 + a * cross(b, b1 - a1) / cross(b, a)",
      "mutated_line": "return a1 + a * cross(b, b1 * a1) / cross(b, a)",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 * a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):",
      "mutated_line": "if is_intersected_ls(l1[1], l1[1], l2[0], l2[1]):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[1], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):",
      "mutated_line": "if is_intersected_ls(l1[-1], l1[1], l2[0], l2[1]):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[-1], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):",
      "mutated_line": "if is_intersected_ls(l1[1], l1[1], l2[0], l2[1]):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[1], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):",
      "mutated_line": "if is_intersected_ls(l1[0], l1[2], l2[0], l2[1]):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[2], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):",
      "mutated_line": "if is_intersected_ls(l1[0], l1[0], l2[0], l2[1]):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[0], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):",
      "mutated_line": "if is_intersected_ls(l1[0], l1[0], l2[0], l2[1]):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[0], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):",
      "mutated_line": "if is_intersected_ls(l1[0], l1[-1], l2[0], l2[1]):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[-1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):",
      "mutated_line": "if is_intersected_ls(l1[0], l1[1], l2[1], l2[1]):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[1], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):",
      "mutated_line": "if is_intersected_ls(l1[0], l1[1], l2[-1], l2[1]):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[-1], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):",
      "mutated_line": "if is_intersected_ls(l1[0], l1[1], l2[1], l2[1]):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[1], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):",
      "mutated_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[2]):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[2]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):",
      "mutated_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[0]):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[0]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):",
      "mutated_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[0]):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[0]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):",
      "mutated_line": "if is_intersected_ls(l1[0], l1[1], l2[0], l2[-1]):",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[-1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS < p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS < p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS > p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS > p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS == p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS == p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS < p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS < p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS > p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS > p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS == p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS == p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "flag = 1",
      "mutated_line": "flag = 2",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 2\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "flag = 1",
      "mutated_line": "flag = 0",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 0\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "flag = 1",
      "mutated_line": "flag = 0",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 0\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "flag = 1",
      "mutated_line": "flag = -1",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = -1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[1])",
      "mutated_line": "p = intersection_l(l1[1], l1[1], l2[0], l2[1])",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[1], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[1])",
      "mutated_line": "p = intersection_l(l1[-1], l1[1], l2[0], l2[1])",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[-1], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[1])",
      "mutated_line": "p = intersection_l(l1[1], l1[1], l2[0], l2[1])",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[1], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[1])",
      "mutated_line": "p = intersection_l(l1[0], l1[2], l2[0], l2[1])",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[2], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[1])",
      "mutated_line": "p = intersection_l(l1[0], l1[0], l2[0], l2[1])",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[0], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[1])",
      "mutated_line": "p = intersection_l(l1[0], l1[0], l2[0], l2[1])",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[0], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[1])",
      "mutated_line": "p = intersection_l(l1[0], l1[-1], l2[0], l2[1])",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[-1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[1])",
      "mutated_line": "p = intersection_l(l1[0], l1[1], l2[1], l2[1])",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[1], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[1])",
      "mutated_line": "p = intersection_l(l1[0], l1[1], l2[-1], l2[1])",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[-1], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[1])",
      "mutated_line": "p = intersection_l(l1[0], l1[1], l2[1], l2[1])",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[1], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[1])",
      "mutated_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[2])",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[2])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[1])",
      "mutated_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[0])",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[0])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[1])",
      "mutated_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[0])",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[0])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[1])",
      "mutated_line": "p = intersection_l(l1[0], l1[1], l2[0], l2[-1])",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[-1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 - EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 - EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 * EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 * EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 + EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 + EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 * EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 * EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 - EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 - EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 * EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 * EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 + EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 + EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 * EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 * EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if +100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if +100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 101 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 101 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 99 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 99 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 0 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 0 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 1 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 1 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= -100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= -100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and +100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and +100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 101 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 101 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 99 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 99 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 0 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 0 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 1 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 1 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= -100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= -100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -101 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -101 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -99 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -99 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -0 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -0 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -1 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -1 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if --100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if --100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -101 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -101 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -99 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -99 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -0 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -0 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and -1 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and -1 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if -100 + EPS <= p.real <= 100 - EPS and -100 + EPS <= p.imag <= 100 - EPS:",
      "mutated_line": "if -100 + EPS <= p.real <= 100 - EPS and --100 + EPS <= p.imag <= 100 - EPS:",
      "code": "import math\nEPS = 1e-10\n\ndef eq(a, b):\n    return abs(a - b) < EPS\n\ndef eqv(a, b):\n    return eq(a.real, b.real) and eq(a.imag, b.imag)\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef is_intersected_ls(a1, a2, b1, b2):\n    return cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS and cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS\n\ndef intersection_l(a1, a2, b1, b2):\n    a = a2 - a1\n    b = b2 - b1\n    return a1 + a * cross(b, b1 - a1) / cross(b, a)\n\ndef calculate_divided_regions(n, lines):\n    if n == 0:\n        return 1\n    ans = 2\n    for i in range(1, n):\n        cross_point = []\n        for j in range(0, i):\n            (l1, l2) = (lines[i], lines[j])\n            if is_intersected_ls(l1[0], l1[1], l2[0], l2[1]):\n                p = intersection_l(l1[0], l1[1], l2[0], l2[1])\n                if -100 + EPS <= p.real <= 100 - EPS and --100 + EPS <= p.imag <= 100 - EPS:\n                    cross_point.append(p)\n        cnt = min(len(cross_point), 1)\n        for i in range(1, len(cross_point)):\n            flag = 0\n            for j in range(0, i):\n                if eqv(cross_point[i], cross_point[j]):\n                    flag = 1\n            if not flag:\n                cnt += 1\n        ans += 1 + cnt\n    return ans"
    }
  ]
}