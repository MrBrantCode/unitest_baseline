{
  "task_id": "taco_3397",
  "entry_point": "med",
  "mutant_count": 152,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "cum = [0] * (n + 1)",
      "mutated_line": "cum = [0] / (n + 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] / (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "cum = [0] * (n + 1)",
      "mutated_line": "cum = [0] + (n + 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] + (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "cum = [0] * (n + 1)",
      "mutated_line": "cum = [0] ** (n + 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] ** (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "cum[i] -= m - 1",
      "mutated_line": "cum[i] += m - 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] += m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 1\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ret = 0",
      "mutated_line": "ret = -1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = -1\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 1\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "ret += zb.sum(cum[j])",
      "mutated_line": "ret -= zb.sum(cum[j])",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret -= zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "l = 0",
      "mutated_line": "l = 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 1\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "l = 0",
      "mutated_line": "l = -1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = -1\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "l = 0",
      "mutated_line": "l = 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 1\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l >= 1:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l >= 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l <= 1:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l <= 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l != 1:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l != 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] / (n + 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] / (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] + (n + 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] + (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] ** (n + 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] ** (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 1\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = -1\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 1\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i > 0:",
      "mutated_line": "while i >= 0:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i >= 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i > 0:",
      "mutated_line": "while i <= 0:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i <= 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i > 0:",
      "mutated_line": "while i != 0:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i != 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "s += self.tree[i]",
      "mutated_line": "s -= self.tree[i]",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s -= self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "i -= i & -i",
      "mutated_line": "i += i & -i",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i += i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while i <= self.size:",
      "mutated_line": "while i < self.size:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i < self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while i <= self.size:",
      "mutated_line": "while i > self.size:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i > self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while i <= self.size:",
      "mutated_line": "while i == self.size:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i == self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "self.tree[i] += x",
      "mutated_line": "self.tree[i] -= x",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] -= x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "i += i & -i",
      "mutated_line": "i -= i & -i",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i -= i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "cum = [0] * (n + 1)",
      "mutated_line": "cum = [0] * (n - 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n - 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "cum = [0] * (n + 1)",
      "mutated_line": "cum = [0] * (n * 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n * 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if a[i] >= x:",
      "mutated_line": "if a[i] > x:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] > x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if a[i] >= x:",
      "mutated_line": "if a[i] < x:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] < x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if a[i] >= x:",
      "mutated_line": "if a[i] == x:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] == x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n - 1):",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n - 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n * 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "cum[i] -= m - 1",
      "mutated_line": "cum[i] -= m + 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m + 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "cum[i] -= m - 1",
      "mutated_line": "cum[i] -= m * 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m * 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for j in range(n + 1):",
      "mutated_line": "for j in range(n - 1):",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n - 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for j in range(n + 1):",
      "mutated_line": "for j in range(n * 1):",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n * 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r + l > 1:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r + l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r * l > 1:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r * l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 2:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 0:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 0:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 0:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 0:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > -1:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > -1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l + r + 1) / 2",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) / 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l + r + 1) * 2",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) * 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) > n * (n + 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) > n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) < n * (n + 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) < n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) == n * (n + 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) == n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n - 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n - 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n * 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n * 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 1:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i > 0:",
      "mutated_line": "while i > -1:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > -1:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 1:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i | -i",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i | -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "i += i & -i",
      "mutated_line": "i += i | -i",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i | -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cum = [0] * (n + 1)",
      "mutated_line": "cum = [1] * (n + 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [1] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cum = [0] * (n + 1)",
      "mutated_line": "cum = [-1] * (n + 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [-1] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cum = [0] * (n + 1)",
      "mutated_line": "cum = [1] * (n + 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [1] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cum = [0] * (n + 1)",
      "mutated_line": "cum = [0] * (n + 2)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 2)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cum = [0] * (n + 1)",
      "mutated_line": "cum = [0] * (n + 0)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 0)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cum = [0] * (n + 1)",
      "mutated_line": "cum = [0] * (n + 0)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 0)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cum = [0] * (n + 1)",
      "mutated_line": "cum = [0] * (n + -1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + -1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cum[i + 1] = cum[i] + 1",
      "mutated_line": "cum[i + 1] = cum[i] - 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] - 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cum[i + 1] = cum[i] + 1",
      "mutated_line": "cum[i + 1] = cum[i] * 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] * 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "cum[i + 1] = cum[i] - 1",
      "mutated_line": "cum[i + 1] = cum[i] + 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] + 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "cum[i + 1] = cum[i] - 1",
      "mutated_line": "cum[i + 1] = cum[i] * 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] * 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 2):",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 2):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 0):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 0):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + -1):",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + -1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cum[i] -= m - 1",
      "mutated_line": "cum[i] -= m - 2",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 2\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cum[i] -= m - 1",
      "mutated_line": "cum[i] -= m - 0",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 0\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cum[i] -= m - 1",
      "mutated_line": "cum[i] -= m - 0",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 0\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cum[i] -= m - 1",
      "mutated_line": "cum[i] -= m - -1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - -1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(n + 1):",
      "mutated_line": "for j in range(n + 2):",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 2):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(n + 1):",
      "mutated_line": "for j in range(n + 0):",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 0):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(n + 1):",
      "mutated_line": "for j in range(n + 0):",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 0):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(n + 1):",
      "mutated_line": "for j in range(n + -1):",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + -1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "zb.add(cum[j], 1)",
      "mutated_line": "zb.add(cum[j], 2)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 2)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "zb.add(cum[j], 1)",
      "mutated_line": "zb.add(cum[j], 0)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 0)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "zb.add(cum[j], 1)",
      "mutated_line": "zb.add(cum[j], 0)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 0)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "zb.add(cum[j], 1)",
      "mutated_line": "zb.add(cum[j], -1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], -1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l + r - 1) // 2",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r - 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l + r) * 1 // 2",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r) * 1 // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l + r + 1) // 3",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 3\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l + r + 1) // 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 1\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l + r + 1) // 0",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 0\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l + r + 1) // 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 1\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l + r + 1) // -2",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // -2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 / med(b[mid], a, n) >= n * (n + 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 / med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 + med(b[mid], a, n) >= n * (n + 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 + med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 ** med(b[mid], a, n) >= n * (n + 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 ** med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) / 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) / 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) * 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) * 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [1] * (n + 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [1] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [-1] * (n + 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [-1] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [1] * (n + 1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [1] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n + 2)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 2)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n + 0)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 0)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n + 0)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 0)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n + -1)",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + -1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i & +i",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & +i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "i += i & -i",
      "mutated_line": "i += i & +i",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & +i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cum[i + 1] = cum[i] + 1",
      "mutated_line": "cum[i - 1] = cum[i] + 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i - 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cum[i + 1] = cum[i] + 1",
      "mutated_line": "cum[i * 1] = cum[i] + 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i * 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cum[i + 1] = cum[i] + 1",
      "mutated_line": "cum[i + 1] = cum[i] + 2",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 2\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cum[i + 1] = cum[i] + 1",
      "mutated_line": "cum[i + 1] = cum[i] + 0",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 0\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cum[i + 1] = cum[i] + 1",
      "mutated_line": "cum[i + 1] = cum[i] + 0",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 0\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cum[i + 1] = cum[i] + 1",
      "mutated_line": "cum[i + 1] = cum[i] + -1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + -1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "cum[i + 1] = cum[i] - 1",
      "mutated_line": "cum[i - 1] = cum[i] - 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i - 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "cum[i + 1] = cum[i] - 1",
      "mutated_line": "cum[i * 1] = cum[i] - 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i * 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cum[i + 1] = cum[i] - 1",
      "mutated_line": "cum[i + 1] = cum[i] - 2",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 2\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cum[i + 1] = cum[i] - 1",
      "mutated_line": "cum[i + 1] = cum[i] - 0",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 0\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cum[i + 1] = cum[i] - 1",
      "mutated_line": "cum[i + 1] = cum[i] - 0",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 0\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cum[i + 1] = cum[i] - 1",
      "mutated_line": "cum[i + 1] = cum[i] - -1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - -1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l - r + 1) // 2",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l - r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l * r + 1) // 2",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l * r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l + r + 2) // 2",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 2) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l + r + 0) // 2",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 0) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l + r + 0) // 2",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 0) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "mid = (l + r + 1) // 2",
      "mutated_line": "mid = (l + r + -1) // 2",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + -1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 3 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 3 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 1 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 1 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 0 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 0 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 1 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 1 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if -2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if -2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n / (n + 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n / (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= (n + (n + 1)) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= (n + (n + 1)) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n ** (n + 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n ** (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 3:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 3:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 1:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 1:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 0:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 0:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 1:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 1:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // -2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // -2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cum[i + 1] = cum[i] + 1",
      "mutated_line": "cum[i + 2] = cum[i] + 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 2] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cum[i + 1] = cum[i] + 1",
      "mutated_line": "cum[i + 0] = cum[i] + 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 0] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cum[i + 1] = cum[i] + 1",
      "mutated_line": "cum[i + 0] = cum[i] + 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 0] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cum[i + 1] = cum[i] + 1",
      "mutated_line": "cum[i + -1] = cum[i] + 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + -1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cum[i + 1] = cum[i] - 1",
      "mutated_line": "cum[i + 2] = cum[i] - 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 2] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cum[i + 1] = cum[i] - 1",
      "mutated_line": "cum[i + 0] = cum[i] - 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 0] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cum[i + 1] = cum[i] - 1",
      "mutated_line": "cum[i + 0] = cum[i] - 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 0] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cum[i + 1] = cum[i] - 1",
      "mutated_line": "cum[i + -1] = cum[i] - 1",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + -1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n * (n - 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n - 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n * (n * 1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n * 1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n * (n + 2) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 2) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n * (n + 0) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 0) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n * (n + 0) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + 0) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 2 * med(b[mid], a, n) >= n * (n + 1) // 2:",
      "mutated_line": "if 2 * med(b[mid], a, n) >= n * (n + -1) // 2:",
      "code": "class Bit:\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\ndef med(x, a, n):\n    cum = [0] * (n + 1)\n    for i in range(n):\n        if a[i] >= x:\n            cum[i + 1] = cum[i] + 1\n        else:\n            cum[i + 1] = cum[i] - 1\n    m = min(cum)\n    for i in range(n + 1):\n        cum[i] -= m - 1\n    zb = Bit(max(cum))\n    ret = 0\n    for j in range(n + 1):\n        ret += zb.sum(cum[j])\n        zb.add(cum[j], 1)\n    return ret\n\ndef find_median_of_medians(a, n):\n    b = sorted(a)\n    l = 0\n    r = n\n    while r - l > 1:\n        mid = (l + r + 1) // 2\n        if 2 * med(b[mid], a, n) >= n * (n + -1) // 2:\n            l = mid\n        else:\n            r = mid\n    return b[l]"
    }
  ]
}