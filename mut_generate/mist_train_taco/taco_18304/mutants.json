{
  "task_id": "taco_18304",
  "entry_point": "count_valid_grid_configurations",
  "mutant_count": 235,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0][None, (0,)] = 1",
      "mutated_line": "dp[0][None, (0,)] = 2",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 2\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0][None, (0,)] = 1",
      "mutated_line": "dp[0][None, (0,)] = 0",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 0\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0][None, (0,)] = 1",
      "mutated_line": "dp[0][None, (0,)] = 0",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 0\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0][None, (0,)] = 1",
      "mutated_line": "dp[0][None, (0,)] = -1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = -1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 1\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = -1\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 1\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(2 * n - 1):",
      "mutated_line": "for i in range(2 * n + 1):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n + 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(2 * n - 1):",
      "mutated_line": "for i in range(2 * n * 1):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n * 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(top) == 1:",
      "mutated_line": "if len(top) != 1:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) != 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0][None, (0,)] = 1",
      "mutated_line": "dp[1][None, (0,)] = 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[1][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0][None, (0,)] = 1",
      "mutated_line": "dp[-1][None, (0,)] = 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[-1][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0][None, (0,)] = 1",
      "mutated_line": "dp[1][None, (0,)] = 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[1][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(2 * n - 1):",
      "mutated_line": "for i in range(2 / n - 1):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 / n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(2 * n - 1):",
      "mutated_line": "for i in range(2 + n - 1):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 + n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(2 * n - 1):",
      "mutated_line": "for i in range(2 ** n - 1):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 ** n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2 * n - 1):",
      "mutated_line": "for i in range(2 * n - 2):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 2):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2 * n - 1):",
      "mutated_line": "for i in range(2 * n - 0):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 0):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2 * n - 1):",
      "mutated_line": "for i in range(2 * n - 0):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 0):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2 * n - 1):",
      "mutated_line": "for i in range(2 * n - -1):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - -1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(top) > k + 1:",
      "mutated_line": "if len(top) >= k + 1:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) >= k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(top) > k + 1:",
      "mutated_line": "if len(top) <= k + 1:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) <= k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(top) > k + 1:",
      "mutated_line": "if len(top) != k + 1:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) != k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if left == None:",
      "mutated_line": "if left != None:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left != None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top or i + 1 - top[-1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top or i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(top) == 1:",
      "mutated_line": "if len(top) == 2:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 2:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(top) == 1:",
      "mutated_line": "if len(top) == 0:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 0:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(top) == 1:",
      "mutated_line": "if len(top) == 0:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 0:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(top) == 1:",
      "mutated_line": "if len(top) == -1:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == -1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left != 2 * n - 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left != 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res = (res + v) % m",
      "mutated_line": "res = (res + v) * m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) * m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res = (res + v) % m",
      "mutated_line": "res = res + v + m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = res + v + m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [Counter() for _ in range(2 * n)]",
      "mutated_line": "dp = [Counter() for _ in range(2 / n)]",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 / n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [Counter() for _ in range(2 * n)]",
      "mutated_line": "dp = [Counter() for _ in range(2 + n)]",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 + n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [Counter() for _ in range(2 * n)]",
      "mutated_line": "dp = [Counter() for _ in range(2 ** n)]",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 ** n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0][None, (0,)] = 1",
      "mutated_line": "dp[0][None, (1,)] = 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (1,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0][None, (0,)] = 1",
      "mutated_line": "dp[0][None, (-1,)] = 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (-1,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[0][None, (0,)] = 1",
      "mutated_line": "dp[0][None, (1,)] = 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (1,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2 * n - 1):",
      "mutated_line": "for i in range(3 * n - 1):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(3 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2 * n - 1):",
      "mutated_line": "for i in range(1 * n - 1):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(1 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2 * n - 1):",
      "mutated_line": "for i in range(0 * n - 1):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(0 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2 * n - 1):",
      "mutated_line": "for i in range(1 * n - 1):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(1 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2 * n - 1):",
      "mutated_line": "for i in range(-2 * n - 1):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(-2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if len(top) > k + 1:",
      "mutated_line": "if len(top) > k - 1:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k - 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if len(top) > k + 1:",
      "mutated_line": "if len(top) > k * 1:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k * 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top or i + 1 - top[0] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top or i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k or len(top) > 1 or i + 1 - top[1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k or len(top) > 1 or i + 1 - top[1] <= k:\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i + 1 - top[-1] < k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] < k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i + 1 - top[-1] > k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] > k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i + 1 - top[-1] == k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] == k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) * m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) * m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i + 1][left, top] = dp[i + 1][left, top] + v + m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = dp[i + 1][left, top] + v + m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for ((left, top), v) in dp[2 * n - 1].items():",
      "mutated_line": "for ((left, top), v) in dp[2 * n + 1].items():",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n + 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for ((left, top), v) in dp[2 * n - 1].items():",
      "mutated_line": "for ((left, top), v) in dp[2 * n * 1].items():",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n * 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left == 2 * n + 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n + 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left == 2 * n * 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n * 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res = (res + v) % m",
      "mutated_line": "res = (res - v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res - v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res = (res + v) % m",
      "mutated_line": "res = res * v % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = res * v % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [Counter() for _ in range(2 * n)]",
      "mutated_line": "dp = [Counter() for _ in range(3 * n)]",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(3 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [Counter() for _ in range(2 * n)]",
      "mutated_line": "dp = [Counter() for _ in range(1 * n)]",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(1 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [Counter() for _ in range(2 * n)]",
      "mutated_line": "dp = [Counter() for _ in range(0 * n)]",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(0 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [Counter() for _ in range(2 * n)]",
      "mutated_line": "dp = [Counter() for _ in range(1 * n)]",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(1 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [Counter() for _ in range(2 * n)]",
      "mutated_line": "dp = [Counter() for _ in range(-2 * n)]",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(-2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(top) > k + 1:",
      "mutated_line": "if len(top) > k + 2:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 2:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(top) > k + 1:",
      "mutated_line": "if len(top) > k + 0:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 0:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(top) > k + 1:",
      "mutated_line": "if len(top) > k + 0:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 0:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(top) > k + 1:",
      "mutated_line": "if len(top) > k + -1:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + -1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top and i + 1 - top[0] < k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] < k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top and i + 1 - top[0] > k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] > k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top and i + 1 - top[0] == k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] == k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) * m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) * m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = dp[i + 1][i + 1, top] + v + m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = dp[i + 1][i + 1, top] + v + m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left < k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left < k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left > k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left > k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left == k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left == k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) >= 1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) >= 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) <= 1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) <= 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) != 1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) != 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] < k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] < k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] > k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] > k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] == k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] == k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) * m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) * m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = dp[i + 1][i + 1, top[1:]] + v + m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = dp[i + 1][i + 1, top[1:]] + v + m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i + 1 + top[-1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 + top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and (i + 1) * top[-1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and (i + 1) * top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "top.append(i + 1)",
      "mutated_line": "top.append(i - 1)",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i - 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "top.append(i + 1)",
      "mutated_line": "top.append(i * 1)",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i * 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] - v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] - v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i + 1][left, top] = dp[i + 1][left, top] * v % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = dp[i + 1][left, top] * v % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for ((left, top), v) in dp[2 * n - 1].items():",
      "mutated_line": "for ((left, top), v) in dp[2 / n - 1].items():",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 / n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for ((left, top), v) in dp[2 * n - 1].items():",
      "mutated_line": "for ((left, top), v) in dp[2 + n - 1].items():",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 + n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for ((left, top), v) in dp[2 * n - 1].items():",
      "mutated_line": "for ((left, top), v) in dp[2 ** n - 1].items():",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 ** n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for ((left, top), v) in dp[2 * n - 1].items():",
      "mutated_line": "for ((left, top), v) in dp[2 * n - 2].items():",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 2].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for ((left, top), v) in dp[2 * n - 1].items():",
      "mutated_line": "for ((left, top), v) in dp[2 * n - 0].items():",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 0].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for ((left, top), v) in dp[2 * n - 1].items():",
      "mutated_line": "for ((left, top), v) in dp[2 * n - 0].items():",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 0].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for ((left, top), v) in dp[2 * n - 1].items():",
      "mutated_line": "for ((left, top), v) in dp[2 * n - -1].items():",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - -1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left == 2 / n - 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 / n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left == 2 + n - 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 + n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left == 2 ** n - 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 ** n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left == 2 * n - 2",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 2\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left == 2 * n - 0",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 0\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left == 2 * n - 0",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 0\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left == 2 * n - -1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - -1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top and i + 1 + top[0] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 + top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top and (i + 1) * top[0] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and (i + 1) * top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] - v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] - v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = dp[i + 1][i + 1, top] * v % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = dp[i + 1][i + 1, top] * v % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 + left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 + left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif (i + 1) * left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif (i + 1) * left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 2 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 2 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 0 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 0 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 0 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 0 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > -1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > -1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 + top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 + top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and ((i + 1) * top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and ((i + 1) * top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] - v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] - v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = dp[i + 1][i + 1, top[1:]] * v % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = dp[i + 1][i + 1, top[1:]] * v % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i - 1 - top[-1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i - 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i * 1 - top[-1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i * 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "top.append(i + 1)",
      "mutated_line": "top.append(i + 2)",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 2)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "top.append(i + 1)",
      "mutated_line": "top.append(i + 0)",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 0)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "top.append(i + 1)",
      "mutated_line": "top.append(i + 0)",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 0)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "top.append(i + 1)",
      "mutated_line": "top.append(i + -1)",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + -1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i - 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i - 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i * 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i * 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for ((left, top), v) in dp[2 * n - 1].items():",
      "mutated_line": "for ((left, top), v) in dp[3 * n - 1].items():",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[3 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for ((left, top), v) in dp[2 * n - 1].items():",
      "mutated_line": "for ((left, top), v) in dp[1 * n - 1].items():",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[1 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for ((left, top), v) in dp[2 * n - 1].items():",
      "mutated_line": "for ((left, top), v) in dp[0 * n - 1].items():",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[0 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for ((left, top), v) in dp[2 * n - 1].items():",
      "mutated_line": "for ((left, top), v) in dp[1 * n - 1].items():",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[1 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for ((left, top), v) in dp[2 * n - 1].items():",
      "mutated_line": "for ((left, top), v) in dp[-2 * n - 1].items():",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[-2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left == 3 * n - 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 3 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left == 1 * n - 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 1 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left == 0 * n - 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 0 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left == 1 * n - 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 1 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "assert left == 2 * n - 1",
      "mutated_line": "assert left == -2 * n - 1",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == -2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top and i - 1 - top[0] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i - 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top and i * 1 - top[0] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i * 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i - 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i - 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i * 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i * 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i - 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i - 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i * 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i * 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i - 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i - 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i * 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i * 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and (i - 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i - 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and (i * 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i * 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i - 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i - 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i * 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i * 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i - 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i - 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i * 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i * 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i + 2 - top[-1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 2 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i + 0 - top[-1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 0 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i + 0 - top[-1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 0 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i + -1 - top[-1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + -1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i + 1 - top[+1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[+1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i + 2][left, top] = (dp[i + 1][left, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 2][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i + 0][left, top] = (dp[i + 1][left, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 0][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i + 0][left, top] = (dp[i + 1][left, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 0][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i + -1][left, top] = (dp[i + 1][left, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + -1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top and i + 2 - top[0] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 2 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top and i + 0 - top[0] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 0 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top and i + 0 - top[0] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 0 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top and i + -1 - top[0] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + -1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top and i + 1 - top[1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[1] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top and i + 1 - top[-1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[-1] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if top and i + 1 - top[0] <= k:",
      "mutated_line": "if top and i + 1 - top[1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[1] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 2][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 2][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 0][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 0][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 0][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 0][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + -1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + -1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 2, top] = (dp[i + 1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 2, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 0, top] = (dp[i + 1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 0, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 0, top] = (dp[i + 1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 0, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + -1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + -1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 2 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 2 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 0 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 0 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 0 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 0 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + -1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + -1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 2 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 2 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 0 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 0 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 0 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 0 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and (i + -1 - top[1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + -1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[2] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[2] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[0] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[0] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[0] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[0] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):",
      "mutated_line": "elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[-1] <= k):",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[-1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 2][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 2][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 0][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 0][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 0][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 0][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + -1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + -1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 2, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 2, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 0, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 0, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 0, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 0, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + -1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + -1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i + 1 - top[-2] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-2] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i + 1 - top[-0] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-0] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i + 1 - top[-0] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-0] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if top and i + 1 - top[-1] <= k:",
      "mutated_line": "if top and i + 1 - top[--1] <= k:",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[--1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i + 1][left, top] = (dp[i - 1][left, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i - 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i + 1][left, top] = (dp[i * 1][left, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i * 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = (dp[i - 1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i - 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = (dp[i * 1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i * 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i - 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i - 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i * 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i * 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[2:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[2:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[0:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[0:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[0:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[0:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[-1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[-1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i - 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i - 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i * 1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i * 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i - 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i - 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i * 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i * 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i + 1][left, top] = (dp[i + 2][left, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 2][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i + 1][left, top] = (dp[i + 0][left, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 0][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i + 1][left, top] = (dp[i + 0][left, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 0][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m",
      "mutated_line": "dp[i + 1][left, top] = (dp[i + -1][left, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + -1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = (dp[i + 2][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 2][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = (dp[i + 0][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 0][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = (dp[i + 0][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 0][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = (dp[i + -1][i + 1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + -1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 2, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 2, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 0, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 0, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 0, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 0, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top] = (dp[i + 1][i + -1, top] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + -1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 2][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 2][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 0][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 0][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 0][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 0][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + -1][i + 1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + -1][i + 1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 2, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 2, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 0, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 0, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 0, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 0, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + -1, top[1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + -1, top[1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[2:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[2:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[0:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[0:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[0:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[0:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[1:]] + v) % m",
      "mutated_line": "dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[-1:]] + v) % m",
      "code": "from collections import Counter\n\ndef count_valid_grid_configurations(n, k, m):\n    dp = [Counter() for _ in range(2 * n)]\n    dp[0][None, (0,)] = 1\n    for i in range(2 * n - 1):\n        for ((left, top), v) in dp[i].items():\n            if len(top) > k + 1:\n                continue\n            if left == None:\n                if top and i + 1 - top[0] <= k:\n                    dp[i + 1][i + 1, top] = (dp[i + 1][i + 1, top] + v) % m\n            elif i + 1 - left <= k and len(top) > 1 and (i + 1 - top[1] <= k):\n                dp[i + 1][i + 1, top[1:]] = (dp[i + 1][i + 1, top[-1:]] + v) % m\n            if top and i + 1 - top[-1] <= k:\n                top = list(top)\n                top.append(i + 1)\n                top = tuple(top)\n                dp[i + 1][left, top] = (dp[i + 1][left, top] + v) % m\n    res = 0\n    for ((left, top), v) in dp[2 * n - 1].items():\n        if len(top) == 1:\n            assert left == 2 * n - 1\n            res = (res + v) % m\n    return res"
    }
  ]
}