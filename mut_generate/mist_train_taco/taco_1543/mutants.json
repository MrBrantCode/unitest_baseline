{
  "task_id": "taco_1543",
  "entry_point": "count_same_path_configurations",
  "mutant_count": 66,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "z = 0",
      "mutated_line": "z = 1",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 1\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "z = 0",
      "mutated_line": "z = -1",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = -1\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "z = 0",
      "mutated_line": "z = 1",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 1\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if len(a) == 0 and len(b) == 0:",
      "mutated_line": "if len(a) == 0 or len(b) == 0:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 or len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if a[i] == b[i]:",
      "mutated_line": "if a[i] != b[i]:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] != b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "z += 1",
      "mutated_line": "z -= 1",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z -= 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if len(a) == 0 and len(b) == 0:",
      "mutated_line": "if len(a) != 0 and len(b) == 0:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) != 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if len(a) == 0 and len(b) == 0:",
      "mutated_line": "if len(a) == 0 and len(b) != 0:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) != 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "f1 = y + a",
      "mutated_line": "f1 = y - a",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y - a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "f1 = y + a",
      "mutated_line": "f1 = y * a",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y * a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "f2 = y + b",
      "mutated_line": "f2 = y - b",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y - b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "f2 = y + b",
      "mutated_line": "f2 = y * b",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y * b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 2) > n and int(f2, 2) > n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n and int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "ans -= 1",
      "mutated_line": "ans += 1",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans += 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "a = bin(u)[2:]",
      "mutated_line": "a = bin(u)[3:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[3:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "a = bin(u)[2:]",
      "mutated_line": "a = bin(u)[1:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[1:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "a = bin(u)[2:]",
      "mutated_line": "a = bin(u)[0:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[0:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "a = bin(u)[2:]",
      "mutated_line": "a = bin(u)[1:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[1:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "a = bin(u)[2:]",
      "mutated_line": "a = bin(u)[-2:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[-2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = bin(v)[2:]",
      "mutated_line": "b = bin(v)[3:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[3:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = bin(v)[2:]",
      "mutated_line": "b = bin(v)[1:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[1:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = bin(v)[2:]",
      "mutated_line": "b = bin(v)[0:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[0:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = bin(v)[2:]",
      "mutated_line": "b = bin(v)[1:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[1:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = bin(v)[2:]",
      "mutated_line": "b = bin(v)[-2:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[-2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z += 1",
      "mutated_line": "z += 2",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 2\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z += 1",
      "mutated_line": "z += 0",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 0\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z += 1",
      "mutated_line": "z += 0",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 0\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z += 1",
      "mutated_line": "z += -1",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += -1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(a) == 0 and len(b) == 0:",
      "mutated_line": "if len(a) == 1 and len(b) == 0:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 1 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(a) == 0 and len(b) == 0:",
      "mutated_line": "if len(a) == -1 and len(b) == 0:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == -1 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(a) == 0 and len(b) == 0:",
      "mutated_line": "if len(a) == 1 and len(b) == 0:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 1 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(a) == 0 and len(b) == 0:",
      "mutated_line": "if len(a) == 0 and len(b) == 1:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 1:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(a) == 0 and len(b) == 0:",
      "mutated_line": "if len(a) == 0 and len(b) == -1:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == -1:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(a) == 0 and len(b) == 0:",
      "mutated_line": "if len(a) == 0 and len(b) == 1:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 1:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = int(y, 2)",
      "mutated_line": "ans = int(y, 3)",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 3)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = int(y, 2)",
      "mutated_line": "ans = int(y, 1)",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 1)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = int(y, 2)",
      "mutated_line": "ans = int(y, 0)",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 0)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = int(y, 2)",
      "mutated_line": "ans = int(y, 1)",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 1)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = int(y, 2)",
      "mutated_line": "ans = int(y, -2)",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, -2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 2) >= n or int(f2, 2) > n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) >= n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 2) <= n or int(f2, 2) > n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) <= n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 2) != n or int(f2, 2) > n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) != n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 2) > n or int(f2, 2) >= n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) >= n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 2) > n or int(f2, 2) <= n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) <= n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 2) > n or int(f2, 2) != n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) != n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 2",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 2\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 0",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 0\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 0",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 0\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= -1",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= -1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "zz = bin(n)[2:]",
      "mutated_line": "zz = bin(n)[3:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[3:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "zz = bin(n)[2:]",
      "mutated_line": "zz = bin(n)[1:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[1:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "zz = bin(n)[2:]",
      "mutated_line": "zz = bin(n)[0:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[0:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "zz = bin(n)[2:]",
      "mutated_line": "zz = bin(n)[1:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[1:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "zz = bin(n)[2:]",
      "mutated_line": "zz = bin(n)[-2:]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[-2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "y = zz[:x - m]",
      "mutated_line": "y = zz[:x + m]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x + m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "y = zz[:x - m]",
      "mutated_line": "y = zz[:x * m]",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x * m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 3) > n or int(f2, 2) > n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 3) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 1) > n or int(f2, 2) > n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 1) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 0) > n or int(f2, 2) > n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 0) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 1) > n or int(f2, 2) > n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 1) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, -2) > n or int(f2, 2) > n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, -2) > n or int(f2, 2) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 2) > n or int(f2, 3) > n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 3) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 2) > n or int(f2, 1) > n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 1) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 2) > n or int(f2, 0) > n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 0) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 2) > n or int(f2, 1) > n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, 1) > n:\n            ans -= 1\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if int(f1, 2) > n or int(f2, 2) > n:",
      "mutated_line": "if int(f1, 2) > n or int(f2, -2) > n:",
      "code": "def count_same_path_configurations(n, u, v):\n    a = bin(u)[2:]\n    b = bin(v)[2:]\n    z = 0\n    l = min(len(a), len(b))\n    for i in range(l):\n        if a[i] == b[i]:\n            z += 1\n        else:\n            break\n    a = a[z:]\n    b = b[z:]\n    if len(a) == 0 and len(b) == 0:\n        return n\n    else:\n        m = max(len(a), len(b))\n        zz = bin(n)[2:]\n        x = len(zz)\n        y = zz[:x - m]\n        f1 = y + a\n        f2 = y + b\n        ans = int(y, 2)\n        if int(f1, 2) > n or int(f2, -2) > n:\n            ans -= 1\n        return ans"
    }
  ]
}