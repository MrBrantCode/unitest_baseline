{
  "task_id": "taco_15990",
  "entry_point": "binarize",
  "mutant_count": 100,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "power = 0",
      "mutated_line": "power = 1",
      "code": "def binarize(num):\n    powers = []\n    power = 1\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "power = 0",
      "mutated_line": "power = -1",
      "code": "def binarize(num):\n    powers = []\n    power = -1\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "power = 0",
      "mutated_line": "power = 1",
      "code": "def binarize(num):\n    powers = []\n    power = 1\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while num > 0:",
      "mutated_line": "while num >= 0:",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num >= 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while num > 0:",
      "mutated_line": "while num <= 0:",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num <= 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while num > 0:",
      "mutated_line": "while num != 0:",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num != 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "power += 1",
      "mutated_line": "power -= 1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power -= 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "return s == 0",
      "mutated_line": "return s != 0",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s != 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mid = (mn + mx) // 2",
      "mutated_line": "mid = (mn + mx) / 2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) / 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mid = (mn + mx) // 2",
      "mutated_line": "mid = (mn + mx) * 2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) * 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if mid == mn:",
      "mutated_line": "if mid != mn:",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid != mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if s < x:",
      "mutated_line": "if s <= x:",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s <= x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if s < x:",
      "mutated_line": "if s >= x:",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s >= x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if s < x:",
      "mutated_line": "if s != x:",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s != x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "repeats = 1",
      "mutated_line": "repeats = 2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 2\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "repeats = 1",
      "mutated_line": "repeats = 0",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 0\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "repeats = 1",
      "mutated_line": "repeats = 0",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 0\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "repeats = 1",
      "mutated_line": "repeats = -1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = -1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "s = s - x",
      "mutated_line": "s = s + x",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s + x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "s = s - x",
      "mutated_line": "s = s * x",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s * x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "mintimes = 0",
      "mutated_line": "mintimes = 1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 1\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "mintimes = 0",
      "mutated_line": "mintimes = -1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = -1\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "mintimes = 0",
      "mutated_line": "mintimes = 1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 1\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if s != 0:",
      "mutated_line": "if s == 0:",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s == 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return optimize(binx, origs, -1, mintimes) + repeats",
      "mutated_line": "return optimize(binx, origs, -1, mintimes) - repeats",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) - repeats"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return optimize(binx, origs, -1, mintimes) + repeats",
      "mutated_line": "return optimize(binx, origs, -1, mintimes) * repeats",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) * repeats"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while num > 0:",
      "mutated_line": "while num > 1:",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 1:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while num > 0:",
      "mutated_line": "while num > -1:",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > -1:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while num > 0:",
      "mutated_line": "while num > 1:",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 1:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "bit = num % 2",
      "mutated_line": "bit = num * 2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num * 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "bit = num % 2",
      "mutated_line": "bit = num + 2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num + 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "num = num // 2",
      "mutated_line": "num = num / 2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num / 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "num = num // 2",
      "mutated_line": "num = num * 2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num * 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "power += 1",
      "mutated_line": "power += 2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 2\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "power += 1",
      "mutated_line": "power += 0",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 0\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "power += 1",
      "mutated_line": "power += 0",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 0\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "power += 1",
      "mutated_line": "power += -1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += -1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "val = 2 ** power",
      "mutated_line": "val = 2 * power",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 * power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "val = 2 ** power",
      "mutated_line": "val = 2 + power",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 + power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "s = s - val * times",
      "mutated_line": "s = s + val * times",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s + val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "s = s - val * times",
      "mutated_line": "s = s * (val * times)",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s * (val * times)\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return s == 0",
      "mutated_line": "return s == 1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 1\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return s == 0",
      "mutated_line": "return s == -1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == -1\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return s == 0",
      "mutated_line": "return s == 1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 1\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mid = (mn + mx) // 2",
      "mutated_line": "mid = (mn - mx) // 2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn - mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mid = (mn + mx) // 2",
      "mutated_line": "mid = mn * mx // 2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = mn * mx // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mid = (mn + mx) // 2",
      "mutated_line": "mid = (mn + mx) // 3",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 3\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mid = (mn + mx) // 2",
      "mutated_line": "mid = (mn + mx) // 1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 1\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mid = (mn + mx) // 2",
      "mutated_line": "mid = (mn + mx) // 0",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 0\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mid = (mn + mx) // 2",
      "mutated_line": "mid = (mn + mx) // 1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 1\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mid = (mn + mx) // 2",
      "mutated_line": "mid = (mn + mx) // -2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // -2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return +1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "val = 2 ** power",
      "mutated_line": "val = 2 * power",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 * power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "val = 2 ** power",
      "mutated_line": "val = 2 + power",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 + power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "times = s // val",
      "mutated_line": "times = s / val",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s / val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "times = s // val",
      "mutated_line": "times = s * val",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s * val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "s = s % val",
      "mutated_line": "s = s * val",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s * val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "s = s % val",
      "mutated_line": "s = s + val",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s + val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if s != 0:",
      "mutated_line": "if s != 1:",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 1:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if s != 0:",
      "mutated_line": "if s != -1:",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != -1:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if s != 0:",
      "mutated_line": "if s != 1:",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 1:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return +1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "bit = num % 2",
      "mutated_line": "bit = num % 3",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 3\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "bit = num % 2",
      "mutated_line": "bit = num % 1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 1\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "bit = num % 2",
      "mutated_line": "bit = num % 0",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 0\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "bit = num % 2",
      "mutated_line": "bit = num % 1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 1\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "bit = num % 2",
      "mutated_line": "bit = num % -2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % -2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "num = num // 2",
      "mutated_line": "num = num // 3",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 3\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "num = num // 2",
      "mutated_line": "num = num // 1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 1\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "num = num // 2",
      "mutated_line": "num = num // 0",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 0\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "num = num // 2",
      "mutated_line": "num = num // 1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 1\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "num = num // 2",
      "mutated_line": "num = num // -2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // -2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "val = 2 ** power",
      "mutated_line": "val = 3 ** power",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 3 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "val = 2 ** power",
      "mutated_line": "val = 1 ** power",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 1 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "val = 2 ** power",
      "mutated_line": "val = 0 ** power",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 0 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "val = 2 ** power",
      "mutated_line": "val = 1 ** power",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 1 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "val = 2 ** power",
      "mutated_line": "val = -2 ** power",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = -2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "times = min(s // val, mpw)",
      "mutated_line": "times = min(s / val, mpw)",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s / val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "times = min(s // val, mpw)",
      "mutated_line": "times = min(s * val, mpw)",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s * val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "s = s - val * times",
      "mutated_line": "s = s - val / times",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val / times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "s = s - val * times",
      "mutated_line": "s = s - (val + times)",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - (val + times)\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "s = s - val * times",
      "mutated_line": "s = s - val ** times",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val ** times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -2\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -0\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -0\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return --1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "val = 2 ** power",
      "mutated_line": "val = 3 ** power",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 3 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "val = 2 ** power",
      "mutated_line": "val = 1 ** power",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 1 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "val = 2 ** power",
      "mutated_line": "val = 0 ** power",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 0 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "val = 2 ** power",
      "mutated_line": "val = 1 ** power",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 1 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "val = 2 ** power",
      "mutated_line": "val = -2 ** power",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = -2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -2\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -0\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -0\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return --1\n    return optimize(binx, origs, -1, mintimes) + repeats"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "return optimize(binx, origs, -1, mintimes) + repeats",
      "mutated_line": "return optimize(binx, origs, +1, mintimes) + repeats",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, +1, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return optimize(binx, origs, -1, mintimes) + repeats",
      "mutated_line": "return optimize(binx, origs, -2, mintimes) + repeats",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -2, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return optimize(binx, origs, -1, mintimes) + repeats",
      "mutated_line": "return optimize(binx, origs, -0, mintimes) + repeats",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -0, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return optimize(binx, origs, -1, mintimes) + repeats",
      "mutated_line": "return optimize(binx, origs, -0, mintimes) + repeats",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, -0, mintimes) + repeats"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return optimize(binx, origs, -1, mintimes) + repeats",
      "mutated_line": "return optimize(binx, origs, --1, mintimes) + repeats",
      "code": "def binarize(num):\n    powers = []\n    power = 0\n    while num > 0:\n        bit = num % 2\n        num = num // 2\n        if bit:\n            powers.append(power)\n        power += 1\n    return list(reversed(powers))\n\ndef possible(binx, s, mpw):\n    for power in binx:\n        val = 2 ** power\n        times = min(s // val, mpw)\n        s = s - val * times\n    return s == 0\n\ndef optimize(binx, s, mn, mx):\n    mid = (mn + mx) // 2\n    if mid == mn:\n        return mx\n    if possible(binx, s, mid):\n        return optimize(binx, s, mn, mid)\n    else:\n        return optimize(binx, s, mid, mx)\n\ndef find_shortest_sequence_length(x, s):\n    if s < x:\n        return -1\n    origs = s\n    repeats = 1\n    s = s - x\n    origs = s\n    binx = binarize(x)\n    mintimes = 0\n    for power in binx:\n        val = 2 ** power\n        times = s // val\n        s = s % val\n        mintimes = max(mintimes, times)\n    if s != 0:\n        return -1\n    return optimize(binx, origs, --1, mintimes) + repeats"
    }
  ]
}