{
  "task_id": "taco_16006",
  "entry_point": "determine_survival_order",
  "mutant_count": 81,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "consume = [0] * n",
      "mutated_line": "consume = [0] / n",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] / n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "consume = [0] * n",
      "mutated_line": "consume = [0] + n",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] + n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "consume = [0] * n",
      "mutated_line": "consume = [0] ** n",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] ** n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "x -= 1",
      "mutated_line": "x += 1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x += 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "y -= 1",
      "mutated_line": "y += 1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y += 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "consume[x] += 1",
      "mutated_line": "consume[x] -= 1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] -= 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "consume[y] += 1",
      "mutated_line": "consume[y] -= 1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] -= 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mark = [False] * m",
      "mutated_line": "mark = [False] / m",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] / m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mark = [False] * m",
      "mutated_line": "mark = [False] + m",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] + m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mark = [False] * m",
      "mutated_line": "mark = [False] ** m",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] ** m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x -= 1",
      "mutated_line": "x -= 2",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 2\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 0\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 0\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x -= 1",
      "mutated_line": "x -= -1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= -1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "y -= 1",
      "mutated_line": "y -= 2",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 2\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 0\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 0\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "y -= 1",
      "mutated_line": "y -= -1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= -1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "consume[x] += 1",
      "mutated_line": "consume[x] += 2",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 2\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "consume[x] += 1",
      "mutated_line": "consume[x] += 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 0\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "consume[x] += 1",
      "mutated_line": "consume[x] += 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 0\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "consume[x] += 1",
      "mutated_line": "consume[x] += -1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += -1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "consume[y] += 1",
      "mutated_line": "consume[y] += 2",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 2\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "consume[y] += 1",
      "mutated_line": "consume[y] += 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 0\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "consume[y] += 1",
      "mutated_line": "consume[y] += 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 0\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "consume[y] += 1",
      "mutated_line": "consume[y] += -1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += -1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if cost != max(0, consume[idx] - foods[idx]):",
      "mutated_line": "if cost == max(0, consume[idx] - foods[idx]):",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost == max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if cost > 0:",
      "mutated_line": "if cost >= 0:",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost >= 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if cost > 0:",
      "mutated_line": "if cost <= 0:",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost <= 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if cost > 0:",
      "mutated_line": "if cost != 0:",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost != 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return \"ALIVE\", [x + 1 for x in ans]",
      "mutated_line": "return ('', [x + 1 for x in ans])",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "consume = [0] * n",
      "mutated_line": "consume = [1] * n",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [1] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "consume = [0] * n",
      "mutated_line": "consume = [-1] * n",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [-1] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "consume = [0] * n",
      "mutated_line": "consume = [1] * n",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [1] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mark = [False] * m",
      "mutated_line": "mark = [True] * m",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [True] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if cost > 0:",
      "mutated_line": "if cost > 1:",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 1:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if cost > 0:",
      "mutated_line": "if cost > -1:",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > -1:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if cost > 0:",
      "mutated_line": "if cost > 1:",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 1:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "x -= 1",
      "mutated_line": "x += 1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x += 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "y -= 1",
      "mutated_line": "y += 1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y += 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "consume[x] -= 1",
      "mutated_line": "consume[x] += 1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] += 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "consume[y] -= 1",
      "mutated_line": "consume[y] += 1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] += 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return \"ALIVE\", [x + 1 for x in ans]",
      "mutated_line": "return ('ALIVE', [x - 1 for x in ans])",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x - 1 for x in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return \"ALIVE\", [x + 1 for x in ans]",
      "mutated_line": "return ('ALIVE', [x * 1 for x in ans])",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x * 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]",
      "mutated_line": "priority_queue = [(max(1, consume[i] - foods[i]), i) for i in range(n)]",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(1, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]",
      "mutated_line": "priority_queue = [(max(-1, consume[i] - foods[i]), i) for i in range(n)]",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(-1, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]",
      "mutated_line": "priority_queue = [(max(1, consume[i] - foods[i]), i) for i in range(n)]",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(1, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]",
      "mutated_line": "priority_queue = [(max(0, consume[i] + foods[i]), i) for i in range(n)]",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] + foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]",
      "mutated_line": "priority_queue = [(max(0, consume[i] * foods[i]), i) for i in range(n)]",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] * foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if cost != max(0, consume[idx] - foods[idx]):",
      "mutated_line": "if cost != max(1, consume[idx] - foods[idx]):",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(1, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if cost != max(0, consume[idx] - foods[idx]):",
      "mutated_line": "if cost != max(-1, consume[idx] - foods[idx]):",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(-1, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if cost != max(0, consume[idx] - foods[idx]):",
      "mutated_line": "if cost != max(1, consume[idx] - foods[idx]):",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(1, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if cost != max(0, consume[idx] - foods[idx]):",
      "mutated_line": "if cost != max(0, consume[idx] + foods[idx]):",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] + foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if cost != max(0, consume[idx] - foods[idx]):",
      "mutated_line": "if cost != max(0, consume[idx] * foods[idx]):",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] * foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return \"DEAD\", []",
      "mutated_line": "return ('', [])",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x -= 1",
      "mutated_line": "x -= 2",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 2\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 0\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 0\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x -= 1",
      "mutated_line": "x -= -1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= -1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "y -= 1",
      "mutated_line": "y -= 2",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 2\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 0\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 0\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "y -= 1",
      "mutated_line": "y -= -1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= -1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "consume[x] -= 1",
      "mutated_line": "consume[x] -= 2",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 2\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "consume[x] -= 1",
      "mutated_line": "consume[x] -= 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 0\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "consume[x] -= 1",
      "mutated_line": "consume[x] -= 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 0\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "consume[x] -= 1",
      "mutated_line": "consume[x] -= -1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= -1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "consume[y] -= 1",
      "mutated_line": "consume[y] -= 2",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 2\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "consume[y] -= 1",
      "mutated_line": "consume[y] -= 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 0\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "consume[y] -= 1",
      "mutated_line": "consume[y] -= 0",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 0\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "consume[y] -= 1",
      "mutated_line": "consume[y] -= -1",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= -1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "mark[p] = True",
      "mutated_line": "mark[p] = False",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = False\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return \"ALIVE\", [x + 1 for x in ans]",
      "mutated_line": "return ('ALIVE', [x + 2 for x in ans])",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 2 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return \"ALIVE\", [x + 1 for x in ans]",
      "mutated_line": "return ('ALIVE', [x + 0 for x in ans])",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 0 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return \"ALIVE\", [x + 1 for x in ans]",
      "mutated_line": "return ('ALIVE', [x + 0 for x in ans])",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 0 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return \"ALIVE\", [x + 1 for x in ans]",
      "mutated_line": "return ('ALIVE', [x + -1 for x in ans])",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + -1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))",
      "mutated_line": "heapq.heappush(priority_queue, (max(1, consume[v] - foods[v]), v))",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(1, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))",
      "mutated_line": "heapq.heappush(priority_queue, (max(-1, consume[v] - foods[v]), v))",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(-1, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))",
      "mutated_line": "heapq.heappush(priority_queue, (max(1, consume[v] - foods[v]), v))",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(1, consume[v] - foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))",
      "mutated_line": "heapq.heappush(priority_queue, (max(0, consume[v] + foods[v]), v))",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] + foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "heapq.heappush(priority_queue, (max(0, consume[v] - foods[v]), v))",
      "mutated_line": "heapq.heappush(priority_queue, (max(0, consume[v] * foods[v]), v))",
      "code": "import heapq\n\ndef determine_survival_order(n, m, foods, friends_food):\n    consume = [0] * n\n    food_friend = [[] for _ in range(n)]\n    for i in range(m):\n        (x, y) = friends_food[i]\n        x -= 1\n        y -= 1\n        food_friend[x].append(i)\n        food_friend[y].append(i)\n        consume[x] += 1\n        consume[y] += 1\n    priority_queue = [(max(0, consume[i] - foods[i]), i) for i in range(n)]\n    heapq.heapify(priority_queue)\n    mark = [False] * m\n    ans = []\n    while priority_queue:\n        (cost, idx) = heapq.heappop(priority_queue)\n        if cost != max(0, consume[idx] - foods[idx]):\n            continue\n        if cost > 0:\n            return ('DEAD', [])\n        delta = set()\n        for p in food_friend[idx]:\n            if not mark[p]:\n                (x, y) = friends_food[p]\n                x -= 1\n                y -= 1\n                consume[x] -= 1\n                consume[y] -= 1\n                mark[p] = True\n                ans.append(p)\n                delta.add(x)\n                delta.add(y)\n        for v in delta:\n            heapq.heappush(priority_queue, (max(0, consume[v] * foods[v]), v))\n    ans.reverse()\n    return ('ALIVE', [x + 1 for x in ans])"
    }
  ]
}