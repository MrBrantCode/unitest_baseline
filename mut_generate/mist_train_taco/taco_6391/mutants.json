{
  "task_id": "taco_6391",
  "entry_point": "max_sum_two_no_overlap",
  "mutant_count": 100,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if L + M > N:",
      "mutated_line": "if L + M >= N:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M >= N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if L + M > N:",
      "mutated_line": "if L + M <= N:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M <= N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if L + M > N:",
      "mutated_line": "if L + M != N:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M != N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if L == M:",
      "mutated_line": "if L != M:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L != M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if L + M > N:",
      "mutated_line": "if L - M > N:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L - M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if L + M > N:",
      "mutated_line": "if L * M > N:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L * M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return +1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -2\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -0\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -0\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return --1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(L, N - M):",
      "mutated_line": "for i in range(L, N + M):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N + M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(L, N - M):",
      "mutated_line": "for i in range(L, N * M):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N * M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "tmp = sL[-1] + A[i] - A[i - L]",
      "mutated_line": "tmp = sL[-1] + A[i] + A[i - L]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] + A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "tmp = sL[-1] + A[i] - A[i - L]",
      "mutated_line": "tmp = (sL[-1] + A[i]) * A[i - L]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = (sL[-1] + A[i]) * A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, len(sL)):",
      "mutated_line": "for i in range(2, len(sL)):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(2, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, len(sL)):",
      "mutated_line": "for i in range(0, len(sL)):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(0, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, len(sL)):",
      "mutated_line": "for i in range(0, len(sL)):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(0, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, len(sL)):",
      "mutated_line": "for i in range(-1, len(sL)):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(-1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if sL[i] > sLmax[-1]:",
      "mutated_line": "if sL[i] >= sLmax[-1]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] >= sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if sL[i] > sLmax[-1]:",
      "mutated_line": "if sL[i] <= sLmax[-1]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] <= sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if sL[i] > sLmax[-1]:",
      "mutated_line": "if sL[i] != sLmax[-1]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] != sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M + 1, L - 1, -1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M + 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range((N - M) * 1, L - 1, -1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range((N - M) * 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - 1, L + 1, -1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L + 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - 1, L * 1, -1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L * 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - 1, L - 1, +1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, +1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "tmp = sM[-1] + A[i] - A[i + M]",
      "mutated_line": "tmp = sM[-1] + A[i] + A[i + M]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] + A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "tmp = sM[-1] + A[i] - A[i + M]",
      "mutated_line": "tmp = (sM[-1] + A[i]) * A[i + M]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = (sM[-1] + A[i]) * A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, len(sM)):",
      "mutated_line": "for i in range(2, len(sM)):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(2, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, len(sM)):",
      "mutated_line": "for i in range(0, len(sM)):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(0, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, len(sM)):",
      "mutated_line": "for i in range(0, len(sM)):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(0, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, len(sM)):",
      "mutated_line": "for i in range(-1, len(sM)):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(-1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if sM[i] > sMmax[-1]:",
      "mutated_line": "if sM[i] >= sMmax[-1]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] >= sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if sM[i] > sMmax[-1]:",
      "mutated_line": "if sM[i] <= sMmax[-1]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] <= sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if sM[i] > sMmax[-1]:",
      "mutated_line": "if sM[i] != sMmax[-1]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] != sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "tmp = sL[-1] + A[i] - A[i - L]",
      "mutated_line": "tmp = sL[-1] - A[i] - A[i - L]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] - A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "tmp = sL[-1] + A[i] - A[i - L]",
      "mutated_line": "tmp = sL[-1] * A[i] - A[i - L]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] * A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sLmax = [sL[0]]",
      "mutated_line": "sLmax = [sL[1]]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[1]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sLmax = [sL[0]]",
      "mutated_line": "sLmax = [sL[-1]]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[-1]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sLmax = [sL[0]]",
      "mutated_line": "sLmax = [sL[1]]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[1]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N + M - 1, L - 1, -1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N + M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N * M - 1, L - 1, -1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N * M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - 2, L - 1, -1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 2, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - 0, L - 1, -1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 0, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - 0, L - 1, -1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 0, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - -1, L - 1, -1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - -1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - 1, L - 2, -1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 2, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - 1, L - 0, -1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 0, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - 1, L - 0, -1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 0, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - 1, L - -1, -1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - -1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - 1, L - 1, -2):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -2):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - 1, L - 1, -0):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -0):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - 1, L - 1, -0):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -0):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(N - M - 1, L - 1, -1):",
      "mutated_line": "for i in range(N - M - 1, L - 1, --1):",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, --1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "tmp = sM[-1] + A[i] - A[i + M]",
      "mutated_line": "tmp = sM[-1] - A[i] - A[i + M]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] - A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "tmp = sM[-1] + A[i] - A[i + M]",
      "mutated_line": "tmp = sM[-1] * A[i] - A[i + M]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] * A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sMmax = [sM[0]]",
      "mutated_line": "sMmax = [sM[1]]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[1]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sMmax = [sM[0]]",
      "mutated_line": "sMmax = [sM[-1]]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[-1]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sMmax = [sM[0]]",
      "mutated_line": "sMmax = [sM[1]]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[1]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "tmp = sL[-1] + A[i] - A[i - L]",
      "mutated_line": "tmp = sL[-1] + A[i] - A[i + L]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i + L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "tmp = sL[-1] + A[i] - A[i - L]",
      "mutated_line": "tmp = sL[-1] + A[i] - A[i * L]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i * L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "if sL[i] > sLmax[-1]:",
      "mutated_line": "if sL[i] > sLmax[+1]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[+1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "tmp = sM[-1] + A[i] - A[i + M]",
      "mutated_line": "tmp = sM[-1] + A[i] - A[i - M]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i - M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "tmp = sM[-1] + A[i] - A[i + M]",
      "mutated_line": "tmp = sM[-1] + A[i] - A[i * M]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i * M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "if sM[i] > sMmax[-1]:",
      "mutated_line": "if sM[i] > sMmax[+1]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[+1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "tmp = sL[-1] + A[i] - A[i - L]",
      "mutated_line": "tmp = sL[+1] + A[i] - A[i - L]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[+1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if sL[i] > sLmax[-1]:",
      "mutated_line": "if sL[i] > sLmax[-2]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-2]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if sL[i] > sLmax[-1]:",
      "mutated_line": "if sL[i] > sLmax[-0]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-0]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if sL[i] > sLmax[-1]:",
      "mutated_line": "if sL[i] > sLmax[-0]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-0]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if sL[i] > sLmax[-1]:",
      "mutated_line": "if sL[i] > sLmax[--1]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[--1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "sLmax.append(sLmax[-1])",
      "mutated_line": "sLmax.append(sLmax[+1])",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[+1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "sM = [sum(A[-M:])]",
      "mutated_line": "sM = [sum(A[+M:])]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[+M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "tmp = sM[-1] + A[i] - A[i + M]",
      "mutated_line": "tmp = sM[+1] + A[i] - A[i + M]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[+1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if sM[i] > sMmax[-1]:",
      "mutated_line": "if sM[i] > sMmax[-2]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-2]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if sM[i] > sMmax[-1]:",
      "mutated_line": "if sM[i] > sMmax[-0]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-0]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if sM[i] > sMmax[-1]:",
      "mutated_line": "if sM[i] > sMmax[-0]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-0]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if sM[i] > sMmax[-1]:",
      "mutated_line": "if sM[i] > sMmax[--1]:",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[--1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "sMmax.append(sMmax[-1])",
      "mutated_line": "sMmax.append(sMmax[+1])",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[+1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tmp = sL[-1] + A[i] - A[i - L]",
      "mutated_line": "tmp = sL[-2] + A[i] - A[i - L]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-2] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tmp = sL[-1] + A[i] - A[i - L]",
      "mutated_line": "tmp = sL[-0] + A[i] - A[i - L]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-0] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tmp = sL[-1] + A[i] - A[i - L]",
      "mutated_line": "tmp = sL[-0] + A[i] - A[i - L]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-0] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tmp = sL[-1] + A[i] - A[i - L]",
      "mutated_line": "tmp = sL[--1] + A[i] - A[i - L]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[--1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sLmax.append(sLmax[-1])",
      "mutated_line": "sLmax.append(sLmax[-2])",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-2])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sLmax.append(sLmax[-1])",
      "mutated_line": "sLmax.append(sLmax[-0])",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-0])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sLmax.append(sLmax[-1])",
      "mutated_line": "sLmax.append(sLmax[-0])",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-0])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sLmax.append(sLmax[-1])",
      "mutated_line": "sLmax.append(sLmax[--1])",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[--1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tmp = sM[-1] + A[i] - A[i + M]",
      "mutated_line": "tmp = sM[-2] + A[i] - A[i + M]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-2] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tmp = sM[-1] + A[i] - A[i + M]",
      "mutated_line": "tmp = sM[-0] + A[i] - A[i + M]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-0] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tmp = sM[-1] + A[i] - A[i + M]",
      "mutated_line": "tmp = sM[-0] + A[i] - A[i + M]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-0] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tmp = sM[-1] + A[i] - A[i + M]",
      "mutated_line": "tmp = sM[--1] + A[i] - A[i + M]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[--1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "sMmax.append(sMmax[-1])",
      "mutated_line": "sMmax.append(sMmax[-2])",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-2])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "sMmax.append(sMmax[-1])",
      "mutated_line": "sMmax.append(sMmax[-0])",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-0])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "sMmax.append(sMmax[-1])",
      "mutated_line": "sMmax.append(sMmax[-0])",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-0])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "sMmax.append(sMmax[-1])",
      "mutated_line": "sMmax.append(sMmax[--1])",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[--1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]",
      "mutated_line": "sMax = [sum(x) for x in zip(sLmax, sMmax[::+1])]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::+1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]",
      "mutated_line": "sMax = [sum(x) for x in zip(sLmax, sMmax[::-2])]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-2])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]",
      "mutated_line": "sMax = [sum(x) for x in zip(sLmax, sMmax[::-0])]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-0])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]",
      "mutated_line": "sMax = [sum(x) for x in zip(sLmax, sMmax[::-0])]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::-0])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]",
      "mutated_line": "sMax = [sum(x) for x in zip(sLmax, sMmax[::--1])]",
      "code": "def max_sum_two_no_overlap(A, L, M):\n    N = len(A)\n    if L + M > N:\n        return -1\n\n    def findmax(L, M):\n        sL = [sum(A[:L])]\n        for i in range(L, N - M):\n            tmp = sL[-1] + A[i] - A[i - L]\n            sL.append(tmp)\n        sLmax = [sL[0]]\n        for i in range(1, len(sL)):\n            if sL[i] > sLmax[-1]:\n                sLmax.append(sL[i])\n            else:\n                sLmax.append(sLmax[-1])\n        sM = [sum(A[-M:])]\n        for i in range(N - M - 1, L - 1, -1):\n            tmp = sM[-1] + A[i] - A[i + M]\n            sM.append(tmp)\n        sMmax = [sM[0]]\n        for i in range(1, len(sM)):\n            if sM[i] > sMmax[-1]:\n                sMmax.append(sM[i])\n            else:\n                sMmax.append(sMmax[-1])\n        sMax = [sum(x) for x in zip(sLmax, sMmax[::--1])]\n        m = max(sMax)\n        return m\n    if L == M:\n        return findmax(L, M)\n    else:\n        return max(findmax(L, M), findmax(M, L))"
    }
  ]
}