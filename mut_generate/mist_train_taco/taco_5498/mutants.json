{
  "task_id": "taco_5498",
  "entry_point": "shortest_path_all_keys",
  "mutant_count": 130,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "all_keys_bitmap = 2 ** key_cnt - 1",
      "mutated_line": "all_keys_bitmap = 2 ** key_cnt + 1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt + 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "all_keys_bitmap = 2 ** key_cnt - 1",
      "mutated_line": "all_keys_bitmap = 2 ** key_cnt * 1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt * 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "final_dist['@', 0] = 0",
      "mutated_line": "final_dist['@', 0] = 1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 1\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "final_dist['@', 0] = 0",
      "mutated_line": "final_dist['@', 0] = -1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = -1\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "final_dist['@', 0] = 0",
      "mutated_line": "final_dist['@', 0] = 1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 1\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "seen[i, j] = True",
      "mutated_line": "seen[i, j] = False",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = False\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "all_keys_bitmap = 2 ** key_cnt - 1",
      "mutated_line": "all_keys_bitmap = 2 * key_cnt - 1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 * key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "all_keys_bitmap = 2 ** key_cnt - 1",
      "mutated_line": "all_keys_bitmap = 2 + key_cnt - 1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 + key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "all_keys_bitmap = 2 ** key_cnt - 1",
      "mutated_line": "all_keys_bitmap = 2 ** key_cnt - 2",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 2\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "all_keys_bitmap = 2 ** key_cnt - 1",
      "mutated_line": "all_keys_bitmap = 2 ** key_cnt - 0",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 0\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "all_keys_bitmap = 2 ** key_cnt - 1",
      "mutated_line": "all_keys_bitmap = 2 ** key_cnt - 0",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 0\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "all_keys_bitmap = 2 ** key_cnt - 1",
      "mutated_line": "all_keys_bitmap = 2 ** key_cnt - -1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - -1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if final_dist[ch, keys_bitmap] < d:",
      "mutated_line": "if final_dist[ch, keys_bitmap] <= d:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] <= d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if final_dist[ch, keys_bitmap] < d:",
      "mutated_line": "if final_dist[ch, keys_bitmap] >= d:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] >= d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if final_dist[ch, keys_bitmap] < d:",
      "mutated_line": "if final_dist[ch, keys_bitmap] != d:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] != d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if keys_bitmap == all_keys_bitmap:",
      "mutated_line": "if keys_bitmap != all_keys_bitmap:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap != all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return --1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}",
      "mutated_line": "key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch in {'.', '#'}}",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))",
      "mutated_line": "key_cnt = sum((key_lock not in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock not in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if ch != src and ch != '.':",
      "mutated_line": "if ch != src or ch != '.':",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src or ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "all_keys_bitmap = 2 ** key_cnt - 1",
      "mutated_line": "all_keys_bitmap = 3 ** key_cnt - 1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 3 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "all_keys_bitmap = 2 ** key_cnt - 1",
      "mutated_line": "all_keys_bitmap = 1 ** key_cnt - 1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 1 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "all_keys_bitmap = 2 ** key_cnt - 1",
      "mutated_line": "all_keys_bitmap = 0 ** key_cnt - 1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 0 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "all_keys_bitmap = 2 ** key_cnt - 1",
      "mutated_line": "all_keys_bitmap = 1 ** key_cnt - 1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 1 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "all_keys_bitmap = 2 ** key_cnt - 1",
      "mutated_line": "all_keys_bitmap = -2 ** key_cnt - 1",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = -2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [(0, '@', 0)]",
      "mutated_line": "hq = [(1, '@', 0)]",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(1, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [(0, '@', 0)]",
      "mutated_line": "hq = [(-1, '@', 0)]",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(-1, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [(0, '@', 0)]",
      "mutated_line": "hq = [(1, '@', 0)]",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(1, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [(0, '@', 0)]",
      "mutated_line": "hq = [(0, '', 0)]",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [(0, '@', 0)]",
      "mutated_line": "hq = [(0, '@', 1)]",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 1)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [(0, '@', 0)]",
      "mutated_line": "hq = [(0, '@', -1)]",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', -1)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "hq = [(0, '@', 0)]",
      "mutated_line": "hq = [(0, '@', 1)]",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 1)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "final_dist['@', 0] = 0",
      "mutated_line": "final_dist['', 0] = 0",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "final_dist['@', 0] = 0",
      "mutated_line": "final_dist['@', 1] = 0",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 1] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "final_dist['@', 0] = 0",
      "mutated_line": "final_dist['@', -1] = 0",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', -1] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "final_dist['@', 0] = 0",
      "mutated_line": "final_dist['@', 1] = 0",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 1] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if d + d2 < final_dist[next_key_lock, keys_bitmap2]:",
      "mutated_line": "if d + d2 <= final_dist[next_key_lock, keys_bitmap2]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 <= final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if d + d2 < final_dist[next_key_lock, keys_bitmap2]:",
      "mutated_line": "if d + d2 >= final_dist[next_key_lock, keys_bitmap2]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 >= final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if d + d2 < final_dist[next_key_lock, keys_bitmap2]:",
      "mutated_line": "if d + d2 != final_dist[next_key_lock, keys_bitmap2]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 != final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(m, n) = (len(grid), len(grid[0]))",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[1]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(m, n) = (len(grid), len(grid[0]))",
      "mutated_line": "(m, n) = (len(grid), len(grid[-1]))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[-1]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(m, n) = (len(grid), len(grid[0]))",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[1]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "seen = defaultdict(lambda : False)",
      "mutated_line": "seen = defaultdict(lambda : True)",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : True)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if ch != src and ch != '.':",
      "mutated_line": "if ch == src and ch != '.':",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch == src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if ch != src and ch != '.':",
      "mutated_line": "if ch != src and ch == '.':",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch == '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (0 <= x < m and 0 <= y < n) and grid[x][y] == '#' and seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) and grid[x][y] == '#' and seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "seen[x, y] = True",
      "mutated_line": "seen[x, y] = False",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = False\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "final_dist = defaultdict(lambda : float('inf'))",
      "mutated_line": "final_dist = defaultdict(lambda : float(''))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float(''))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if d + d2 < final_dist[next_key_lock, keys_bitmap2]:",
      "mutated_line": "if d - d2 < final_dist[next_key_lock, keys_bitmap2]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d - d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if d + d2 < final_dist[next_key_lock, keys_bitmap2]:",
      "mutated_line": "if d * d2 < final_dist[next_key_lock, keys_bitmap2]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d * d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "final_dist[next_key_lock, keys_bitmap2] = d + d2",
      "mutated_line": "final_dist[next_key_lock, keys_bitmap2] = d - d2",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d - d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "final_dist[next_key_lock, keys_bitmap2] = d + d2",
      "mutated_line": "final_dist[next_key_lock, keys_bitmap2] = d * d2",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d * d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}",
      "mutated_line": "key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'', '#'}}",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}",
      "mutated_line": "key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', ''}}",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', ''}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))",
      "mutated_line": "key_cnt = sum((key_lock in ('', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))",
      "mutated_line": "key_cnt = sum((key_lock in ('a', '', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', '', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))",
      "mutated_line": "key_cnt = sum((key_lock in ('a', 'b', '', 'd', 'e', 'f') for key_lock in key_lock_loc))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', '', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))",
      "mutated_line": "key_cnt = sum((key_lock in ('a', 'b', 'c', '', 'e', 'f') for key_lock in key_lock_loc))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', '', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))",
      "mutated_line": "key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', '', 'f') for key_lock in key_lock_loc))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', '', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))",
      "mutated_line": "key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', '') for key_lock in key_lock_loc))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', '') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dque = deque([(i, j, 0)])",
      "mutated_line": "dque = deque([(i, j, 1)])",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 1)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dque = deque([(i, j, 0)])",
      "mutated_line": "dque = deque([(i, j, -1)])",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, -1)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dque = deque([(i, j, 0)])",
      "mutated_line": "dque = deque([(i, j, 1)])",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 1)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if ch != src and ch != '.':",
      "mutated_line": "if ch != src and ch != '':",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i + 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i + 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i * 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i * 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i - 1, j), (i, j - 1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i - 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i * 1, j), (i, j - 1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i * 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j + 1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j + 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j * 1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j * 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j - 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j - 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j * 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j * 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] != '#' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] != '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')",
      "mutated_line": "keys_bitmap2 |= 2 << ord(next_key_lock) - ord('a')",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 2 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')",
      "mutated_line": "keys_bitmap2 |= 0 << ord(next_key_lock) - ord('a')",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 0 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')",
      "mutated_line": "keys_bitmap2 |= 0 << ord(next_key_lock) - ord('a')",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 0 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')",
      "mutated_line": "keys_bitmap2 |= -1 << ord(next_key_lock) - ord('a')",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= -1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')",
      "mutated_line": "keys_bitmap2 |= 1 << ord(next_key_lock) + ord('a')",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) + ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')",
      "mutated_line": "keys_bitmap2 |= 1 << ord(next_key_lock) * ord('a')",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) * ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 2, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 2, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 0, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 0, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 0, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 0, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - -1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - -1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 2, j), (i, j - 1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 2, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 0, j), (i, j - 1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 0, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 0, j), (i, j - 1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 0, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + -1, j), (i, j - 1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + -1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 2), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 2), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 0), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 0), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 0), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 0), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - -1), (i, j + 1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - -1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 2)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 2)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 0)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 0)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 0)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 0)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):",
      "mutated_line": "for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + -1)):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + -1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (0 <= x < m or 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m or 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dque.append((x, y, d + 1))",
      "mutated_line": "dque.append((x, y, d - 1))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d - 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dque.append((x, y, d + 1))",
      "mutated_line": "dque.append((x, y, d * 1))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d * 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):",
      "mutated_line": "if not keys_bitmap | 1 << ord(next_key_lock) - ord('A'):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap | 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))",
      "mutated_line": "heapq.heappush(hq, (d - d2, next_key_lock, keys_bitmap2))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d - d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))",
      "mutated_line": "heapq.heappush(hq, (d * d2, next_key_lock, keys_bitmap2))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d * d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (0 < x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 < x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (0 > x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 > x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (0 == x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 == x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (0 <= x < m and 0 < y < n) or grid[x][y] == '#' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 < y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (0 <= x < m and 0 > y < n) or grid[x][y] == '#' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 > y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (0 <= x < m and 0 == y < n) or grid[x][y] == '#' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 == y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dque.append((x, y, d + 1))",
      "mutated_line": "dque.append((x, y, d + 2))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 2))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dque.append((x, y, d + 1))",
      "mutated_line": "dque.append((x, y, d + 0))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 0))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dque.append((x, y, d + 1))",
      "mutated_line": "dque.append((x, y, d + 0))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 0))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dque.append((x, y, d + 1))",
      "mutated_line": "dque.append((x, y, d + -1))",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + -1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')",
      "mutated_line": "keys_bitmap2 |= 1 << ord(next_key_lock) - ord('')",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (1 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (1 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (-1 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (-1 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (1 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (1 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (0 <= x < m and 1 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 1 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (0 <= x < m and -1 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and -1 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "mutated_line": "if not (0 <= x < m and 1 <= y < n) or grid[x][y] == '#' or seen[x, y]:",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 1 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):",
      "mutated_line": "if not keys_bitmap & 2 << ord(next_key_lock) - ord('A'):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 2 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):",
      "mutated_line": "if not keys_bitmap & 0 << ord(next_key_lock) - ord('A'):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 0 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):",
      "mutated_line": "if not keys_bitmap & 0 << ord(next_key_lock) - ord('A'):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 0 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):",
      "mutated_line": "if not keys_bitmap & -1 << ord(next_key_lock) - ord('A'):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & -1 << ord(next_key_lock) - ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):",
      "mutated_line": "if not keys_bitmap & 1 << ord(next_key_lock) + ord('A'):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) + ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):",
      "mutated_line": "if not keys_bitmap & 1 << ord(next_key_lock) * ord('A'):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) * ord('A'):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if not keys_bitmap & 1 << ord(next_key_lock) - ord('A'):",
      "mutated_line": "if not keys_bitmap & 1 << ord(next_key_lock) - ord(''):",
      "code": "import heapq\nfrom collections import deque, defaultdict\nfrom typing import List\n\ndef shortest_path_all_keys(grid: List[str]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    key_lock_loc = {ch: (i, j) for (i, row) in enumerate(grid) for (j, ch) in enumerate(row) if ch not in {'.', '#'}}\n    key_cnt = sum((key_lock in ('a', 'b', 'c', 'd', 'e', 'f') for key_lock in key_lock_loc))\n\n    def bfs_from(src):\n        (i, j) = key_lock_loc[src]\n        seen = defaultdict(lambda : False)\n        seen[i, j] = True\n        dque = deque([(i, j, 0)])\n        dist = {}\n        while dque:\n            (i, j, d) = dque.popleft()\n            ch = grid[i][j]\n            if ch != src and ch != '.':\n                dist[ch] = d\n                continue\n            for (x, y) in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or seen[x, y]:\n                    continue\n                seen[x, y] = True\n                dque.append((x, y, d + 1))\n        return dist\n    dists = {key_lock: bfs_from(key_lock) for key_lock in key_lock_loc}\n    all_keys_bitmap = 2 ** key_cnt - 1\n    hq = [(0, '@', 0)]\n    final_dist = defaultdict(lambda : float('inf'))\n    final_dist['@', 0] = 0\n    while hq:\n        (d, ch, keys_bitmap) = heapq.heappop(hq)\n        if final_dist[ch, keys_bitmap] < d:\n            continue\n        if keys_bitmap == all_keys_bitmap:\n            return d\n        for (next_key_lock, d2) in list(dists[ch].items()):\n            keys_bitmap2 = keys_bitmap\n            if next_key_lock.islower():\n                keys_bitmap2 |= 1 << ord(next_key_lock) - ord('a')\n            elif next_key_lock.isupper():\n                if not keys_bitmap & 1 << ord(next_key_lock) - ord(''):\n                    continue\n            if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                final_dist[next_key_lock, keys_bitmap2] = d + d2\n                heapq.heappush(hq, (d + d2, next_key_lock, keys_bitmap2))\n    return -1"
    }
  ]
}