{
  "task_id": "taco_5215",
  "entry_point": "minimum_streetlight_cost",
  "mutant_count": 93,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if W == 1 and H == 1:",
      "mutated_line": "if W == 1 or H == 1:",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 or H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 100000",
      "mutated_line": "ans = 100001",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100001\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 100000",
      "mutated_line": "ans = 99999",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 99999\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 100000",
      "mutated_line": "ans = 0",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 0\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 100000",
      "mutated_line": "ans = 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 1\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 100000",
      "mutated_line": "ans = -100000",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = -100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "return self.total < other.total or (self.total == other.total and self.use > other.use)",
      "mutated_line": "return self.total < other.total and (self.total == other.total and self.use > other.use)",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total and (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if W == 1 and H == 1:",
      "mutated_line": "if W != 1 and H == 1:",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W != 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if W == 1 and H == 1:",
      "mutated_line": "if W == 1 and H != 1:",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H != 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 1\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return -1\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 1\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dis = x + y - 2",
      "mutated_line": "dis = x + y + 2",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y + 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dis = x + y - 2",
      "mutated_line": "dis = (x + y) * 2",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = (x + y) * 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return self.total < other.total or (self.total == other.total and self.use > other.use)",
      "mutated_line": "return self.total <= other.total or (self.total == other.total and self.use > other.use)",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total <= other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return self.total < other.total or (self.total == other.total and self.use > other.use)",
      "mutated_line": "return self.total >= other.total or (self.total == other.total and self.use > other.use)",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total >= other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return self.total < other.total or (self.total == other.total and self.use > other.use)",
      "mutated_line": "return self.total != other.total or (self.total == other.total and self.use > other.use)",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total != other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "return self.total < other.total or (self.total == other.total and self.use > other.use)",
      "mutated_line": "return self.total < other.total or (self.total == other.total or self.use > other.use)",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total or self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if W == 1 and H == 1:",
      "mutated_line": "if W == 2 and H == 1:",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 2 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if W == 1 and H == 1:",
      "mutated_line": "if W == 0 and H == 1:",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 0 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if W == 1 and H == 1:",
      "mutated_line": "if W == 0 and H == 1:",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 0 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if W == 1 and H == 1:",
      "mutated_line": "if W == -1 and H == 1:",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == -1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if W == 1 and H == 1:",
      "mutated_line": "if W == 1 and H == 2:",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 2:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if W == 1 and H == 1:",
      "mutated_line": "if W == 1 and H == 0:",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 0:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if W == 1 and H == 1:",
      "mutated_line": "if W == 1 and H == 0:",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 0:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if W == 1 and H == 1:",
      "mutated_line": "if W == 1 and H == -1:",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == -1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dis = x + y - 2",
      "mutated_line": "dis = x - y - 2",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x - y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dis = x + y - 2",
      "mutated_line": "dis = x * y - 2",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x * y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dis = x + y - 2",
      "mutated_line": "dis = x + y - 3",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 3\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dis = x + y - 2",
      "mutated_line": "dis = x + y - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 1\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dis = x + y - 2",
      "mutated_line": "dis = x + y - 0",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 0\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dis = x + y - 2",
      "mutated_line": "dis = x + y - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 1\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dis = x + y - 2",
      "mutated_line": "dis = x + y - -2",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - -2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total - max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total - max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total * max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total * max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) + 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) + 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = (abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1])) * 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = (abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1])) * 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "total = top.total + use",
      "mutated_line": "total = top.total - use",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total - use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "total = top.total + use",
      "mutated_line": "total = top.total * use",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total * use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if mins[i] > new:",
      "mutated_line": "if mins[i] >= new:",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] >= new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if mins[i] > new:",
      "mutated_line": "if mins[i] <= new:",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] <= new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if mins[i] > new:",
      "mutated_line": "if mins[i] != new:",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] != new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return self.total < other.total or (self.total == other.total and self.use > other.use)",
      "mutated_line": "return self.total < other.total or (self.total != other.total and self.use > other.use)",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total != other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return self.total < other.total or (self.total == other.total and self.use > other.use)",
      "mutated_line": "return self.total < other.total or (self.total == other.total and self.use >= other.use)",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use >= other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return self.total < other.total or (self.total == other.total and self.use > other.use)",
      "mutated_line": "return self.total < other.total or (self.total == other.total and self.use <= other.use)",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use <= other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return self.total < other.total or (self.total == other.total and self.use > other.use)",
      "mutated_line": "return self.total < other.total or (self.total == other.total and self.use != other.use)",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use != other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) - abs(lights[top.place][1] - lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) - abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) * abs(lights[top.place][1] - lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) * abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 2",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 2\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 0",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 0\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 0",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 0\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - -1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - -1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "use = max(0, dis - top.use)",
      "mutated_line": "use = max(1, dis - top.use)",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(1, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "use = max(0, dis - top.use)",
      "mutated_line": "use = max(-1, dis - top.use)",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(-1, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "use = max(0, dis - top.use)",
      "mutated_line": "use = max(1, dis - top.use)",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(1, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "use = max(0, dis - top.use)",
      "mutated_line": "use = max(0, dis + top.use)",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis + top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "use = max(0, dis - top.use)",
      "mutated_line": "use = max(0, dis * top.use)",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis * top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(1, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(1, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(-1, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(-1, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(1, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(1, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) + top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) + top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, (abs(W - lights[top.place][0]) + abs(H - lights[top.place][1])) * top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, (abs(W - lights[top.place][0]) + abs(H - lights[top.place][1])) * top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) - abs(H - lights[top.place][1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) - abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) * abs(H - lights[top.place][1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) * abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] + lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] + lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] * lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] * lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] + lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] + lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] * lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] * lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, abs(W + lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W + lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, abs(W * lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W * lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H + lights[top.place][1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H + lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H * lights[top.place][1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H * lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][1] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][1] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][-1] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][-1] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][1] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][1] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][1]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][1]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][-1]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][-1]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][1]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][1]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][2] - lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][2] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][0] - lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][0] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][0] - lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][0] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][-1] - lights[i][1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][-1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][2]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][2]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][0]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][0]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][0]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][0]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1",
      "mutated_line": "dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][-1]) - 1",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][-1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][1]) + abs(H - lights[top.place][1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][1]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][-1]) + abs(H - lights[top.place][1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][-1]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][1]) + abs(H - lights[top.place][1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][1]) + abs(H - lights[top.place][1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][2]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][2]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][0]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][0]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][0]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][0]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][1]) - top.use))",
      "mutated_line": "ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][-1]) - top.use))",
      "code": "import heapq\n\nclass Point:\n\n    def __init__(self, total, use, place):\n        self.total = total\n        self.use = use\n        self.place = place\n\n    def __lt__(self, other):\n        return self.total < other.total or (self.total == other.total and self.use > other.use)\n\ndef minimum_streetlight_cost(W, H, N, lights):\n    if W == 1 and H == 1:\n        return 0\n    que = []\n    mins = []\n    for (i, (x, y)) in enumerate(lights):\n        dis = x + y - 2\n        heapq.heappush(que, Point(dis, dis, i))\n        mins.append(Point(dis, dis, i))\n    ans = 100000\n    while que:\n        top = heapq.heappop(que)\n        ans = min(ans, top.total + max(0, abs(W - lights[top.place][0]) + abs(H - lights[top.place][-1]) - top.use))\n        for i in range(len(lights)):\n            dis = abs(lights[top.place][0] - lights[i][0]) + abs(lights[top.place][1] - lights[i][1]) - 1\n            use = max(0, dis - top.use)\n            total = top.total + use\n            new = Point(total, use, i)\n            if mins[i] > new:\n                mins[i] = new\n                heapq.heappush(que, new)\n    return ans"
    }
  ]
}