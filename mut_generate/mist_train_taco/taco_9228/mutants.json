{
  "task_id": "taco_9228",
  "entry_point": "reverse_and_combine_text",
  "mutant_count": 19,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while len(words) > 1:",
      "mutated_line": "while len(words) >= 1:",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) >= 1:\n        it = map(lambda w: w[::-1], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while len(words) > 1:",
      "mutated_line": "while len(words) <= 1:",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) <= 1:\n        it = map(lambda w: w[::-1], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while len(words) > 1:",
      "mutated_line": "while len(words) != 1:",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) != 1:\n        it = map(lambda w: w[::-1], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "words = text.split(' ')",
      "mutated_line": "words = text.split('')",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split('')\n    while len(words) > 1:\n        it = map(lambda w: w[::-1], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "while len(words) > 1:",
      "mutated_line": "while len(words) > 2:",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > 2:\n        it = map(lambda w: w[::-1], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "while len(words) > 1:",
      "mutated_line": "while len(words) > 0:",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > 0:\n        it = map(lambda w: w[::-1], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "while len(words) > 1:",
      "mutated_line": "while len(words) > 0:",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > 0:\n        it = map(lambda w: w[::-1], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "while len(words) > 1:",
      "mutated_line": "while len(words) > -1:",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > -1:\n        it = map(lambda w: w[::-1], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return words[0]",
      "mutated_line": "return words[1]",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > 1:\n        it = map(lambda w: w[::-1], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return words[0]",
      "mutated_line": "return words[-1]",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > 1:\n        it = map(lambda w: w[::-1], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return words[0]",
      "mutated_line": "return words[1]",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > 1:\n        it = map(lambda w: w[::-1], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[1]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]",
      "mutated_line": "words = [a - b for (a, b) in zip_longest(it, it, fillvalue='')]",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > 1:\n        it = map(lambda w: w[::-1], words)\n        words = [a - b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]",
      "mutated_line": "words = [a * b for (a, b) in zip_longest(it, it, fillvalue='')]",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > 1:\n        it = map(lambda w: w[::-1], words)\n        words = [a * b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "it = map(lambda w: w[::-1], words)",
      "mutated_line": "it = map(lambda w: w[::+1], words)",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > 1:\n        it = map(lambda w: w[::+1], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]",
      "mutated_line": "words = [a + b for (a, b) in zip_longest(it, it, fillvalue='MUTATED')]",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > 1:\n        it = map(lambda w: w[::-1], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='MUTATED')]\n    return words[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "it = map(lambda w: w[::-1], words)",
      "mutated_line": "it = map(lambda w: w[::-2], words)",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > 1:\n        it = map(lambda w: w[::-2], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "it = map(lambda w: w[::-1], words)",
      "mutated_line": "it = map(lambda w: w[::-0], words)",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > 1:\n        it = map(lambda w: w[::-0], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "it = map(lambda w: w[::-1], words)",
      "mutated_line": "it = map(lambda w: w[::-0], words)",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > 1:\n        it = map(lambda w: w[::-0], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "it = map(lambda w: w[::-1], words)",
      "mutated_line": "it = map(lambda w: w[::--1], words)",
      "code": "def reverse_and_combine_text(text: str) -> str:\n    words = text.split(' ')\n    while len(words) > 1:\n        it = map(lambda w: w[::--1], words)\n        words = [a + b for (a, b) in zip_longest(it, it, fillvalue='')]\n    return words[0]"
    }
  ]
}