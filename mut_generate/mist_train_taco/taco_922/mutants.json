{
  "task_id": "taco_922",
  "entry_point": "max_constrained_subset_sum",
  "mutant_count": 32,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if queue and i - queue[0] > k:",
      "mutated_line": "if queue or i - queue[0] > k:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue or i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if queue and dp[queue[0]] > 0:",
      "mutated_line": "if queue or dp[queue[0]] > 0:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue or dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "dp[i] += dp[queue[0]]",
      "mutated_line": "dp[i] -= dp[queue[0]]",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] -= dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "while queue and dp[i] >= dp[queue[-1]]:",
      "mutated_line": "while queue or dp[i] >= dp[queue[-1]]:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue or dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if queue and i - queue[0] > k:",
      "mutated_line": "if queue and i - queue[0] >= k:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] >= k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if queue and i - queue[0] > k:",
      "mutated_line": "if queue and i - queue[0] <= k:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] <= k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if queue and i - queue[0] > k:",
      "mutated_line": "if queue and i - queue[0] != k:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] != k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if queue and dp[queue[0]] > 0:",
      "mutated_line": "if queue and dp[queue[0]] >= 0:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] >= 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if queue and dp[queue[0]] > 0:",
      "mutated_line": "if queue and dp[queue[0]] <= 0:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] <= 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if queue and dp[queue[0]] > 0:",
      "mutated_line": "if queue and dp[queue[0]] != 0:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] != 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while queue and dp[i] >= dp[queue[-1]]:",
      "mutated_line": "while queue and dp[i] > dp[queue[-1]]:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] > dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while queue and dp[i] >= dp[queue[-1]]:",
      "mutated_line": "while queue and dp[i] < dp[queue[-1]]:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] < dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while queue and dp[i] >= dp[queue[-1]]:",
      "mutated_line": "while queue and dp[i] == dp[queue[-1]]:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] == dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if queue and i - queue[0] > k:",
      "mutated_line": "if queue and i + queue[0] > k:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i + queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if queue and i - queue[0] > k:",
      "mutated_line": "if queue and i * queue[0] > k:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i * queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if queue and dp[queue[0]] > 0:",
      "mutated_line": "if queue and dp[queue[0]] > 1:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 1:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if queue and dp[queue[0]] > 0:",
      "mutated_line": "if queue and dp[queue[0]] > -1:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > -1:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if queue and dp[queue[0]] > 0:",
      "mutated_line": "if queue and dp[queue[0]] > 1:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 1:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i] += dp[queue[0]]",
      "mutated_line": "dp[i] += dp[queue[1]]",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[1]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i] += dp[queue[0]]",
      "mutated_line": "dp[i] += dp[queue[-1]]",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[-1]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i] += dp[queue[0]]",
      "mutated_line": "dp[i] += dp[queue[1]]",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[1]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if queue and i - queue[0] > k:",
      "mutated_line": "if queue and i - queue[1] > k:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[1] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if queue and i - queue[0] > k:",
      "mutated_line": "if queue and i - queue[-1] > k:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[-1] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if queue and i - queue[0] > k:",
      "mutated_line": "if queue and i - queue[1] > k:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[1] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if queue and dp[queue[0]] > 0:",
      "mutated_line": "if queue and dp[queue[1]] > 0:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[1]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if queue and dp[queue[0]] > 0:",
      "mutated_line": "if queue and dp[queue[-1]] > 0:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[-1]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if queue and dp[queue[0]] > 0:",
      "mutated_line": "if queue and dp[queue[1]] > 0:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[1]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "while queue and dp[i] >= dp[queue[-1]]:",
      "mutated_line": "while queue and dp[i] >= dp[queue[+1]]:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[+1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while queue and dp[i] >= dp[queue[-1]]:",
      "mutated_line": "while queue and dp[i] >= dp[queue[-2]]:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-2]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while queue and dp[i] >= dp[queue[-1]]:",
      "mutated_line": "while queue and dp[i] >= dp[queue[-0]]:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-0]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while queue and dp[i] >= dp[queue[-1]]:",
      "mutated_line": "while queue and dp[i] >= dp[queue[-0]]:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[-0]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while queue and dp[i] >= dp[queue[-1]]:",
      "mutated_line": "while queue and dp[i] >= dp[queue[--1]]:",
      "code": "from collections import deque\n\ndef max_constrained_subset_sum(nums, k):\n    N = len(nums)\n    queue = deque()\n    dp = [val for val in nums]\n    for (i, val) in enumerate(nums):\n        if queue and i - queue[0] > k:\n            queue.popleft()\n        if queue and dp[queue[0]] > 0:\n            dp[i] += dp[queue[0]]\n        while queue and dp[i] >= dp[queue[--1]]:\n            queue.pop()\n        queue.append(i)\n    return max(dp)"
    }
  ]
}