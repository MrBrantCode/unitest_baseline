{
  "task_id": "taco_10695",
  "entry_point": "count_leaper_moves",
  "mutant_count": 98,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 - 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 * 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 * 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 + 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 8\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 6\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 0\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 1\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + -7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if 'L' in board[r]:",
      "mutated_line": "if 'L' not in board[r]:",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' not in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for moveNum in range(m + 1):",
      "mutated_line": "for moveNum in range(m - 1):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m - 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for moveNum in range(m + 1):",
      "mutated_line": "for moveNum in range(m * 1):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m * 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if moveNum == 0:",
      "mutated_line": "if moveNum != 0:",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum != 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 11 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 9 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 0 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 1 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = -10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 10 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 8 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 0 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 1 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** -9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if 'L' in board[r]:",
      "mutated_line": "if '' in board[r]:",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if '' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for moveNum in range(m + 1):",
      "mutated_line": "for moveNum in range(m + 2):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 2):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for moveNum in range(m + 1):",
      "mutated_line": "for moveNum in range(m + 0):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 0):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for moveNum in range(m + 1):",
      "mutated_line": "for moveNum in range(m + 0):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 0):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for moveNum in range(m + 1):",
      "mutated_line": "for moveNum in range(m + -1):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + -1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if moveNum == 0:",
      "mutated_line": "if moveNum == 1:",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 1:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if moveNum == 0:",
      "mutated_line": "if moveNum == -1:",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == -1:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if moveNum == 0:",
      "mutated_line": "if moveNum == 1:",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 1:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "locationC = board[r].index('L')",
      "mutated_line": "locationC = board[r].index('')",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "return ways[-1][locationR][locationC]",
      "mutated_line": "return ways[+1][locationR][locationC]",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[+1][locationR][locationC]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if board[i][j] != 'P':",
      "mutated_line": "if board[i][j] == 'P':",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if board[i][j] == 'P':",
      "mutated_line": "if board[i][j] != 'P':",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 1\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "total = 0",
      "mutated_line": "total = -1",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = -1\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 1\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return ways[-1][locationR][locationC]",
      "mutated_line": "return ways[-2][locationR][locationC]",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-2][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return ways[-1][locationR][locationC]",
      "mutated_line": "return ways[-0][locationR][locationC]",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-0][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return ways[-1][locationR][locationC]",
      "mutated_line": "return ways[-0][locationR][locationC]",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-0][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return ways[-1][locationR][locationC]",
      "mutated_line": "return ways[--1][locationR][locationC]",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[--1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if board[i][j] != 'P':",
      "mutated_line": "if board[i][j] != '':",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != '':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if board[i][j] == 'P':",
      "mutated_line": "if board[i][j] == '':",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == '':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "row.append(1)",
      "mutated_line": "row.append(2)",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(2)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "row.append(1)",
      "mutated_line": "row.append(0)",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(0)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "row.append(1)",
      "mutated_line": "row.append(0)",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(0)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "row.append(1)",
      "mutated_line": "row.append(-1)",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(-1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "row.append(0)",
      "mutated_line": "row.append(1)",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(1)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "row.append(0)",
      "mutated_line": "row.append(-1)",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(-1)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "row.append(0)",
      "mutated_line": "row.append(1)",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(1)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "row.append(0)",
      "mutated_line": "row.append(1)",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(1)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "row.append(0)",
      "mutated_line": "row.append(-1)",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(-1)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "row.append(0)",
      "mutated_line": "row.append(1)",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(1)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for r in range(max(0, i - s), min(n, i + s + 1)):",
      "mutated_line": "for r in range(max(1, i - s), min(n, i + s + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(1, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for r in range(max(0, i - s), min(n, i + s + 1)):",
      "mutated_line": "for r in range(max(-1, i - s), min(n, i + s + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(-1, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for r in range(max(0, i - s), min(n, i + s + 1)):",
      "mutated_line": "for r in range(max(1, i - s), min(n, i + s + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(1, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for r in range(max(0, i - s), min(n, i + s + 1)):",
      "mutated_line": "for r in range(max(0, i + s), min(n, i + s + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i + s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for r in range(max(0, i - s), min(n, i + s + 1)):",
      "mutated_line": "for r in range(max(0, i * s), min(n, i + s + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i * s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for r in range(max(0, i - s), min(n, i + s + 1)):",
      "mutated_line": "for r in range(max(0, i - s), min(n, i + s - 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s - 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for r in range(max(0, i - s), min(n, i + s + 1)):",
      "mutated_line": "for r in range(max(0, i - s), min(n, (i + s) * 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, (i + s) * 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total = (total + ways[moveNum - 1][r][c]) % MOD",
      "mutated_line": "total = (total + ways[moveNum - 1][r][c]) * MOD",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) * MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total = (total + ways[moveNum - 1][r][c]) % MOD",
      "mutated_line": "total = total + ways[moveNum - 1][r][c] + MOD",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = total + ways[moveNum - 1][r][c] + MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for r in range(max(0, i - s), min(n, i + s + 1)):",
      "mutated_line": "for r in range(max(0, i - s), min(n, i - s + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i - s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for r in range(max(0, i - s), min(n, i + s + 1)):",
      "mutated_line": "for r in range(max(0, i - s), min(n, i * s + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i * s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for r in range(max(0, i - s), min(n, i + s + 1)):",
      "mutated_line": "for r in range(max(0, i - s), min(n, i + s + 2)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 2)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for r in range(max(0, i - s), min(n, i + s + 1)):",
      "mutated_line": "for r in range(max(0, i - s), min(n, i + s + 0)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 0)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for r in range(max(0, i - s), min(n, i + s + 1)):",
      "mutated_line": "for r in range(max(0, i - s), min(n, i + s + 0)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 0)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for r in range(max(0, i - s), min(n, i + s + 1)):",
      "mutated_line": "for r in range(max(0, i - s), min(n, i + s + -1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + -1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(1, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(1, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(-1, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(-1, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(1, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(1, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s - abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s - abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, (j - s) * abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, (j - s) * abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) - 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) - 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s + abs(r - i)), min(n, (j + s - abs(r - i)) * 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, (j + s - abs(r - i)) * 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total = (total + ways[moveNum - 1][r][c]) % MOD",
      "mutated_line": "total = (total - ways[moveNum - 1][r][c]) % MOD",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total - ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total = (total + ways[moveNum - 1][r][c]) % MOD",
      "mutated_line": "total = total * ways[moveNum - 1][r][c] % MOD",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = total * ways[moveNum - 1][r][c] % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j + s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j + s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j * s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j * s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s + abs(r - i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s + abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s + abs(r - i)), min(n, (j + s) * abs(r - i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, (j + s) * abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 2)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 2)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 0)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 0)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 0)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 0)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + -1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + -1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s + abs(r + i)), min(n, j + s - abs(r - i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r + i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s + abs(r * i)), min(n, j + s - abs(r - i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r * i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j - s - abs(r - i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j - s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j * s - abs(r - i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j * s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r + i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r + i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):",
      "mutated_line": "for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r * i) + 1)):",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r * i) + 1)):\n                            total = (total + ways[moveNum - 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total = (total + ways[moveNum - 1][r][c]) % MOD",
      "mutated_line": "total = (total + ways[moveNum + 1][r][c]) % MOD",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum + 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total = (total + ways[moveNum - 1][r][c]) % MOD",
      "mutated_line": "total = (total + ways[moveNum * 1][r][c]) % MOD",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum * 1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "total = (total + ways[moveNum - 1][r][c]) % MOD",
      "mutated_line": "total = (total + ways[moveNum - 2][r][c]) % MOD",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 2][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "total = (total + ways[moveNum - 1][r][c]) % MOD",
      "mutated_line": "total = (total + ways[moveNum - 0][r][c]) % MOD",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 0][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "total = (total + ways[moveNum - 1][r][c]) % MOD",
      "mutated_line": "total = (total + ways[moveNum - 0][r][c]) % MOD",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - 0][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "total = (total + ways[moveNum - 1][r][c]) % MOD",
      "mutated_line": "total = (total + ways[moveNum - -1][r][c]) % MOD",
      "code": "def count_leaper_moves(n, m, s, board):\n    MOD = 10 ** 9 + 7\n    (locationR, locationC) = (None, None)\n    for r in range(n):\n        if 'L' in board[r]:\n            locationR = r\n            locationC = board[r].index('L')\n            break\n    ways = []\n    for moveNum in range(m + 1):\n        tboard = []\n        if moveNum == 0:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] != 'P':\n                        row.append(1)\n                    else:\n                        row.append(0)\n                tboard.append(row)\n        else:\n            for i in range(n):\n                row = []\n                for j in range(n):\n                    if board[i][j] == 'P':\n                        row.append(0)\n                        continue\n                    total = 0\n                    for r in range(max(0, i - s), min(n, i + s + 1)):\n                        for c in range(max(0, j - s + abs(r - i)), min(n, j + s - abs(r - i) + 1)):\n                            total = (total + ways[moveNum - -1][r][c]) % MOD\n                    row.append(total)\n                tboard.append(row)\n        ways.append(tboard)\n    return ways[-1][locationR][locationC]"
    }
  ]
}