{
  "task_id": "taco_17144",
  "entry_point": "minimum_rotations_to_unlock",
  "mutant_count": 48,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if initial_sequence == unlocking_sequence:",
      "mutated_line": "if initial_sequence != unlocking_sequence:",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence != unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rotations = 0",
      "mutated_line": "rotations = 1",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 1\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rotations = 0",
      "mutated_line": "rotations = -1",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = -1\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rotations = 0",
      "mutated_line": "rotations = 1",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 1\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while False:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "rotations += 1",
      "mutated_line": "rotations -= 1",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations -= 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 1\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return -1\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 1\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "rotations += 1",
      "mutated_line": "rotations += 2",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 2\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "rotations += 1",
      "mutated_line": "rotations += 0",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 0\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "rotations += 1",
      "mutated_line": "rotations += 0",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 0\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "rotations += 1",
      "mutated_line": "rotations += -1",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += -1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for j in range(i + 1, k + 1):",
      "mutated_line": "for j in range(i - 1, k + 1):",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i - 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for j in range(i + 1, k + 1):",
      "mutated_line": "for j in range(i * 1, k + 1):",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i * 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for j in range(i + 1, k + 1):",
      "mutated_line": "for j in range(i + 1, k - 1):",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k - 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for j in range(i + 1, k + 1):",
      "mutated_line": "for j in range(i + 1, k * 1):",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k * 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "diff = (unlocking_sequence[i] - current_state[i]) % 10",
      "mutated_line": "diff = (unlocking_sequence[i] - current_state[i]) * 10",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) * 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "diff = (unlocking_sequence[i] - current_state[i]) % 10",
      "mutated_line": "diff = unlocking_sequence[i] - current_state[i] + 10",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = unlocking_sequence[i] - current_state[i] + 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if new_state == unlocking_sequence:",
      "mutated_line": "if new_state != unlocking_sequence:",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state != unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if tuple(new_state) not in visited_states:",
      "mutated_line": "if tuple(new_state) in visited_states:",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(i + 1, k + 1):",
      "mutated_line": "for j in range(i + 2, k + 1):",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 2, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(i + 1, k + 1):",
      "mutated_line": "for j in range(i + 0, k + 1):",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 0, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(i + 1, k + 1):",
      "mutated_line": "for j in range(i + 0, k + 1):",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 0, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(i + 1, k + 1):",
      "mutated_line": "for j in range(i + -1, k + 1):",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + -1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(i + 1, k + 1):",
      "mutated_line": "for j in range(i + 1, k + 2):",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 2):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(i + 1, k + 1):",
      "mutated_line": "for j in range(i + 1, k + 0):",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 0):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(i + 1, k + 1):",
      "mutated_line": "for j in range(i + 1, k + 0):",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 0):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(i + 1, k + 1):",
      "mutated_line": "for j in range(i + 1, k + -1):",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + -1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "diff = (unlocking_sequence[i] - current_state[i]) % 10",
      "mutated_line": "diff = (unlocking_sequence[i] + current_state[i]) % 10",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] + current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "diff = (unlocking_sequence[i] - current_state[i]) % 10",
      "mutated_line": "diff = unlocking_sequence[i] * current_state[i] % 10",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = unlocking_sequence[i] * current_state[i] % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "diff = (unlocking_sequence[i] - current_state[i]) % 10",
      "mutated_line": "diff = (unlocking_sequence[i] - current_state[i]) % 11",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 11\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "diff = (unlocking_sequence[i] - current_state[i]) % 10",
      "mutated_line": "diff = (unlocking_sequence[i] - current_state[i]) % 9",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 9\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "diff = (unlocking_sequence[i] - current_state[i]) % 10",
      "mutated_line": "diff = (unlocking_sequence[i] - current_state[i]) % 0",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 0\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "diff = (unlocking_sequence[i] - current_state[i]) % 10",
      "mutated_line": "diff = (unlocking_sequence[i] - current_state[i]) % 1",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 1\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "diff = (unlocking_sequence[i] - current_state[i]) % 10",
      "mutated_line": "diff = (unlocking_sequence[i] - current_state[i]) % -10",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % -10\n                    new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "mutated_line": "new_state = [(current_state[idx] + diff) % 10 if i < idx < j else current_state[idx] for idx in range(k)]",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i < idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "mutated_line": "new_state = [(current_state[idx] + diff) % 10 if i > idx < j else current_state[idx] for idx in range(k)]",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i > idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "mutated_line": "new_state = [(current_state[idx] + diff) % 10 if i == idx < j else current_state[idx] for idx in range(k)]",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 10 if i == idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "mutated_line": "new_state = [(current_state[idx] + diff) * 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) * 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "mutated_line": "new_state = [current_state[idx] + diff + 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [current_state[idx] + diff + 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "mutated_line": "new_state = [(current_state[idx] - diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] - diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "mutated_line": "new_state = [current_state[idx] * diff % 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [current_state[idx] * diff % 10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "mutated_line": "new_state = [(current_state[idx] + diff) % 11 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 11 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "mutated_line": "new_state = [(current_state[idx] + diff) % 9 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 9 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "mutated_line": "new_state = [(current_state[idx] + diff) % 0 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 0 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "mutated_line": "new_state = [(current_state[idx] + diff) % 1 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % 1 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "new_state = [(current_state[idx] + diff) % 10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "mutated_line": "new_state = [(current_state[idx] + diff) % -10 if i <= idx < j else current_state[idx] for idx in range(k)]",
      "code": "def minimum_rotations_to_unlock(k, initial_sequence, unlocking_sequence):\n    if initial_sequence == unlocking_sequence:\n        return 0\n    initial_sequence = [int(c) for c in initial_sequence]\n    unlocking_sequence = [int(c) for c in unlocking_sequence]\n    current_states = [initial_sequence]\n    visited_states = set()\n    visited_states.add(tuple(initial_sequence))\n    rotations = 0\n    while True:\n        rotations += 1\n        next_states = []\n        for current_state in current_states:\n            for i in range(k):\n                for j in range(i + 1, k + 1):\n                    diff = (unlocking_sequence[i] - current_state[i]) % 10\n                    new_state = [(current_state[idx] + diff) % -10 if i <= idx < j else current_state[idx] for idx in range(k)]\n                    if new_state == unlocking_sequence:\n                        return rotations\n                    if tuple(new_state) not in visited_states:\n                        visited_states.add(tuple(new_state))\n                        next_states.append(new_state)\n        current_states = next_states"
    }
  ]
}