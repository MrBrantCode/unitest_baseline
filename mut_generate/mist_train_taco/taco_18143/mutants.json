{
  "task_id": "taco_18143",
  "entry_point": "calculate_minimum_wet_time",
  "mutant_count": 52,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "S -= 1",
      "mutated_line": "S += 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S += 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "G -= 1",
      "mutated_line": "G += 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G += 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S -= 1",
      "mutated_line": "S -= 2",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 2\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S -= 1",
      "mutated_line": "S -= 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 0\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S -= 1",
      "mutated_line": "S -= 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 0\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S -= 1",
      "mutated_line": "S -= -1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= -1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G -= 1",
      "mutated_line": "G -= 2",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 2\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G -= 1",
      "mutated_line": "G -= 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 0\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G -= 1",
      "mutated_line": "G -= 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 0\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G -= 1",
      "mutated_line": "G -= -1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= -1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "u -= 1",
      "mutated_line": "u += 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u += 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "v -= 1",
      "mutated_line": "v += 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v += 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "score[(S, 0)] = 0",
      "mutated_line": "score[S, 0] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 1\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "score[(S, 0)] = 0",
      "mutated_line": "score[S, 0] = -1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = -1\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "score[(S, 0)] = 0",
      "mutated_line": "score[S, 0] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 1\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "u -= 1",
      "mutated_line": "u -= 2",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 2\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 0\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 0\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "u -= 1",
      "mutated_line": "u -= -1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= -1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v -= 1",
      "mutated_line": "v -= 2",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 2\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 0\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 0\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v -= 1",
      "mutated_line": "v -= -1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= -1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if node == G:",
      "mutated_line": "if node != G:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node != G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "score[(S, 0)] = 0",
      "mutated_line": "score[S, 1] = 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 1] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "score[(S, 0)] = 0",
      "mutated_line": "score[S, -1] = 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, -1] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "score[(S, 0)] = 0",
      "mutated_line": "score[S, 1] = 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 1] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heappush(que, (0, 0, S))",
      "mutated_line": "heappush(que, (1, 0, S))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (1, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heappush(que, (0, 0, S))",
      "mutated_line": "heappush(que, (-1, 0, S))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (-1, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heappush(que, (0, 0, S))",
      "mutated_line": "heappush(que, (1, 0, S))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (1, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heappush(que, (0, 0, S))",
      "mutated_line": "heappush(que, (0, 1, S))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 1, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heappush(que, (0, 0, S))",
      "mutated_line": "heappush(que, (0, -1, S))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, -1, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heappush(que, (0, 0, S))",
      "mutated_line": "heappush(que, (0, 1, S))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 1, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if start < time:",
      "mutated_line": "if start <= time:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start <= time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if start < time:",
      "mutated_line": "if start >= time:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start >= time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if start < time:",
      "mutated_line": "if start != time:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start != time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "new_total = total + (start - time)",
      "mutated_line": "new_total = total - (start - time)",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total - (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "new_total = total + (start - time)",
      "mutated_line": "new_total = total * (start - time)",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total * (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if (to, end) not in score or score[to, end] > new_total:",
      "mutated_line": "if (to, end) not in score and score[to, end] > new_total:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score and score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[u].append((t, t + c, v))",
      "mutated_line": "edges[u].append((t, t - c, v))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t - c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[u].append((t, t + c, v))",
      "mutated_line": "edges[u].append((t, t * c, v))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t * c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "new_total = total + (start - time)",
      "mutated_line": "new_total = total + (start + time)",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start + time)\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "new_total = total + (start - time)",
      "mutated_line": "new_total = total + start * time",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + start * time\n            if (to, end) not in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if (to, end) not in score or score[to, end] > new_total:",
      "mutated_line": "if (to, end) in score or score[to, end] > new_total:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) in score or score[to, end] > new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if (to, end) not in score or score[to, end] > new_total:",
      "mutated_line": "if (to, end) not in score or score[to, end] >= new_total:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] >= new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if (to, end) not in score or score[to, end] > new_total:",
      "mutated_line": "if (to, end) not in score or score[to, end] <= new_total:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] <= new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if (to, end) not in score or score[to, end] > new_total:",
      "mutated_line": "if (to, end) not in score or score[to, end] != new_total:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_wet_time(N, M, S, G, routes):\n    S -= 1\n    G -= 1\n    edges = [[] for _ in range(N)]\n    for (u, v, t, c) in routes:\n        u -= 1\n        v -= 1\n        edges[u].append((t, t + c, v))\n    score = {}\n    score[S, 0] = 0\n    que = []\n    heappush(que, (0, 0, S))\n    while que:\n        (total, time, node) = heappop(que)\n        if node == G:\n            return total\n        for (start, end, to) in edges[node]:\n            if start < time:\n                continue\n            new_total = total + (start - time)\n            if (to, end) not in score or score[to, end] != new_total:\n                score[to, end] = new_total\n                heappush(que, (new_total, end, to))\n    return -1"
    }
  ]
}