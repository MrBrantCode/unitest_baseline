{
  "task_id": "taco_11265",
  "entry_point": "maximize_spectator_influence",
  "mutant_count": 99,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "s_Y = [0] * Y",
      "mutated_line": "s_Y = [0] / Y",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] / Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "s_Y = [0] * Y",
      "mutated_line": "s_Y = [0] + Y",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] + Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "s_Y = [0] * Y",
      "mutated_line": "s_Y = [0] ** Y",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] ** Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 1\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = -1\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 1\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "s += f['10'][i]",
      "mutated_line": "s -= f['10'][i]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s -= f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "s_Z = [0] * Z",
      "mutated_line": "s_Z = [0] / Z",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] / Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "s_Z = [0] * Z",
      "mutated_line": "s_Z = [0] + Z",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] + Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "s_Z = [0] * Z",
      "mutated_line": "s_Z = [0] ** Z",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] ** Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 1\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = -1\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 1\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "s += f['01'][i]",
      "mutated_line": "s -= f['01'][i]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s -= f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 1\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = -1\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 1\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 1\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = -1\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 1\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for W in range(X + 1):",
      "mutated_line": "for W in range(X - 1):",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X - 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for W in range(X + 1):",
      "mutated_line": "for W in range(X * 1):",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X * 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if W > len(f['00']):",
      "mutated_line": "if W >= len(f['00']):",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W >= len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if W > len(f['00']):",
      "mutated_line": "if W <= len(f['00']):",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W <= len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if W > len(f['00']):",
      "mutated_line": "if W != len(f['00']):",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W != len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if W >= 1:",
      "mutated_line": "if W > 1:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W > 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if W >= 1:",
      "mutated_line": "if W < 1:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W < 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if W >= 1:",
      "mutated_line": "if W == 1:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W == 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "s += f['00'][W - 1]",
      "mutated_line": "s -= f['00'][W - 1]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s -= f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "bound = X - W",
      "mutated_line": "bound = X + W",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X + W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "bound = X - W",
      "mutated_line": "bound = X * W",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X * W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if Y > Z:",
      "mutated_line": "if Y >= Z:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y >= Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if Y > Z:",
      "mutated_line": "if Y <= Z:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y <= Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if Y > Z:",
      "mutated_line": "if Y != Z:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y != Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "calculate = s_X + s",
      "mutated_line": "calculate = s_X - s",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X - s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "calculate = s_X + s",
      "mutated_line": "calculate = s_X * s",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X * s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if tmp_Y > 0:",
      "mutated_line": "if tmp_Y >= 0:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y >= 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if tmp_Y > 0:",
      "mutated_line": "if tmp_Y <= 0:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y <= 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if tmp_Y > 0:",
      "mutated_line": "if tmp_Y != 0:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y != 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "calculate += s_Y[tmp_Y - 1]",
      "mutated_line": "calculate -= s_Y[tmp_Y - 1]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate -= s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if tmp_Z > 0:",
      "mutated_line": "if tmp_Z >= 0:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z >= 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if tmp_Z > 0:",
      "mutated_line": "if tmp_Z <= 0:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z <= 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if tmp_Z > 0:",
      "mutated_line": "if tmp_Z != 0:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z != 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 55,
      "original_line": "calculate += s_Z[tmp_Z - 1]",
      "mutated_line": "calculate -= s_Z[tmp_Z - 1]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate -= s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "s_X = sum(f['11'])",
      "mutated_line": "s_X = sum(f[''])",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f[''])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "X = len(f['11'])",
      "mutated_line": "X = len(f[''])",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f[''])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "Y = len(f['10'])",
      "mutated_line": "Y = len(f[''])",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f[''])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "Z = len(f['01'])",
      "mutated_line": "Z = len(f[''])",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f[''])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "s_Y = [0] * Y",
      "mutated_line": "s_Y = [1] * Y",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [1] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "s_Y = [0] * Y",
      "mutated_line": "s_Y = [-1] * Y",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [-1] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "s_Y = [0] * Y",
      "mutated_line": "s_Y = [1] * Y",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [1] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s_Z = [0] * Z",
      "mutated_line": "s_Z = [1] * Z",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [1] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s_Z = [0] * Z",
      "mutated_line": "s_Z = [-1] * Z",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [-1] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s_Z = [0] * Z",
      "mutated_line": "s_Z = [1] * Z",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [1] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for W in range(X + 1):",
      "mutated_line": "for W in range(X + 2):",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 2):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for W in range(X + 1):",
      "mutated_line": "for W in range(X + 0):",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 0):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for W in range(X + 1):",
      "mutated_line": "for W in range(X + 0):",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 0):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for W in range(X + 1):",
      "mutated_line": "for W in range(X + -1):",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + -1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if W >= 1:",
      "mutated_line": "if W >= 2:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 2:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if W >= 1:",
      "mutated_line": "if W >= 0:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 0:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if W >= 1:",
      "mutated_line": "if W >= 0:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 0:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if W >= 1:",
      "mutated_line": "if W >= -1:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= -1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif Y == Z:",
      "mutated_line": "elif Y != Z:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y != Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if tmp_Y > 0:",
      "mutated_line": "if tmp_Y > 1:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 1:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if tmp_Y > 0:",
      "mutated_line": "if tmp_Y > -1:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > -1:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if tmp_Y > 0:",
      "mutated_line": "if tmp_Y > 1:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 1:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if tmp_Z > 0:",
      "mutated_line": "if tmp_Z > 1:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 1:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if tmp_Z > 0:",
      "mutated_line": "if tmp_Z > -1:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > -1:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if tmp_Z > 0:",
      "mutated_line": "if tmp_Z > 1:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 1:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f[key].sort(reverse=True)",
      "mutated_line": "f[key].sort(reverse=False)",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=False)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "s += f['10'][i]",
      "mutated_line": "s += f[''][i]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f[''][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "s += f['01'][i]",
      "mutated_line": "s += f[''][i]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f[''][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "s += f['00'][W - 1]",
      "mutated_line": "s += f['00'][W + 1]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W + 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "s += f['00'][W - 1]",
      "mutated_line": "s += f['00'][W * 1]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W * 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "tmp_Y = min(Y, Z + bound)",
      "mutated_line": "tmp_Y = min(Y, Z - bound)",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z - bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "tmp_Y = min(Y, Z + bound)",
      "mutated_line": "tmp_Y = min(Y, Z * bound)",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z * bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "elif Y < Z:",
      "mutated_line": "elif Y <= Z:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y <= Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "elif Y < Z:",
      "mutated_line": "elif Y >= Z:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y >= Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "elif Y < Z:",
      "mutated_line": "elif Y != Z:",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y != Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "calculate += s_Y[tmp_Y - 1]",
      "mutated_line": "calculate += s_Y[tmp_Y + 1]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y + 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "calculate += s_Y[tmp_Y - 1]",
      "mutated_line": "calculate += s_Y[tmp_Y * 1]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y * 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "calculate += s_Z[tmp_Z - 1]",
      "mutated_line": "calculate += s_Z[tmp_Z + 1]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z + 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "calculate += s_Z[tmp_Z - 1]",
      "mutated_line": "calculate += s_Z[tmp_Z * 1]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z * 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if W > len(f['00']):",
      "mutated_line": "if W > len(f['']):",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s += f['00'][W - 1]",
      "mutated_line": "s += f[''][W - 1]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f[''][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s += f['00'][W - 1]",
      "mutated_line": "s += f['00'][W - 2]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 2]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s += f['00'][W - 1]",
      "mutated_line": "s += f['00'][W - 0]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 0]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s += f['00'][W - 1]",
      "mutated_line": "s += f['00'][W - 0]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 0]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s += f['00'][W - 1]",
      "mutated_line": "s += f['00'][W - -1]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - -1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "calculate += s_Y[tmp_Y - 1]",
      "mutated_line": "calculate += s_Y[tmp_Y - 2]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 2]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "calculate += s_Y[tmp_Y - 1]",
      "mutated_line": "calculate += s_Y[tmp_Y - 0]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 0]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "calculate += s_Y[tmp_Y - 1]",
      "mutated_line": "calculate += s_Y[tmp_Y - 0]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 0]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "calculate += s_Y[tmp_Y - 1]",
      "mutated_line": "calculate += s_Y[tmp_Y - -1]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - -1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "calculate += s_Z[tmp_Z - 1]",
      "mutated_line": "calculate += s_Z[tmp_Z - 2]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 2]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "calculate += s_Z[tmp_Z - 1]",
      "mutated_line": "calculate += s_Z[tmp_Z - 0]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 0]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "calculate += s_Z[tmp_Z - 1]",
      "mutated_line": "calculate += s_Z[tmp_Z - 0]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 0]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "calculate += s_Z[tmp_Z - 1]",
      "mutated_line": "calculate += s_Z[tmp_Z - -1]",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y + bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - -1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "tmp_Z = min(Z, Y + bound)",
      "mutated_line": "tmp_Z = min(Z, Y - bound)",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y - bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "tmp_Z = min(Z, Y + bound)",
      "mutated_line": "tmp_Z = min(Z, Y * bound)",
      "code": "def maximize_spectator_influence(n, spectators):\n    from collections import defaultdict\n    import heapq\n    f = defaultdict(list)\n    for (s_i, a_i) in spectators:\n        f[s_i].append(a_i)\n    for key in f:\n        f[key].sort(reverse=True)\n    s_X = sum(f['11'])\n    X = len(f['11'])\n    Y = len(f['10'])\n    Z = len(f['01'])\n    s_Y = [0] * Y\n    s = 0\n    for i in range(Y):\n        s += f['10'][i]\n        s_Y[i] = s\n    s_Z = [0] * Z\n    s = 0\n    for i in range(Z):\n        s += f['01'][i]\n        s_Z[i] = s\n    res = 0\n    s = 0\n    for W in range(X + 1):\n        if W > len(f['00']):\n            break\n        if W >= 1:\n            s += f['00'][W - 1]\n        bound = X - W\n        if Y > Z:\n            tmp_Y = min(Y, Z + bound)\n            tmp_Z = Z\n        elif Y == Z:\n            tmp_Y = Y\n            tmp_Z = Z\n        elif Y < Z:\n            tmp_Y = Y\n            tmp_Z = min(Z, Y * bound)\n        calculate = s_X + s\n        if tmp_Y > 0:\n            calculate += s_Y[tmp_Y - 1]\n        if tmp_Z > 0:\n            calculate += s_Z[tmp_Z - 1]\n        res = max(res, calculate)\n    return res"
    }
  ]
}