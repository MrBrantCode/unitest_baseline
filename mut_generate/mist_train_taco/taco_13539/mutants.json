{
  "task_id": "taco_13539",
  "entry_point": "minimum_moves_to_lexicographically_smallest_string",
  "mutant_count": 52,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ind = 0",
      "mutated_line": "ind = 1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 1\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ind = 0",
      "mutated_line": "ind = -1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = -1\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ind = 0",
      "mutated_line": "ind = 1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 1\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while S[ind] == x:",
      "mutated_line": "while S[ind] != x:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] != x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "ind += 1",
      "mutated_line": "ind -= 1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind -= 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(S) == 0:",
      "mutated_line": "if len(S) != 0:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) != 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prev = 0",
      "mutated_line": "prev = 1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 1\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prev = 0",
      "mutated_line": "prev = -1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = -1\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prev = 0",
      "mutated_line": "prev = 1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 1\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if S not in cost:",
      "mutated_line": "if S in cost:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x = S[0]",
      "mutated_line": "x = S[1]",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[1]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x = S[0]",
      "mutated_line": "x = S[-1]",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[-1]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "x = S[0]",
      "mutated_line": "x = S[1]",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[1]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ind += 1",
      "mutated_line": "ind += 2",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 2\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ind += 1",
      "mutated_line": "ind += 0",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 0\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ind += 1",
      "mutated_line": "ind += 0",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 0\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ind += 1",
      "mutated_line": "ind += -1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += -1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if ind >= len(S):",
      "mutated_line": "if ind > len(S):",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind > len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if ind >= len(S):",
      "mutated_line": "if ind < len(S):",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind < len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if ind >= len(S):",
      "mutated_line": "if ind == len(S):",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind == len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(S) == 0:",
      "mutated_line": "if len(S) == 1:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 1:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(S) == 0:",
      "mutated_line": "if len(S) == -1:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == -1:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(S) == 0:",
      "mutated_line": "if len(S) == 1:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 1:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 1\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return -1\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 1\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if c != prev:",
      "mutated_line": "if c == prev:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c == prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while S[0] == cs:",
      "mutated_line": "while S[0] != cs:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] != cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cutted_id = 0",
      "mutated_line": "cutted_id = 1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 1\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cutted_id = 0",
      "mutated_line": "cutted_id = -1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = -1\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cutted_id = 0",
      "mutated_line": "cutted_id = 1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 1\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if len(S) == 0:",
      "mutated_line": "if len(S) != 0:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) != 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if test_c == cs:",
      "mutated_line": "if test_c != cs:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c != cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "cutted_id += 1",
      "mutated_line": "cutted_id -= 1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id -= 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "mini = float('inf')",
      "mutated_line": "mini = float('')",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while S[0] == cs:",
      "mutated_line": "while S[1] == cs:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[1] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while S[0] == cs:",
      "mutated_line": "while S[-1] == cs:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[-1] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while S[0] == cs:",
      "mutated_line": "while S[1] == cs:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[1] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if len(S) == 0:",
      "mutated_line": "if len(S) == 1:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 1:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if len(S) == 0:",
      "mutated_line": "if len(S) == -1:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == -1:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if len(S) == 0:",
      "mutated_line": "if len(S) == 1:",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 1:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 1\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return -1\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 1\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cutted_id += 1",
      "mutated_line": "cutted_id += 2",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 2\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cutted_id += 1",
      "mutated_line": "cutted_id += 0",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 0\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cutted_id += 1",
      "mutated_line": "cutted_id += 0",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 0\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cutted_id += 1",
      "mutated_line": "cutted_id += -1",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += -1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))",
      "mutated_line": "mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) - len(ind_c))",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) - len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))",
      "mutated_line": "mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) * len(ind_c))",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) * len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))",
      "mutated_line": "mini = min(mini, concept(cutted_S[ind:] - cutted_S[:ind]) + len(ind_c))",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] - cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "mini = min(mini, concept(cutted_S[ind:] + cutted_S[:ind]) + len(ind_c))",
      "mutated_line": "mini = min(mini, concept(cutted_S[ind:] * cutted_S[:ind]) + len(ind_c))",
      "code": "def minimum_moves_to_lexicographically_smallest_string(S):\n\n    def second_val(S):\n        x = S[0]\n        ind = 0\n        while S[ind] == x:\n            ind += 1\n            if ind >= len(S):\n                return ind\n        return ind\n    cost = {}\n\n    def concept(S):\n        if len(S) == 0:\n            return 0\n        prev = 0\n        Snew = []\n        for c in S:\n            if c != prev:\n                prev = c\n                Snew.append(c)\n        S = tuple(Snew)\n        if S not in cost:\n            cs = min(S)\n            while S[0] == cs:\n                cut_index = second_val(S)\n                S = S[cut_index:]\n                if len(S) == 0:\n                    return 0\n                cs = min(S)\n            ind_c = []\n            cutted_S = []\n            cutted_id = 0\n            for (ind, test_c) in enumerate(S):\n                if test_c == cs:\n                    ind_c.append(cutted_id)\n                else:\n                    cutted_S.append(test_c)\n                    cutted_id += 1\n            cutted_S = tuple(cutted_S)\n            mini = float('inf')\n            for ind in ind_c:\n                mini = min(mini, concept(cutted_S[ind:] * cutted_S[:ind]) + len(ind_c))\n            cost[S] = mini\n        return cost[S]\n    return concept(S)"
    }
  ]
}