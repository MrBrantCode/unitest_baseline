{
  "task_id": "taco_4889",
  "entry_point": "min_jumps_to_roof",
  "mutant_count": 265,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mem[0][st[0]] = True",
      "mutated_line": "mem[0][st[0]] = False",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = False\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mem[1][st[1]] = True",
      "mutated_line": "mem[1][st[1]] = False",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = False\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while len(que) != 0:",
      "mutated_line": "while len(que) == 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) == 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "UOI",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return +1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "return str(count) if count >= 0 else 'NA'",
      "mutated_line": "return str(count) if count > 0 else 'NA'",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count > 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "return str(count) if count >= 0 else 'NA'",
      "mutated_line": "return str(count) if count < 0 else 'NA'",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count < 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "return str(count) if count >= 0 else 'NA'",
      "mutated_line": "return str(count) if count == 0 else 'NA'",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count == 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return str(count) if count >= 0 else 'NA'",
      "mutated_line": "return str(count) if count >= 0 else ''",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else ''"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "st = [0, 0]",
      "mutated_line": "st = [1, 0]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [1, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "st = [0, 0]",
      "mutated_line": "st = [-1, 0]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [-1, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "st = [0, 0]",
      "mutated_line": "st = [1, 0]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [1, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "st = [0, 0]",
      "mutated_line": "st = [0, 1]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 1]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "st = [0, 0]",
      "mutated_line": "st = [0, -1]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, -1]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "st = [0, 0]",
      "mutated_line": "st = [0, 1]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 1]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2):",
      "mutated_line": "for i in range(3):",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(3):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2):",
      "mutated_line": "for i in range(1):",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(1):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2):",
      "mutated_line": "for i in range(0):",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(0):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2):",
      "mutated_line": "for i in range(1):",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(1):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(2):",
      "mutated_line": "for i in range(-2):",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(-2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if b[i][0] != 1:",
      "mutated_line": "if b[i][0] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] == 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 1 or b[i][st[i] + 1] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 or b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "st[i] += 1",
      "mutated_line": "st[i] -= 1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] -= 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if st[i] == n - 1:",
      "mutated_line": "if st[i] != n - 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] != n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(que) != 0:",
      "mutated_line": "while len(que) != 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 1:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(que) != 0:",
      "mutated_line": "while len(que) != -1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != -1:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(que) != 0:",
      "mutated_line": "while len(que) != 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 1:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = (d[0] + 1) * 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) * 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = d[0] + 1 + 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = d[0] + 1 + 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cst = d[2] + 1",
      "mutated_line": "cst = d[2] - 1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] - 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cst = d[2] + 1",
      "mutated_line": "cst = d[2] * 1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] * 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -2\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -0\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -0\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return --1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return str(count) if count >= 0 else 'NA'",
      "mutated_line": "return str(count) if count >= 1 else 'NA'",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 1 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return str(count) if count >= 0 else 'NA'",
      "mutated_line": "return str(count) if count >= -1 else 'NA'",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= -1 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return str(count) if count >= 0 else 'NA'",
      "mutated_line": "return str(count) if count >= 1 else 'NA'",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 1 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mem = [[False for _ in range(n)] for _ in range(2)]",
      "mutated_line": "mem = [[True for _ in range(n)] for _ in range(2)]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[True for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b[i][0] != 1:",
      "mutated_line": "if b[i][0] != 2:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 2:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b[i][0] != 1:",
      "mutated_line": "if b[i][0] != 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 0:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b[i][0] != 1:",
      "mutated_line": "if b[i][0] != 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 0:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b[i][0] != 1:",
      "mutated_line": "if b[i][0] != -1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != -1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] <= n - 1 and b[i][st[i] + 1] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] <= n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] >= n - 1 and b[i][st[i] + 1] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] >= n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] != n - 1 and b[i][st[i] + 1] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] != n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 1 and b[i][st[i] + 1] != 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] != 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "st[i] += 1",
      "mutated_line": "st[i] += 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 2\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "st[i] += 1",
      "mutated_line": "st[i] += 0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 0\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "st[i] += 1",
      "mutated_line": "st[i] += 0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 0\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "st[i] += 1",
      "mutated_line": "st[i] += -1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += -1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if st[i] == n - 1:",
      "mutated_line": "if st[i] == n + 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n + 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if st[i] == n - 1:",
      "mutated_line": "if st[i] == n * 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n * 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 1\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return -1\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 1\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mem[0][st[0]] = True",
      "mutated_line": "mem[1][st[0]] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[1][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mem[0][st[0]] = True",
      "mutated_line": "mem[-1][st[0]] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[-1][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mem[0][st[0]] = True",
      "mutated_line": "mem[1][st[0]] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[1][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mem[0][st[0]] = True",
      "mutated_line": "mem[0][st[1]] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[1]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mem[0][st[0]] = True",
      "mutated_line": "mem[0][st[-1]] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[-1]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mem[0][st[0]] = True",
      "mutated_line": "mem[0][st[1]] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[1]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mem[1][st[1]] = True",
      "mutated_line": "mem[2][st[1]] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[2][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mem[1][st[1]] = True",
      "mutated_line": "mem[0][st[1]] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[0][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mem[1][st[1]] = True",
      "mutated_line": "mem[0][st[1]] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[0][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mem[1][st[1]] = True",
      "mutated_line": "mem[-1][st[1]] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[-1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mem[1][st[1]] = True",
      "mutated_line": "mem[1][st[2]] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[2]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mem[1][st[1]] = True",
      "mutated_line": "mem[1][st[0]] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[0]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mem[1][st[1]] = True",
      "mutated_line": "mem[1][st[0]] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[0]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mem[1][st[1]] = True",
      "mutated_line": "mem[1][st[-1]] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[-1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[1, st[0], 0], [1, st[1], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[1, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[-1, st[0], 0], [1, st[1], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[-1, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[1, st[0], 0], [1, st[1], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[1, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[0], 1], [1, st[1], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 1], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[0], -1], [1, st[1], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], -1], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[0], 1], [1, st[1], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 1], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[0], 0], [2, st[1], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [2, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[0], 0], [0, st[1], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [0, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[0], 0], [0, st[1], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [0, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[0], 0], [-1, st[1], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [-1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[0], 0], [1, st[1], 1]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 1]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[0], 0], [1, st[1], -1]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], -1]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[0], 0], [1, st[1], 1]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 1]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = que.pop(0)",
      "mutated_line": "d = que.pop(1)",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(1)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = que.pop(0)",
      "mutated_line": "d = que.pop(-1)",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(-1)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = que.pop(0)",
      "mutated_line": "d = que.pop(1)",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(1)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = (d[0] - 1) % 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] - 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = d[0] * 1 % 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = d[0] * 1 % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = (d[0] + 1) % 3",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 3\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = (d[0] + 1) % 1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 1\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = (d[0] + 1) % 0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 0\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = (d[0] + 1) % 1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 1\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = (d[0] + 1) % -2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % -2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cst = d[2] + 1",
      "mutated_line": "cst = d[2] + 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 2\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cst = d[2] + 1",
      "mutated_line": "cst = d[2] + 0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 0\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cst = d[2] + 1",
      "mutated_line": "cst = d[2] + 0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 0\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cst = d[2] + 1",
      "mutated_line": "cst = d[2] + -1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + -1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(4):",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(4):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(2):",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(2):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(0):",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(0):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(1):",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(1):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(-3):",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(-3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "fl = d[1] + i",
      "mutated_line": "fl = d[1] - i",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] - i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "fl = d[1] + i",
      "mutated_line": "fl = d[1] * i",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] * i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if fl >= n:",
      "mutated_line": "if fl > n:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl > n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if fl >= n:",
      "mutated_line": "if fl < n:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl < n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if fl >= n:",
      "mutated_line": "if fl == n:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl == n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if state != 2 and fl == n - 1:",
      "mutated_line": "if state != 2 or fl == n - 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 or fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if state == 0:",
      "mutated_line": "if state != 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state != 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mem = [[False for _ in range(n)] for _ in range(2)]",
      "mutated_line": "mem = [[False for _ in range(n)] for _ in range(3)]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(3)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mem = [[False for _ in range(n)] for _ in range(2)]",
      "mutated_line": "mem = [[False for _ in range(n)] for _ in range(1)]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(1)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mem = [[False for _ in range(n)] for _ in range(2)]",
      "mutated_line": "mem = [[False for _ in range(n)] for _ in range(0)]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(0)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mem = [[False for _ in range(n)] for _ in range(2)]",
      "mutated_line": "mem = [[False for _ in range(n)] for _ in range(1)]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(1)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mem = [[False for _ in range(n)] for _ in range(2)]",
      "mutated_line": "mem = [[False for _ in range(n)] for _ in range(-2)]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(-2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b[i][0] != 1:",
      "mutated_line": "if b[i][1] != 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][1] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b[i][0] != 1:",
      "mutated_line": "if b[i][-1] != 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][-1] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if b[i][0] != 1:",
      "mutated_line": "if b[i][1] != 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][1] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n + 1 and b[i][st[i] + 1] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n + 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n * 1 and b[i][st[i] + 1] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n * 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 2:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 2:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 0:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 0:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 1 and b[i][st[i] + 1] == -1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == -1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if st[i] == n - 1:",
      "mutated_line": "if st[i] == n - 2:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 2:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if st[i] == n - 1:",
      "mutated_line": "if st[i] == n - 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 0:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if st[i] == n - 1:",
      "mutated_line": "if st[i] == n - 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 0:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if st[i] == n - 1:",
      "mutated_line": "if st[i] == n - -1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - -1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[1], 0], [1, st[1], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[1], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[-1], 0], [1, st[1], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[-1], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[1], 0], [1, st[1], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[1], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[0], 0], [1, st[2], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[2], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[0], 0], [1, st[0], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[0], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[0], 0], [1, st[0], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[0], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [[0, st[0], 0], [1, st[1], 0]]",
      "mutated_line": "que = [[0, st[0], 0], [1, st[-1], 0]]",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[-1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = (d[0] + 2) % 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 2) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = (d[0] + 0) % 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 0) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = (d[0] + 0) % 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 0) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = (d[0] + -1) % 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + -1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cst = d[2] + 1",
      "mutated_line": "cst = d[3] + 1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[3] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cst = d[2] + 1",
      "mutated_line": "cst = d[1] + 1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[1] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cst = d[2] + 1",
      "mutated_line": "cst = d[0] + 1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[0] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cst = d[2] + 1",
      "mutated_line": "cst = d[1] + 1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[1] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cst = d[2] + 1",
      "mutated_line": "cst = d[-2] + 1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[-2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if state != 2 and fl == n - 1:",
      "mutated_line": "if state == 2 and fl == n - 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state == 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if state != 2 and fl == n - 1:",
      "mutated_line": "if state != 2 and fl != n - 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl != n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if state == 0:",
      "mutated_line": "if state == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 1:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if state == 0:",
      "mutated_line": "if state == -1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == -1:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if state == 0:",
      "mutated_line": "if state == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 1:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if mem[des][fl] == False:",
      "mutated_line": "if mem[des][fl] != False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] != False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif state == 1:",
      "mutated_line": "elif state != 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state != 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 2 and b[i][st[i] + 1] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 2 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 0 and b[i][st[i] + 1] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 0 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 0 and b[i][st[i] + 1] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 0 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - -1 and b[i][st[i] + 1] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - -1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 1 and b[i][st[i] - 1] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] - 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 1 and b[i][st[i] * 1] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] * 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = (d[1] + 1) % 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[1] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = (d[-1] + 1) % 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[-1] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "des = (d[0] + 1) % 2",
      "mutated_line": "des = (d[1] + 1) % 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[1] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "fl = d[1] + i",
      "mutated_line": "fl = d[2] + i",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[2] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "fl = d[1] + i",
      "mutated_line": "fl = d[0] + i",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[0] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "fl = d[1] + i",
      "mutated_line": "fl = d[0] + i",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[0] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "fl = d[1] + i",
      "mutated_line": "fl = d[-1] + i",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[-1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if state != 2 and fl == n - 1:",
      "mutated_line": "if state != 3 and fl == n - 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 3 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if state != 2 and fl == n - 1:",
      "mutated_line": "if state != 1 and fl == n - 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 1 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if state != 2 and fl == n - 1:",
      "mutated_line": "if state != 0 and fl == n - 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 0 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if state != 2 and fl == n - 1:",
      "mutated_line": "if state != 1 and fl == n - 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 1 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if state != 2 and fl == n - 1:",
      "mutated_line": "if state != -2 and fl == n - 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != -2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if state != 2 and fl == n - 1:",
      "mutated_line": "if state != 2 and fl == n + 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n + 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if state != 2 and fl == n - 1:",
      "mutated_line": "if state != 2 and fl == n * 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n * 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if mem[des][fl] == False:",
      "mutated_line": "if mem[des][fl] == True:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == True:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "mem[des][fl] = True",
      "mutated_line": "mem[des][fl] = False",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = False\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif state == 1:",
      "mutated_line": "elif state == 2:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif state == 1:",
      "mutated_line": "elif state == 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 0:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif state == 1:",
      "mutated_line": "elif state == 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 0:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif state == 1:",
      "mutated_line": "elif state == -1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == -1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "k = 1",
      "mutated_line": "k = 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 2\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "k = 1",
      "mutated_line": "k = 0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 0\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "k = 1",
      "mutated_line": "k = 0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 0\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "k = 1",
      "mutated_line": "k = -1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = -1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while False:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "elif state == 2:",
      "mutated_line": "elif state != 2:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state != 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 1 and b[i][st[i] + 2] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 2] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 1 and b[i][st[i] + 0] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 0] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 1 and b[i][st[i] + 0] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 0] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while st[i] < n - 1 and b[i][st[i] + 1] == 1:",
      "mutated_line": "while st[i] < n - 1 and b[i][st[i] + -1] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + -1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if state != 2 and fl == n - 1:",
      "mutated_line": "if state != 2 and fl == n - 2:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 2:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if state != 2 and fl == n - 1:",
      "mutated_line": "if state != 2 and fl == n - 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 0:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if state != 2 and fl == n - 1:",
      "mutated_line": "if state != 2 and fl == n - 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 0:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if state != 2 and fl == n - 1:",
      "mutated_line": "if state != 2 and fl == n - -1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - -1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if fl + k >= n:",
      "mutated_line": "if fl + k > n:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k > n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if fl + k >= n:",
      "mutated_line": "if fl + k < n:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k < n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if fl + k >= n:",
      "mutated_line": "if fl + k == n:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k == n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if b[des][fl + k] != 1:",
      "mutated_line": "if b[des][fl + k] == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] == 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k -= 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif state == 2:",
      "mutated_line": "elif state == 3:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 3:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif state == 2:",
      "mutated_line": "elif state == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif state == 2:",
      "mutated_line": "elif state == 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 0:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif state == 2:",
      "mutated_line": "elif state == 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif state == 2:",
      "mutated_line": "elif state == -2:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == -2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "k = 1",
      "mutated_line": "k = 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 2\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "k = 1",
      "mutated_line": "k = 0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 0\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "k = 1",
      "mutated_line": "k = 0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 0\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "k = 1",
      "mutated_line": "k = -1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = -1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while False:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if fl + k >= n:",
      "mutated_line": "if fl - k >= n:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl - k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if fl + k >= n:",
      "mutated_line": "if fl * k >= n:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl * k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if b[des][fl + k] != 1:",
      "mutated_line": "if b[des][fl + k] != 2:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 2:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if b[des][fl + k] != 1:",
      "mutated_line": "if b[des][fl + k] != 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 0:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if b[des][fl + k] != 1:",
      "mutated_line": "if b[des][fl + k] != 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 0:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if b[des][fl + k] != 1:",
      "mutated_line": "if b[des][fl + k] != -1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != -1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if mem[des][fl + k - 1] == False:",
      "mutated_line": "if mem[des][fl + k - 1] != False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] != False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 2\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 0\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 0\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += -1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if b[des][fl - k] != 2:",
      "mutated_line": "if b[des][fl - k] == 2:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] == 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k -= 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if b[des][fl + k] != 1:",
      "mutated_line": "if b[des][fl - k] != 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl - k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if b[des][fl + k] != 1:",
      "mutated_line": "if b[des][fl * k] != 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl * k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mem[des][fl + k - 1] == False:",
      "mutated_line": "if mem[des][fl + k - 1] == True:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == True:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mem[des][fl + k - 1] = True",
      "mutated_line": "mem[des][fl + k - 1] = False",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = False\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if b[des][fl - k] != 2:",
      "mutated_line": "if b[des][fl - k] != 3:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 3:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if b[des][fl - k] != 2:",
      "mutated_line": "if b[des][fl - k] != 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 1:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if b[des][fl - k] != 2:",
      "mutated_line": "if b[des][fl - k] != 0:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 0:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if b[des][fl - k] != 2:",
      "mutated_line": "if b[des][fl - k] != 1:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 1:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if b[des][fl - k] != 2:",
      "mutated_line": "if b[des][fl - k] != -2:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != -2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if mem[des][fl - k] == False:",
      "mutated_line": "if mem[des][fl - k] != False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] != False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 2\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 0\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 0\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += -1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if mem[des][fl + k - 1] == False:",
      "mutated_line": "if mem[des][fl + k + 1] == False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k + 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if mem[des][fl + k - 1] == False:",
      "mutated_line": "if mem[des][(fl + k) * 1] == False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][(fl + k) * 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "mem[des][fl + k - 1] = True",
      "mutated_line": "mem[des][fl + k + 1] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k + 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "mem[des][fl + k - 1] = True",
      "mutated_line": "mem[des][(fl + k) * 1] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][(fl + k) * 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if b[des][fl - k] != 2:",
      "mutated_line": "if b[des][fl + k] != 2:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl + k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if b[des][fl - k] != 2:",
      "mutated_line": "if b[des][fl * k] != 2:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl * k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if mem[des][fl - k] == False:",
      "mutated_line": "if mem[des][fl - k] == True:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == True:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "mem[des][fl - k] = True",
      "mutated_line": "mem[des][fl - k] = False",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = False\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if mem[des][fl + k - 1] == False:",
      "mutated_line": "if mem[des][fl - k - 1] == False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl - k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if mem[des][fl + k - 1] == False:",
      "mutated_line": "if mem[des][fl * k - 1] == False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl * k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mem[des][fl + k - 1] == False:",
      "mutated_line": "if mem[des][fl + k - 2] == False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 2] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mem[des][fl + k - 1] == False:",
      "mutated_line": "if mem[des][fl + k - 0] == False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 0] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mem[des][fl + k - 1] == False:",
      "mutated_line": "if mem[des][fl + k - 0] == False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 0] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mem[des][fl + k - 1] == False:",
      "mutated_line": "if mem[des][fl + k - -1] == False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - -1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "que.append([des, fl + k - 1, cst])",
      "mutated_line": "que.append([des, fl + k + 1, cst])",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k + 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "que.append([des, fl + k - 1, cst])",
      "mutated_line": "que.append([des, (fl + k) * 1, cst])",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, (fl + k) * 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "mem[des][fl + k - 1] = True",
      "mutated_line": "mem[des][fl - k - 1] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl - k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "mem[des][fl + k - 1] = True",
      "mutated_line": "mem[des][fl * k - 1] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl * k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mem[des][fl + k - 1] = True",
      "mutated_line": "mem[des][fl + k - 2] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 2] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mem[des][fl + k - 1] = True",
      "mutated_line": "mem[des][fl + k - 0] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 0] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mem[des][fl + k - 1] = True",
      "mutated_line": "mem[des][fl + k - 0] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 0] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mem[des][fl + k - 1] = True",
      "mutated_line": "mem[des][fl + k - -1] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - -1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if mem[des][fl - k] == False:",
      "mutated_line": "if mem[des][fl + k] == False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl + k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if mem[des][fl - k] == False:",
      "mutated_line": "if mem[des][fl * k] == False:",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl * k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "mem[des][fl - k] = True",
      "mutated_line": "mem[des][fl + k] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl + k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "mem[des][fl - k] = True",
      "mutated_line": "mem[des][fl * k] = True",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl * k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "que.append([des, fl + k - 1, cst])",
      "mutated_line": "que.append([des, fl - k - 1, cst])",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl - k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "que.append([des, fl + k - 1, cst])",
      "mutated_line": "que.append([des, fl * k - 1, cst])",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl * k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "que.append([des, fl + k - 1, cst])",
      "mutated_line": "que.append([des, fl + k - 2, cst])",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 2, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "que.append([des, fl + k - 1, cst])",
      "mutated_line": "que.append([des, fl + k - 0, cst])",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 0, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "que.append([des, fl + k - 1, cst])",
      "mutated_line": "que.append([des, fl + k - 0, cst])",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 0, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "que.append([des, fl + k - 1, cst])",
      "mutated_line": "que.append([des, fl + k - -1, cst])",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - -1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl - k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "que.append([des, fl - k, cst])",
      "mutated_line": "que.append([des, fl + k, cst])",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl + k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "que.append([des, fl - k, cst])",
      "mutated_line": "que.append([des, fl * k, cst])",
      "code": "def min_jumps_to_roof(n, building_a, building_b):\n\n    def bfs(b):\n        mem = [[False for _ in range(n)] for _ in range(2)]\n        st = [0, 0]\n        for i in range(2):\n            if b[i][0] != 1:\n                continue\n            while st[i] < n - 1 and b[i][st[i] + 1] == 1:\n                st[i] += 1\n            if st[i] == n - 1:\n                return 0\n        mem[0][st[0]] = True\n        mem[1][st[1]] = True\n        que = [[0, st[0], 0], [1, st[1], 0]]\n        while len(que) != 0:\n            d = que.pop(0)\n            des = (d[0] + 1) % 2\n            cst = d[2] + 1\n            for i in range(3):\n                fl = d[1] + i\n                if fl >= n:\n                    break\n                state = b[des][fl]\n                if state != 2 and fl == n - 1:\n                    return cst\n                if state == 0:\n                    if mem[des][fl] == False:\n                        que.append([des, fl, cst])\n                        mem[des][fl] = True\n                elif state == 1:\n                    k = 1\n                    while True:\n                        if fl + k >= n:\n                            return cst\n                        if b[des][fl + k] != 1:\n                            if mem[des][fl + k - 1] == False:\n                                que.append([des, fl + k - 1, cst])\n                                mem[des][fl + k - 1] = True\n                            break\n                        else:\n                            k += 1\n                elif state == 2:\n                    k = 1\n                    while True:\n                        if b[des][fl - k] != 2:\n                            if mem[des][fl - k] == False:\n                                que.append([des, fl * k, cst])\n                                mem[des][fl - k] = True\n                            break\n                        else:\n                            k += 1\n        return -1\n    b = [building_a, building_b]\n    count = bfs(b)\n    return str(count) if count >= 0 else 'NA'"
    }
  ]
}