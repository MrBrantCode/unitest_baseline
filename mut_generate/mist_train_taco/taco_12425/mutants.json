{
  "task_id": "taco_12425",
  "entry_point": "max_subset_weight",
  "mutant_count": 110,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "def dfs(v, p=-1):",
      "mutated_line": "def dfs(v, p=+1):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=+1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 1\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = -1\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 1\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > 1 or r[-2] == 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 or r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "o = (r[k] if k < len(r) else 0) + weights[v]",
      "mutated_line": "o = (r[k] if k < len(r) else 0) - weights[v]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) - weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "o = (r[k] if k < len(r) else 0) + weights[v]",
      "mutated_line": "o = (r[k] if k < len(r) else 0) * weights[v]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) * weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return dfs(0)[0]",
      "mutated_line": "return dfs(0)[1]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return dfs(0)[0]",
      "mutated_line": "return dfs(0)[-1]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return dfs(0)[0]",
      "mutated_line": "return dfs(0)[1]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "def dfs(v, p=-1):",
      "mutated_line": "def dfs(v, p=-2):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-2):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "def dfs(v, p=-1):",
      "mutated_line": "def dfs(v, p=-0):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-0):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "def dfs(v, p=-1):",
      "mutated_line": "def dfs(v, p=-0):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-0):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "def dfs(v, p=-1):",
      "mutated_line": "def dfs(v, p=--1):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=--1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i >= len(c[-1]):",
      "mutated_line": "if i > len(c[-1]):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i > len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i >= len(c[-1]):",
      "mutated_line": "if i < len(c[-1]):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i < len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i >= len(c[-1]):",
      "mutated_line": "if i == len(c[-1]):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i == len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i -= 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "r.append(0)",
      "mutated_line": "r.append(1)",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(1)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "r.append(0)",
      "mutated_line": "r.append(-1)",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(-1)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "r.append(0)",
      "mutated_line": "r.append(1)",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(1)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(len(r) - 1, 0, -1):",
      "mutated_line": "for i in range(len(r) + 1, 0, -1):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) + 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(len(r) - 1, 0, -1):",
      "mutated_line": "for i in range(len(r) * 1, 0, -1):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) * 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(len(r) - 1, 0, -1):",
      "mutated_line": "for i in range(len(r) - 1, 1, -1):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 1, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(len(r) - 1, 0, -1):",
      "mutated_line": "for i in range(len(r) - 1, -1, -1):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, -1, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(len(r) - 1, 0, -1):",
      "mutated_line": "for i in range(len(r) - 1, 1, -1):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 1, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "for i in range(len(r) - 1, 0, -1):",
      "mutated_line": "for i in range(len(r) - 1, 0, +1):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, +1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) >= 1 and r[-2] == 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) >= 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) <= 1 and r[-2] == 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) <= 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) != 1 and r[-2] == 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) != 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > 1 and r[-2] != 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] != 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "r.insert(0, max(o, r[0]))",
      "mutated_line": "r.insert(1, max(o, r[0]))",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(1, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "r.insert(0, max(o, r[0]))",
      "mutated_line": "r.insert(-1, max(o, r[0]))",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(-1, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "r.insert(0, max(o, r[0]))",
      "mutated_line": "r.insert(1, max(o, r[0]))",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(1, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return dfs(0)[0]",
      "mutated_line": "return dfs(1)[0]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(1)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return dfs(0)[0]",
      "mutated_line": "return dfs(-1)[0]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(-1)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return dfs(0)[0]",
      "mutated_line": "return dfs(1)[0]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(1)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "c = [dfs(child, v) for child in g.get(v, set()) - {p}]",
      "mutated_line": "c = [dfs(child, v) for child in g.get(v, set()) + {p}]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) + {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "c = [dfs(child, v) for child in g.get(v, set()) - {p}]",
      "mutated_line": "c = [dfs(child, v) for child in g.get(v, set()) * {p}]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) * {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c.sort(key=len, reverse=True)",
      "mutated_line": "c.sort(key=len, reverse=False)",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=False)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s = q = 0",
      "mutated_line": "s = q = 1",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 1\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s = q = 0",
      "mutated_line": "s = q = -1",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = -1\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s = q = 0",
      "mutated_line": "s = q = 1",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 1\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 2\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 0\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 0\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += -1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(len(r) - 1, 0, -1):",
      "mutated_line": "for i in range(len(r) - 2, 0, -1):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 2, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(len(r) - 1, 0, -1):",
      "mutated_line": "for i in range(len(r) - 0, 0, -1):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 0, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(len(r) - 1, 0, -1):",
      "mutated_line": "for i in range(len(r) - 0, 0, -1):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 0, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(len(r) - 1, 0, -1):",
      "mutated_line": "for i in range(len(r) - -1, 0, -1):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - -1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(len(r) - 1, 0, -1):",
      "mutated_line": "for i in range(len(r) - 1, 0, -2):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -2):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(len(r) - 1, 0, -1):",
      "mutated_line": "for i in range(len(r) - 1, 0, -0):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -0):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(len(r) - 1, 0, -1):",
      "mutated_line": "for i in range(len(r) - 1, 0, -0):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -0):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(len(r) - 1, 0, -1):",
      "mutated_line": "for i in range(len(r) - 1, 0, --1):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, --1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "r[i - 1] = max(r[i - 1], r[i])",
      "mutated_line": "r[i + 1] = max(r[i - 1], r[i])",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i + 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "r[i - 1] = max(r[i - 1], r[i])",
      "mutated_line": "r[i * 1] = max(r[i - 1], r[i])",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i * 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > 2 and r[-2] == 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 2 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > 0 and r[-2] == 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 0 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > 0 and r[-2] == 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 0 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > -1 and r[-2] == 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > -1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > 1 and r[-2] == 1:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 1:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > 1 and r[-2] == -1:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == -1:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > 1 and r[-2] == 1:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 1:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "o = (r[k] if k < len(r) else 0) + weights[v]",
      "mutated_line": "o = (r[k] if k <= len(r) else 0) + weights[v]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k <= len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "o = (r[k] if k < len(r) else 0) + weights[v]",
      "mutated_line": "o = (r[k] if k >= len(r) else 0) + weights[v]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k >= len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "o = (r[k] if k < len(r) else 0) + weights[v]",
      "mutated_line": "o = (r[k] if k != len(r) else 0) + weights[v]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k != len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "o = (r[k] if k < len(r) else 0) + weights[v]",
      "mutated_line": "o = (r[k] if k < len(r) else 1) + weights[v]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 1) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "o = (r[k] if k < len(r) else 0) + weights[v]",
      "mutated_line": "o = (r[k] if k < len(r) else -1) + weights[v]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else -1) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "o = (r[k] if k < len(r) else 0) + weights[v]",
      "mutated_line": "o = (r[k] if k < len(r) else 1) + weights[v]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 1) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "o = max(i, k - i - 1)",
      "mutated_line": "o = max(i, k - i + 1)",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i + 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "o = max(i, k - i - 1)",
      "mutated_line": "o = max(i, (k - i) * 1)",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, (k - i) * 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(x) <= o:",
      "mutated_line": "if len(x) < o:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) < o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(x) <= o:",
      "mutated_line": "if len(x) > o:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) > o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(x) <= o:",
      "mutated_line": "if len(x) == o:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) == o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "s += x[o]",
      "mutated_line": "s -= x[o]",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s -= x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r.append(q + s)",
      "mutated_line": "r.append(q - s)",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q - s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r.append(q + s)",
      "mutated_line": "r.append(q * s)",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q * s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r[i - 1] = max(r[i - 1], r[i])",
      "mutated_line": "r[i - 2] = max(r[i - 1], r[i])",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 2] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r[i - 1] = max(r[i - 1], r[i])",
      "mutated_line": "r[i - 0] = max(r[i - 1], r[i])",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 0] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r[i - 1] = max(r[i - 1], r[i])",
      "mutated_line": "r[i - 0] = max(r[i - 1], r[i])",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 0] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r[i - 1] = max(r[i - 1], r[i])",
      "mutated_line": "r[i - -1] = max(r[i - 1], r[i])",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - -1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "r[i - 1] = max(r[i - 1], r[i])",
      "mutated_line": "r[i - 1] = max(r[i + 1], r[i])",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i + 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "r[i - 1] = max(r[i - 1], r[i])",
      "mutated_line": "r[i - 1] = max(r[i * 1], r[i])",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i * 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > 1 and r[+2] == 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[+2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "r.insert(0, max(o, r[0]))",
      "mutated_line": "r.insert(0, max(o, r[1]))",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[1]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "r.insert(0, max(o, r[0]))",
      "mutated_line": "r.insert(0, max(o, r[-1]))",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[-1]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "r.insert(0, max(o, r[0]))",
      "mutated_line": "r.insert(0, max(o, r[1]))",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[1]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "if i >= len(c[-1]):",
      "mutated_line": "if i >= len(c[+1]):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[+1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "o = max(i, k - i - 1)",
      "mutated_line": "o = max(i, k + i - 1)",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k + i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "o = max(i, k - i - 1)",
      "mutated_line": "o = max(i, k * i - 1)",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k * i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "o = max(i, k - i - 1)",
      "mutated_line": "o = max(i, k - i - 2)",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 2)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "o = max(i, k - i - 1)",
      "mutated_line": "o = max(i, k - i - 0)",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 0)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "o = max(i, k - i - 1)",
      "mutated_line": "o = max(i, k - i - 0)",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 0)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "o = max(i, k - i - 1)",
      "mutated_line": "o = max(i, k - i - -1)",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - -1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r[i - 1] = max(r[i - 1], r[i])",
      "mutated_line": "r[i - 1] = max(r[i - 2], r[i])",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 2], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r[i - 1] = max(r[i - 1], r[i])",
      "mutated_line": "r[i - 1] = max(r[i - 0], r[i])",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 0], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r[i - 1] = max(r[i - 1], r[i])",
      "mutated_line": "r[i - 1] = max(r[i - 0], r[i])",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 0], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "r[i - 1] = max(r[i - 1], r[i])",
      "mutated_line": "r[i - 1] = max(r[i - -1], r[i])",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - -1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > 1 and r[-3] == 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-3] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > 1 and r[-1] == 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-1] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > 1 and r[-0] == 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-0] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > 1 and r[-1] == 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-1] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(r) > 1 and r[-2] == 0:",
      "mutated_line": "while len(r) > 1 and r[--2] == 0:",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[--2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i >= len(c[-1]):",
      "mutated_line": "if i >= len(c[-2]):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-2]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i >= len(c[-1]):",
      "mutated_line": "if i >= len(c[-0]):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-0]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i >= len(c[-1]):",
      "mutated_line": "if i >= len(c[-0]):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-0]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i >= len(c[-1]):",
      "mutated_line": "if i >= len(c[--1]):",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[--1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] - x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "q = max(q, x[i] - x[o])",
      "mutated_line": "q = max(q, x[i] + x[o])",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] + x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "q = max(q, x[i] - x[o])",
      "mutated_line": "q = max(q, x[i] * x[o])",
      "code": "def max_subset_weight(n, k, weights, edges):\n    g = {}\n\n    def dfs(v, p=-1):\n        c = [dfs(child, v) for child in g.get(v, set()) - {p}]\n        c.sort(key=len, reverse=True)\n        r = []\n        i = 0\n        while c:\n            if i >= len(c[-1]):\n                c.pop()\n            else:\n                o = max(i, k - i - 1)\n                s = q = 0\n                for x in c:\n                    if len(x) <= o:\n                        q = max(q, x[i])\n                    else:\n                        s += x[o]\n                        q = max(q, x[i] * x[o])\n                r.append(q + s)\n                i += 1\n        r.append(0)\n        for i in range(len(r) - 1, 0, -1):\n            r[i - 1] = max(r[i - 1], r[i])\n        while len(r) > 1 and r[-2] == 0:\n            r.pop()\n        o = (r[k] if k < len(r) else 0) + weights[v]\n        r.insert(0, max(o, r[0]))\n        return r\n    for (u, v) in edges:\n        g.setdefault(u, set()).add(v)\n        g.setdefault(v, set()).add(u)\n    return dfs(0)[0]"
    }
  ]
}