{
  "task_id": "taco_12721",
  "entry_point": "combk",
  "mutant_count": 139,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "MOD = 10 ** 9 - 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "MOD = 10 ** 9 * 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "MOD = 10 * 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "MOD = 10 + 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "MOD = 10 ** 9 + 8\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "MOD = 10 ** 9 + 6\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "MOD = 10 ** 9 + 0\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "MOD = 10 ** 9 + 1\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "MOD = 10 ** 9 + -7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(tbl) < k:",
      "mutated_line": "if len(tbl) <= k:",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) <= k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(tbl) < k:",
      "mutated_line": "if len(tbl) >= k:",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) >= k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(tbl) < k:",
      "mutated_line": "if len(tbl) != k:",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) != k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "tbl += [0] * k + [1]",
      "mutated_line": "tbl -= [0] * k + [1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl -= [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while n >= len(tbl):",
      "mutated_line": "while n > len(tbl):",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n > len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while n >= len(tbl):",
      "mutated_line": "while n < len(tbl):",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n < len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while n >= len(tbl):",
      "mutated_line": "while n == len(tbl):",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n == len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count = total = 0",
      "mutated_line": "count = total = 1",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 1\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count = total = 0",
      "mutated_line": "count = total = -1",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = -1\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count = total = 0",
      "mutated_line": "count = total = 1",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 1\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "pos = oplist[0] // 2",
      "mutated_line": "pos = oplist[0] / 2",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] / 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "pos = oplist[0] // 2",
      "mutated_line": "pos = oplist[0] * 2",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] * 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "count += delta",
      "mutated_line": "count -= delta",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count -= delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "MOD = 11 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "MOD = 9 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "MOD = 0 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "MOD = 1 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "MOD = -10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "MOD = 10 ** 10 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "MOD = 10 ** 8 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "MOD = 10 ** 0 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "MOD = 10 ** 1 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "MOD = 10 ** -9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "tbl += [0] * k + [1]",
      "mutated_line": "tbl += [0] * k - [1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k - [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "tbl += [0] * k + [1]",
      "mutated_line": "tbl += [0] * k * [1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k * [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pos = oplist[0] // 2",
      "mutated_line": "pos = oplist[0] // 3",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 3\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pos = oplist[0] // 2",
      "mutated_line": "pos = oplist[0] // 1",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 1\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pos = oplist[0] // 2",
      "mutated_line": "pos = oplist[0] // 0",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 0\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pos = oplist[0] // 2",
      "mutated_line": "pos = oplist[0] // 1",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 1\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pos = oplist[0] // 2",
      "mutated_line": "pos = oplist[0] // -2",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // -2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if op & 1:",
      "mutated_line": "if op | 1:",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op | 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "total = (total + combk(count, k) * (i - pos)) % MOD",
      "mutated_line": "total = (total + combk(count, k) * (i - pos)) * MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) * MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "total = (total + combk(count, k) * (i - pos)) % MOD",
      "mutated_line": "total = total + combk(count, k) * (i - pos) + MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = total + combk(count, k) * (i - pos) + MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "tbl += [0] * k + [1]",
      "mutated_line": "tbl += [0] / k + [1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] / k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "tbl += [0] * k + [1]",
      "mutated_line": "tbl += [0] + k + [1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] + k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "tbl += [0] * k + [1]",
      "mutated_line": "tbl += [0] ** k + [1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] ** k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) * MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) * MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) + MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) + MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pos = oplist[0] // 2",
      "mutated_line": "pos = oplist[1] // 2",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[1] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pos = oplist[0] // 2",
      "mutated_line": "pos = oplist[-1] // 2",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[-1] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pos = oplist[0] // 2",
      "mutated_line": "pos = oplist[1] // 2",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[1] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if op & 1:",
      "mutated_line": "if op & 2:",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 2:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if op & 1:",
      "mutated_line": "if op & 0:",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 0:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if op & 1:",
      "mutated_line": "if op & 0:",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 0:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if op & 1:",
      "mutated_line": "if op & -1:",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & -1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "total = (total + combk(count, k) * (i - pos)) % MOD",
      "mutated_line": "total = (total - combk(count, k) * (i - pos)) % MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total - combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "total = (total + combk(count, k) * (i - pos)) % MOD",
      "mutated_line": "total = total * (combk(count, k) * (i - pos)) % MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = total * (combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tbl += [0] * k + [1]",
      "mutated_line": "tbl += [0] * k + [2]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [2]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tbl += [0] * k + [1]",
      "mutated_line": "tbl += [0] * k + [0]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [0]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tbl += [0] * k + [1]",
      "mutated_line": "tbl += [0] * k + [0]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [0]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tbl += [0] * k + [1]",
      "mutated_line": "tbl += [0] * k + [-1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [-1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-1] * len(tbl) / pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) / pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append((tbl[-1] * len(tbl) + pow(len(tbl) - k, MOD - 2, MOD)) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append((tbl[-1] * len(tbl) + pow(len(tbl) - k, MOD - 2, MOD)) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append((tbl[-1] * len(tbl)) ** pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append((tbl[-1] * len(tbl)) ** pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 / l, 2 * r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 / l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 + l, 2 * r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 + l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 ** l, 2 * r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 ** l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r - 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r - 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r * 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r * 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 1) / 2, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) / 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 1) * 2, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) * 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 1) // 2, +1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, +1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(i, delta) = (op // 2, 1)",
      "mutated_line": "(i, delta) = (op / 2, 1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op / 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(i, delta) = (op // 2, 1)",
      "mutated_line": "(i, delta) = (op * 2, 1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op * 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(i, delta) = (op // 2, 1)",
      "mutated_line": "(i, delta) = (op // 2, 2)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 2)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(i, delta) = (op // 2, 1)",
      "mutated_line": "(i, delta) = (op // 2, 0)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 0)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(i, delta) = (op // 2, 1)",
      "mutated_line": "(i, delta) = (op // 2, 0)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 0)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(i, delta) = (op // 2, 1)",
      "mutated_line": "(i, delta) = (op // 2, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, -1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "total = (total + combk(count, k) * (i - pos)) % MOD",
      "mutated_line": "total = (total + combk(count, k) / (i - pos)) % MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) / (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "total = (total + combk(count, k) * (i - pos)) % MOD",
      "mutated_line": "total = (total + (combk(count, k) + (i - pos))) % MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + (combk(count, k) + (i - pos))) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "total = (total + combk(count, k) * (i - pos)) % MOD",
      "mutated_line": "total = (total + combk(count, k) ** (i - pos)) % MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) ** (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tbl += [0] * k + [1]",
      "mutated_line": "tbl += [1] * k + [1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [1] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tbl += [0] * k + [1]",
      "mutated_line": "tbl += [-1] * k + [1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [-1] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tbl += [0] * k + [1]",
      "mutated_line": "tbl += [1] * k + [1]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [1] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-1] / len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] / len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append((tbl[-1] + len(tbl)) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append((tbl[-1] + len(tbl)) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-1] ** len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] ** len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (3 * l, 2 * r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (3 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (1 * l, 2 * r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (1 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (0 * l, 2 * r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (0 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (1 * l, 2 * r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (1 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (-2 * l, 2 * r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (-2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 / r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 / r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 + r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 + r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 ** r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 ** r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 2)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 2)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 0)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 0)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 0)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 0)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + -1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + -1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op - 1) // 2, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op - 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = (op * 1 // 2, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = (op * 1 // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 1) // 3, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 3, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 1) // 1, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 1, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 1) // 0, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 0, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 1) // 1, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 1, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 1) // -2, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // -2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 1) // 2, -2)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -2)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 1) // 2, -0)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -0)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 1) // 2, -0)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -0)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 1) // 2, --1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, --1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(i, delta) = (op // 2, 1)",
      "mutated_line": "(i, delta) = (op // 3, 1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 3, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(i, delta) = (op // 2, 1)",
      "mutated_line": "(i, delta) = (op // 1, 1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 1, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(i, delta) = (op // 2, 1)",
      "mutated_line": "(i, delta) = (op // 0, 1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 0, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(i, delta) = (op // 2, 1)",
      "mutated_line": "(i, delta) = (op // 1, 1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 1, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(i, delta) = (op // 2, 1)",
      "mutated_line": "(i, delta) = (op // -2, 1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // -2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "total = (total + combk(count, k) * (i - pos)) % MOD",
      "mutated_line": "total = (total + combk(count, k) * (i + pos)) % MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i + pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "total = (total + combk(count, k) * (i - pos)) % MOD",
      "mutated_line": "total = (total + combk(count, k) * (i * pos)) % MOD",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i * pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) + k, MOD - 2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) + k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) * k, MOD - 2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) * k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD + 2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD + 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD * 2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD * 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 * l, 3 * r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 3 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 * l, 1 * r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 1 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 * l, 0 * r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 0 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 * l, 1 * r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 1 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]",
      "mutated_line": "oplist = [p for (l, r) in segments for p in (2 * l, -2 * r + 1)]",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, -2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 2) // 2, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 2) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 0) // 2, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 0) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + 0) // 2, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 0) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(i, delta) = ((op + 1) // 2, -1)",
      "mutated_line": "(i, delta) = ((op + -1) // 2, -1)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + -1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[+1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[+1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 3, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 3, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 1, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 1, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 0, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 0, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 1, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 1, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - -2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - -2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-2] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-2] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-0] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-0] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[-0] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[-0] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tbl.append(tbl[-1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "mutated_line": "tbl.append(tbl[--1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)",
      "code": "MOD = 10 ** 9 + 7\n\ndef combk(n, k, MOD=MOD, tbl=[]):\n    if len(tbl) < k:\n        tbl += [0] * k + [1]\n    while n >= len(tbl):\n        tbl.append(tbl[--1] * len(tbl) * pow(len(tbl) - k, MOD - 2, MOD) % MOD)\n    return tbl[n]\n\ndef calculate_intersection_sum(n, k, segments):\n    oplist = [p for (l, r) in segments for p in (2 * l, 2 * r + 1)]\n    oplist.sort()\n    count = total = 0\n    pos = oplist[0] // 2\n    for op in oplist:\n        if op & 1:\n            (i, delta) = ((op + 1) // 2, -1)\n        else:\n            (i, delta) = (op // 2, 1)\n        total = (total + combk(count, k) * (i - pos)) % MOD\n        pos = i\n        count += delta\n    return total"
    }
  ]
}