{
  "task_id": "taco_10147",
  "entry_point": "minimum_velocity_to_reach_target",
  "mutant_count": 133,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "l = d / (b + 1)",
      "mutated_line": "l = d * (b + 1)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d * (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "l = d / (b + 1)",
      "mutated_line": "l = d // (b + 1)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d // (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "idx = 0",
      "mutated_line": "idx = 1",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 1\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "idx = 0",
      "mutated_line": "idx = -1",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = -1\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "idx = 0",
      "mutated_line": "idx = 1",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 1\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "vx2 = 10 ** 9",
      "mutated_line": "vx2 = 10 * 9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 * 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "vx2 = 10 ** 9",
      "mutated_line": "vx2 = 10 + 9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 + 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if vx2 == 0:",
      "mutated_line": "if vx2 != 0:",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 != 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "l = d / (b + 1)",
      "mutated_line": "l = d / (b - 1)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b - 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "l = d / (b + 1)",
      "mutated_line": "l = d / (b * 1)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b * 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "vx2 = 10 ** 9",
      "mutated_line": "vx2 = 11 ** 9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 11 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "vx2 = 10 ** 9",
      "mutated_line": "vx2 = 9 ** 9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 9 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "vx2 = 10 ** 9",
      "mutated_line": "vx2 = 0 ** 9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 0 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "vx2 = 10 ** 9",
      "mutated_line": "vx2 = 1 ** 9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 1 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "vx2 = 10 ** 9",
      "mutated_line": "vx2 = -10 ** 9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = -10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "vx2 = 10 ** 9",
      "mutated_line": "vx2 = 10 ** 10",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 10\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "vx2 = 10 ** 9",
      "mutated_line": "vx2 = 10 ** 8",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 8\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "vx2 = 10 ** 9",
      "mutated_line": "vx2 = 10 ** 0",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 0\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "vx2 = 10 ** 9",
      "mutated_line": "vx2 = 10 ** 1",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 1\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "vx2 = 10 ** 9",
      "mutated_line": "vx2 = 10 ** -9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** -9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(b + 1):",
      "mutated_line": "for i in range(b - 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b - 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(b + 1):",
      "mutated_line": "for i in range(b * 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b * 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n or O[idx][0] * (b + 1) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n or O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "p -= l * i",
      "mutated_line": "p += l * i",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p += l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "idx += 1",
      "mutated_line": "idx -= 1",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx -= 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if vx2 == 0:",
      "mutated_line": "if vx2 == 1:",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 1:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if vx2 == 0:",
      "mutated_line": "if vx2 == -1:",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == -1:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if vx2 == 0:",
      "mutated_line": "if vx2 == 1:",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 1:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return 10 ** 9",
      "mutated_line": "return 10 * 9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 * 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return 10 ** 9",
      "mutated_line": "return 10 + 9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 + 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l < vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l < vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l > vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l > vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l == vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l == vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 - l ** 2 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 - l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 * (l ** 2 / (4 * vx2))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 * (l ** 2 / (4 * vx2))\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l = d / (b + 1)",
      "mutated_line": "l = d / (b + 2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 2)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l = d / (b + 1)",
      "mutated_line": "l = d / (b + 0)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 0)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l = d / (b + 1)",
      "mutated_line": "l = d / (b + 0)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 0)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l = d / (b + 1)",
      "mutated_line": "l = d / (b + -1)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + -1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(b + 1):",
      "mutated_line": "for i in range(b + 2):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 2):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(b + 1):",
      "mutated_line": "for i in range(b + 0):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 0):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(b + 1):",
      "mutated_line": "for i in range(b + 0):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 0):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(b + 1):",
      "mutated_line": "for i in range(b + -1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + -1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx <= n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx <= n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx >= n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx >= n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx != n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx != n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 1) < d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) < d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 1) > d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) > d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 1) == d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) == d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p -= l * i",
      "mutated_line": "p -= l / i",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l / i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p -= l * i",
      "mutated_line": "p -= l + i",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l + i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p -= l * i",
      "mutated_line": "p -= l ** i",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l ** i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "idx += 1",
      "mutated_line": "idx += 2",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 2\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "idx += 1",
      "mutated_line": "idx += 0",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 0\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "idx += 1",
      "mutated_line": "idx += 0",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 0\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "idx += 1",
      "mutated_line": "idx += -1",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += -1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 10 ** 9",
      "mutated_line": "return 11 ** 9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 11 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 10 ** 9",
      "mutated_line": "return 9 ** 9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 9 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 10 ** 9",
      "mutated_line": "return 0 ** 9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 0 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 10 ** 9",
      "mutated_line": "return 1 ** 9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 1 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 10 ** 9",
      "mutated_line": "return -10 ** 9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return -10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 10 ** 9",
      "mutated_line": "return 10 ** 10",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 10\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 10 ** 9",
      "mutated_line": "return 10 ** 8",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 8\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 10 ** 9",
      "mutated_line": "return 10 ** 0",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 0\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 10 ** 9",
      "mutated_line": "return 10 ** 1",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 1\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 10 ** 9",
      "mutated_line": "return 10 ** -9",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** -9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 / 2 else vx2 + l ** 2 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 / 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 + 2 else vx2 + l ** 2 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 + 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 ** 2 else vx2 + l ** 2 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 ** 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 * (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 * (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 // (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 // (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] / (b + 1) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] / (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] + (b + 1) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] + (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] ** (b + 1) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] ** (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 1) <= d / (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d / (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 1) <= d + (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d + (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 1) <= d ** (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d ** (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, p * (l - p) * (2 * h))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) * (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, p * (l - p) // (2 * h))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) // (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 3 else vx2 + l ** 2 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 3 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 1 else vx2 + l ** 2 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 1 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 0 else vx2 + l ** 2 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 0 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 1 else vx2 + l ** 2 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 1 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * -2 else vx2 + l ** 2 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * -2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l * 2 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l * 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + (l + 2) / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + (l + 2) / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 / vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 / vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 + vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 + vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / 4 ** vx2",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / 4 ** vx2\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return math.sqrt(min(map(solve, range(b + 1))))",
      "mutated_line": "return math.sqrt(min(map(solve, range(b - 1))))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b - 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return math.sqrt(min(map(solve, range(b + 1))))",
      "mutated_line": "return math.sqrt(min(map(solve, range(b * 1))))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b * 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b - 1) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b - 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b * 1) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b * 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i - 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i - 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i * 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i * 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, p / (l - p) / (2 * h))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p / (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, (p + (l - p)) / (2 * h))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, (p + (l - p)) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, p ** (l - p) / (2 * h))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p ** (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, p * (l - p) / (2 / h))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 / h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, p * (l - p) / (2 + h))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 + h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, p * (l - p) / 2 ** h)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / 2 ** h)\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** 3 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 3 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** 1 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 1 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** 0 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 0 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** 1 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 1 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** -2 / (4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** -2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (5 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (5 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (3 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (3 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (0 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (0 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (1 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (1 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)",
      "mutated_line": "return l if l <= vx2 * 2 else vx2 + l ** 2 / (-4 * vx2)",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (-4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return math.sqrt(min(map(solve, range(b + 1))))",
      "mutated_line": "return math.sqrt(min(map(solve, range(b + 2))))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 2))))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return math.sqrt(min(map(solve, range(b + 1))))",
      "mutated_line": "return math.sqrt(min(map(solve, range(b + 0))))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 0))))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return math.sqrt(min(map(solve, range(b + 1))))",
      "mutated_line": "return math.sqrt(min(map(solve, range(b + 0))))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 0))))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return math.sqrt(min(map(solve, range(b + 1))))",
      "mutated_line": "return math.sqrt(min(map(solve, range(b + -1))))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + -1))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][1] * (b + 1) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][1] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][-1] * (b + 1) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][-1] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][1] * (b + 1) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][1] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 2) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 2) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 0) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 0) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 0) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 0) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + -1) <= d * (i + 1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + -1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 2):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 2):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 0):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 0):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 0):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 0):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):",
      "mutated_line": "while idx < n and O[idx][0] * (b + 1) <= d * (i + -1):",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + -1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, p * (l + p) / (2 * h))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l + p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, p * (l * p) / (2 * h))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l * p) / (2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, p * (l - p) / (3 * h))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (3 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, p * (l - p) / (1 * h))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (1 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, p * (l - p) / (0 * h))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (0 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, p * (l - p) / (1 * h))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (1 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vx2 = min(vx2, p * (l - p) / (2 * h))",
      "mutated_line": "vx2 = min(vx2, p * (l - p) / (-2 * h))",
      "code": "import math\n\ndef minimum_velocity_to_reach_target(d, n, b, O):\n\n    def solve(b):\n        l = d / (b + 1)\n        idx = 0\n        vx2 = 10 ** 9\n        for i in range(b + 1):\n            while idx < n and O[idx][0] * (b + 1) <= d * (i + 1):\n                (p, h) = O[idx]\n                p -= l * i\n                vx2 = min(vx2, p * (l - p) / (-2 * h))\n                idx += 1\n        if vx2 == 0:\n            return 10 ** 9\n        return l if l <= vx2 * 2 else vx2 + l ** 2 / (4 * vx2)\n    return math.sqrt(min(map(solve, range(b + 1))))"
    }
  ]
}