{
  "task_id": "taco_14495",
  "entry_point": "calculate_minimum_climbing_time",
  "mutant_count": 228,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inf = 1000000007",
      "mutated_line": "inf = 1000000008",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000008\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inf = 1000000007",
      "mutated_line": "inf = 1000000006",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000006\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inf = 1000000007",
      "mutated_line": "inf = 0",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 0\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inf = 1000000007",
      "mutated_line": "inf = 1",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inf = 1000000007",
      "mutated_line": "inf = -1000000007",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = -1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [+2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [+2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, +1, 0, 1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, +1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 1, 1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 1, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, -1, 1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, -1, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 1, 1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 1, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 2, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 2, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 0, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 0, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 0, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 0, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, -1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, -1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 3, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 3, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 1, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 1, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 0, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 0, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 1, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 1, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, -2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, -2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, +1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, +1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, -1, 1, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 1, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, -1, -1, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, -1, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, -1, 1, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 1, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 2, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 2, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 0, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 0, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 0, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 0, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, -1, 0, -1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, -1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 1]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 1]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, -1]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, -1]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 1]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 1]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [2, 1, 1, 1, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [2, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [0, 1, 1, 1, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [0, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [0, 1, 1, 1, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [0, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [-1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [-1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 2, 1, 1, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 2, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 0, 1, 1, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 0, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 0, 1, 1, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 0, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, -1, 1, 1, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, -1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 2, 1, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 2, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 0, 1, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 0, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 0, 1, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 0, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, -1, 1, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, -1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 2, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 2, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 0, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 0, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 0, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 0, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, -1, 1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, -1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 2, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 2, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 0, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 0, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 0, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 0, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, -1, 2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, -1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 3, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 3, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 1, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 1, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 0, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 0, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 1, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 1, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, -2, 2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, -2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, 3, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 3, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, 1, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 1, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, 0, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 0, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, 1, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 1, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, -2, 2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, -2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, 2, 3, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 3, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, 2, 1, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 1, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, 2, 0, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 0, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, 2, 1, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 1, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, 2, -2, 3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, -2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 4]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 4]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 2]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 2]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 0]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 1]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 1]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]",
      "mutated_line": "rx = [1, 1, 1, 1, 1, 2, 2, 2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, -3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [+1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [+1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, +1, -1, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, +1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, +1, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, +1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, +1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, +1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, +1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, +1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, +2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, +2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, +2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, +2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -2, +2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, +2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, +3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, +3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if dp[i][j][b] < cost:",
      "mutated_line": "if dp[i][j][b] <= cost:",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] <= cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if dp[i][j][b] < cost:",
      "mutated_line": "if dp[i][j][b] >= cost:",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] >= cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if dp[i][j][b] < cost:",
      "mutated_line": "if dp[i][j][b] != cost:",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] != cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if cliff_data[i][j] == 'T':",
      "mutated_line": "if cliff_data[i][j] != 'T':",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] != 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "return res if res != inf else -1",
      "mutated_line": "return res if res == inf else -1",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res == inf else -1"
    },
    {
      "operator": "UOI",
      "lineno": 50,
      "original_line": "return res if res != inf else -1",
      "mutated_line": "return res if res != inf else +1",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else +1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-3, -1, 0, 1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-3, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-1, -1, 0, 1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-1, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-0, -1, 0, 1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-0, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-1, -1, 0, 1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-1, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [--2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [--2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -2, 0, 1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -2, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -0, 0, 1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -0, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -0, 0, 1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -0, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, --1, 0, 1, 2, -1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, --1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, -2, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -2, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, -0, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -0, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, -0, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -0, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]",
      "mutated_line": "dy = [-2, -1, 0, 1, 2, --1, 0, 1, 0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, --1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-2, -1, -1, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-2, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-0, -1, -1, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-0, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-0, -1, -1, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-0, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [--1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [--1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -2, -1, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -2, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -0, -1, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -0, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -0, -1, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -0, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, --1, -1, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, --1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -2, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -2, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -0, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -0, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -0, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -0, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, --1, -1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, --1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -2, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -2, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -0, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -0, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -0, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -0, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, --1, -1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, --1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -2, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -2, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -0, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -0, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -0, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -0, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, --1, -2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, --1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -3, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -3, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -1, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -1, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -0, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -0, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -1, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -1, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, --2, -2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, --2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -3, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -3, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -1, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -1, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -0, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -0, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -1, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -1, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, --2, -2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, --2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -3, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -3, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -1, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -1, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -0, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -0, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -1, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -1, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -2, --2, -3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, --2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -4]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -4]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -2]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -2]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -0]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -0]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -1]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -1]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]",
      "mutated_line": "lx = [-1, -1, -1, -1, -1, -2, -2, -2, --3]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, --3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]",
      "mutated_line": "dp = [[[inf] / 2 for _ in range(w)] for _ in range(h)]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] / 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]",
      "mutated_line": "dp = [[[inf] + 2 for _ in range(w)] for _ in range(h)]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] + 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]",
      "mutated_line": "dp = [[[inf] ** 2 for _ in range(w)] for _ in range(h)]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] ** 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if cliff_data[i][j] == 'S':",
      "mutated_line": "if cliff_data[i][j] != 'S':",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] != 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if cliff_data[i][j] == 'T':",
      "mutated_line": "if cliff_data[i][j] == '':",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == '':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for k in range(9):",
      "mutated_line": "for k in range(10):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(10):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for k in range(9):",
      "mutated_line": "for k in range(8):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(8):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for k in range(9):",
      "mutated_line": "for k in range(0):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(0):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for k in range(9):",
      "mutated_line": "for k in range(1):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(1):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for k in range(9):",
      "mutated_line": "for k in range(-9):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(-9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "h = i + dy[k]",
      "mutated_line": "h = i - dy[k]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i - dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "h = i + dy[k]",
      "mutated_line": "h = i * dy[k]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i * dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "bb = (b + 1) % 2",
      "mutated_line": "bb = (b + 1) * 2",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) * 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "bb = (b + 1) % 2",
      "mutated_line": "bb = b + 1 + 2",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = b + 1 + 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if cliff_data[h][w] == 'X':",
      "mutated_line": "if cliff_data[h][w] != 'X':",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] != 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if '1' <= cliff_data[i][j] <= '9':",
      "mutated_line": "if '1' < cliff_data[i][j] <= '9':",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' < cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if '1' <= cliff_data[i][j] <= '9':",
      "mutated_line": "if '1' > cliff_data[i][j] <= '9':",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' > cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if '1' <= cliff_data[i][j] <= '9':",
      "mutated_line": "if '1' == cliff_data[i][j] <= '9':",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' == cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if ncost < dp[h][w][bb]:",
      "mutated_line": "if ncost <= dp[h][w][bb]:",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost <= dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if ncost < dp[h][w][bb]:",
      "mutated_line": "if ncost >= dp[h][w][bb]:",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost >= dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if ncost < dp[h][w][bb]:",
      "mutated_line": "if ncost != dp[h][w][bb]:",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost != dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return res if res != inf else -1",
      "mutated_line": "return res if res != inf else -2",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -2"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return res if res != inf else -1",
      "mutated_line": "return res if res != inf else -0",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return res if res != inf else -1",
      "mutated_line": "return res if res != inf else -0",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return res if res != inf else -1",
      "mutated_line": "return res if res != inf else --1",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else --1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]",
      "mutated_line": "dp = [[[inf] * 3 for _ in range(w)] for _ in range(h)]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 3 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]",
      "mutated_line": "dp = [[[inf] * 1 for _ in range(w)] for _ in range(h)]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 1 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]",
      "mutated_line": "dp = [[[inf] * 0 for _ in range(w)] for _ in range(h)]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 0 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]",
      "mutated_line": "dp = [[[inf] * 1 for _ in range(w)] for _ in range(h)]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 1 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]",
      "mutated_line": "dp = [[[inf] * -2 for _ in range(w)] for _ in range(h)]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * -2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if cliff_data[i][j] == 'S':",
      "mutated_line": "if cliff_data[i][j] == '':",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == '':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[i][j][0] = 0",
      "mutated_line": "dp[i][j][0] = 1",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 1\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[i][j][0] = 0",
      "mutated_line": "dp[i][j][0] = -1",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = -1\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[i][j][0] = 0",
      "mutated_line": "dp[i][j][0] = 1",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 1\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][1] = 0",
      "mutated_line": "dp[i][j][1] = 1",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 1\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][1] = 0",
      "mutated_line": "dp[i][j][1] = -1",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = -1\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][1] = 0",
      "mutated_line": "dp[i][j][1] = 1",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 1\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "w = j + lx[k]",
      "mutated_line": "w = j - lx[k]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j - lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "w = j + lx[k]",
      "mutated_line": "w = j * lx[k]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j * lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "w = j + rx[k]",
      "mutated_line": "w = j - rx[k]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j - rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "w = j + rx[k]",
      "mutated_line": "w = j * rx[k]",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j * rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "bb = (b + 1) % 2",
      "mutated_line": "bb = (b - 1) % 2",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b - 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "bb = (b + 1) % 2",
      "mutated_line": "bb = b * 1 % 2",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = b * 1 % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bb = (b + 1) % 2",
      "mutated_line": "bb = (b + 1) % 3",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 3\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bb = (b + 1) % 2",
      "mutated_line": "bb = (b + 1) % 1",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 1\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bb = (b + 1) % 2",
      "mutated_line": "bb = (b + 1) % 0",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 0\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bb = (b + 1) % 2",
      "mutated_line": "bb = (b + 1) % 1",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 1\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bb = (b + 1) % 2",
      "mutated_line": "bb = (b + 1) % -2",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % -2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "if not (0 <= h < h and 0 <= w < w):",
      "mutated_line": "if not (0 <= h < h or 0 <= w < w):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h or 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if cliff_data[h][w] == 'X':",
      "mutated_line": "if cliff_data[h][w] == '':",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == '':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if '1' <= cliff_data[i][j] <= '9':",
      "mutated_line": "if '' <= cliff_data[i][j] <= '9':",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if '1' <= cliff_data[i][j] <= '9':",
      "mutated_line": "if '1' <= cliff_data[i][j] <= '':",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ncost = cost + int(cliff_data[i][j])",
      "mutated_line": "ncost = cost - int(cliff_data[i][j])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost - int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ncost = cost + int(cliff_data[i][j])",
      "mutated_line": "ncost = cost * int(cliff_data[i][j])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost * int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[i][j][0] = 0",
      "mutated_line": "dp[i][j][1] = 0",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][1] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[i][j][0] = 0",
      "mutated_line": "dp[i][j][-1] = 0",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][-1] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp[i][j][0] = 0",
      "mutated_line": "dp[i][j][1] = 0",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][1] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][1] = 0",
      "mutated_line": "dp[i][j][2] = 0",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][2] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][1] = 0",
      "mutated_line": "dp[i][j][0] = 0",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][0] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][1] = 0",
      "mutated_line": "dp[i][j][0] = 0",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][0] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][j][1] = 0",
      "mutated_line": "dp[i][j][-1] = 0",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][-1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bb = (b + 1) % 2",
      "mutated_line": "bb = (b + 2) % 2",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 2) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bb = (b + 1) % 2",
      "mutated_line": "bb = (b + 0) % 2",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 0) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bb = (b + 1) % 2",
      "mutated_line": "bb = (b + 0) % 2",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 0) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bb = (b + 1) % 2",
      "mutated_line": "bb = (b + -1) % 2",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + -1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if not (0 <= h < h and 0 <= w < w):",
      "mutated_line": "if not (0 < h < h and 0 <= w < w):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 < h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if not (0 <= h < h and 0 <= w < w):",
      "mutated_line": "if not (0 > h < h and 0 <= w < w):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 > h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if not (0 <= h < h and 0 <= w < w):",
      "mutated_line": "if not (0 == h < h and 0 <= w < w):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 == h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if not (0 <= h < h and 0 <= w < w):",
      "mutated_line": "if not (0 <= h < h and 0 < w < w):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 < w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if not (0 <= h < h and 0 <= w < w):",
      "mutated_line": "if not (0 <= h < h and 0 > w < w):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 > w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if not (0 <= h < h and 0 <= w < w):",
      "mutated_line": "if not (0 <= h < h and 0 == w < w):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 == w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pq.append([0, i, j, 0])",
      "mutated_line": "pq.append([1, i, j, 0])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([1, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pq.append([0, i, j, 0])",
      "mutated_line": "pq.append([-1, i, j, 0])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([-1, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pq.append([0, i, j, 0])",
      "mutated_line": "pq.append([1, i, j, 0])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([1, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pq.append([0, i, j, 0])",
      "mutated_line": "pq.append([0, i, j, 1])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 1])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pq.append([0, i, j, 0])",
      "mutated_line": "pq.append([0, i, j, -1])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, -1])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pq.append([0, i, j, 0])",
      "mutated_line": "pq.append([0, i, j, 1])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 1])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pq.append([0, i, j, 1])",
      "mutated_line": "pq.append([1, i, j, 1])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([1, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pq.append([0, i, j, 1])",
      "mutated_line": "pq.append([-1, i, j, 1])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([-1, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pq.append([0, i, j, 1])",
      "mutated_line": "pq.append([1, i, j, 1])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([1, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pq.append([0, i, j, 1])",
      "mutated_line": "pq.append([0, i, j, 2])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 2])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pq.append([0, i, j, 1])",
      "mutated_line": "pq.append([0, i, j, 0])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 0])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pq.append([0, i, j, 1])",
      "mutated_line": "pq.append([0, i, j, 0])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 0])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pq.append([0, i, j, 1])",
      "mutated_line": "pq.append([0, i, j, -1])",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, -1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if not (0 <= h < h and 0 <= w < w):",
      "mutated_line": "if not (1 <= h < h and 0 <= w < w):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (1 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if not (0 <= h < h and 0 <= w < w):",
      "mutated_line": "if not (-1 <= h < h and 0 <= w < w):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (-1 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if not (0 <= h < h and 0 <= w < w):",
      "mutated_line": "if not (1 <= h < h and 0 <= w < w):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (1 <= h < h and 0 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if not (0 <= h < h and 0 <= w < w):",
      "mutated_line": "if not (0 <= h < h and 1 <= w < w):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 1 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if not (0 <= h < h and 0 <= w < w):",
      "mutated_line": "if not (0 <= h < h and -1 <= w < w):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and -1 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if not (0 <= h < h and 0 <= w < w):",
      "mutated_line": "if not (0 <= h < h and 1 <= w < w):",
      "code": "import heapq\nimport copy\n\ndef calculate_minimum_climbing_time(w, h, cliff_data):\n    dy = [-2, -1, 0, 1, 2, -1, 0, 1, 0]\n    rx = [1, 1, 1, 1, 1, 2, 2, 2, 3]\n    lx = [-1, -1, -1, -1, -1, -2, -2, -2, -3]\n    inf = 1000000007\n    dp = [[[inf] * 2 for _ in range(w)] for _ in range(h)]\n    pq = []\n    for i in range(h):\n        for j in range(w):\n            if cliff_data[i][j] == 'S':\n                pq.append([0, i, j, 0])\n                dp[i][j][0] = 0\n                pq.append([0, i, j, 1])\n                dp[i][j][1] = 0\n    heapq.heapify(pq)\n    res = inf\n    while pq:\n        (cost, i, j, b) = heapq.heappop(pq)\n        if dp[i][j][b] < cost:\n            continue\n        if cliff_data[i][j] == 'T':\n            res = cost\n            break\n        for k in range(9):\n            h = i + dy[k]\n            if b:\n                w = j + lx[k]\n            else:\n                w = j + rx[k]\n            bb = (b + 1) % 2\n            if not (0 <= h < h and 1 <= w < w):\n                continue\n            if cliff_data[h][w] == 'X':\n                continue\n            if '1' <= cliff_data[i][j] <= '9':\n                ncost = cost + int(cliff_data[i][j])\n            else:\n                ncost = copy.copy(cost)\n            if ncost < dp[h][w][bb]:\n                dp[h][w][bb] = ncost\n                heapq.heappush(pq, [ncost, h, w, bb])\n    return res if res != inf else -1"
    }
  ]
}