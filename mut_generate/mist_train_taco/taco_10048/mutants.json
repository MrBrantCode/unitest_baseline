{
  "task_id": "taco_10048",
  "entry_point": "generate_visit_order",
  "mutant_count": 94,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:",
      "mutated_line": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] & int:",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] & int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:",
      "mutated_line": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] ^ int:",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] ^ int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n * m == 1:",
      "mutated_line": "if n * m != 1:",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m != 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if n * m == 1:",
      "mutated_line": "if n / m == 1:",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n / m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if n * m == 1:",
      "mutated_line": "if n + m == 1:",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n + m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if n * m == 1:",
      "mutated_line": "if n ** m == 1:",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n ** m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n * m == 1:",
      "mutated_line": "if n * m == 2:",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 2:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n * m == 1:",
      "mutated_line": "if n * m == 0:",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 0:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n * m == 1:",
      "mutated_line": "if n * m == 0:",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 0:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n * m == 1:",
      "mutated_line": "if n * m == -1:",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == -1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for row in range((n + 1) // 2):",
      "mutated_line": "for row in range((n + 1) / 2):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) / 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for row in range((n + 1) // 2):",
      "mutated_line": "for row in range((n + 1) * 2):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) * 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "rev_row = n - row",
      "mutated_line": "rev_row = n + row",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n + row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "rev_row = n - row",
      "mutated_line": "rev_row = n * row",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n * row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return res if len(res) == n * m else -1",
      "mutated_line": "return res if len(res) != n * m else -1",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) != n * m else -1"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "return res if len(res) == n * m else -1",
      "mutated_line": "return res if len(res) == n * m else +1",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else +1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for row in range((n + 1) // 2):",
      "mutated_line": "for row in range((n - 1) // 2):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n - 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for row in range((n + 1) // 2):",
      "mutated_line": "for row in range(n * 1 // 2):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range(n * 1 // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for row in range((n + 1) // 2):",
      "mutated_line": "for row in range((n + 1) // 3):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 3):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for row in range((n + 1) // 2):",
      "mutated_line": "for row in range((n + 1) // 1):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 1):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for row in range((n + 1) // 2):",
      "mutated_line": "for row in range((n + 1) // 0):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 0):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for row in range((n + 1) // 2):",
      "mutated_line": "for row in range((n + 1) // 1):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 1):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for row in range((n + 1) // 2):",
      "mutated_line": "for row in range((n + 1) // -2):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // -2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row == row + 1 else (m + 1) // 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row == row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) / 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) / 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) * 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) * 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return res if len(res) == n * m else -1",
      "mutated_line": "return res if len(res) == n / m else -1",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n / m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return res if len(res) == n * m else -1",
      "mutated_line": "return res if len(res) == n + m else -1",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n + m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return res if len(res) == n * m else -1",
      "mutated_line": "return res if len(res) == n ** m else -1",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n ** m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return res if len(res) == n * m else -1",
      "mutated_line": "return res if len(res) == n * m else -2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -2"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return res if len(res) == n * m else -1",
      "mutated_line": "return res if len(res) == n * m else -0",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return res if len(res) == n * m else -1",
      "mutated_line": "return res if len(res) == n * m else -0",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return res if len(res) == n * m else -1",
      "mutated_line": "return res if len(res) == n * m else --1",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else --1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return [(1, 1)]",
      "mutated_line": "return [(2, 1)]",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(2, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return [(1, 1)]",
      "mutated_line": "return [(0, 1)]",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(0, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return [(1, 1)]",
      "mutated_line": "return [(0, 1)]",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(0, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return [(1, 1)]",
      "mutated_line": "return [(-1, 1)]",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(-1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return [(1, 1)]",
      "mutated_line": "return [(1, 2)]",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 2)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return [(1, 1)]",
      "mutated_line": "return [(1, 0)]",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 0)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return [(1, 1)]",
      "mutated_line": "return [(1, 0)]",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 0)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return [(1, 1)]",
      "mutated_line": "return [(1, -1)]",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, -1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for row in range((n + 1) // 2):",
      "mutated_line": "for row in range((n + 2) // 2):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 2) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for row in range((n + 1) // 2):",
      "mutated_line": "for row in range((n + 0) // 2):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 0) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for row in range((n + 1) // 2):",
      "mutated_line": "for row in range((n + 0) // 2):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 0) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for row in range((n + 1) // 2):",
      "mutated_line": "for row in range((n + -1) // 2):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + -1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row - 1 else (m + 1) // 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row - 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row * 1 else (m + 1) // 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row * 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 1 else (m - 1) // 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m - 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 1 else m * 1 // 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else m * 1 // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 3",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 3\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 1",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 1\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 0",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 0\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 1",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 1\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // -2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // -2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + 1 == rev_row or i + 1 == m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row or i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 2 else (m + 1) // 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 2 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 0 else (m + 1) // 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 0 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 0 else (m + 1) // 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 0 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + -1 else (m + 1) // 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + -1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 1 else (m + 2) // 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 2) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 1 else (m + 0) // 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 0) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 1 else (m + 0) // 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 0) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cell_cnt = m if rev_row != row + 1 else (m + 1) // 2",
      "mutated_line": "cell_cnt = m if rev_row != row + 1 else (m + -1) // 2",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + -1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "res.append((row + 1, i + 1))",
      "mutated_line": "res.append((row - 1, i + 1))",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row - 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "res.append((row + 1, i + 1))",
      "mutated_line": "res.append((row * 1, i + 1))",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row * 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "res.append((row + 1, i + 1))",
      "mutated_line": "res.append((row + 1, i - 1))",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i - 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "res.append((row + 1, i + 1))",
      "mutated_line": "res.append((row + 1, i * 1))",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i * 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + 1 != rev_row and i + 1 == m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 != rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + 1 == rev_row and i + 1 != m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 != m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res.append((row + 1, i + 1))",
      "mutated_line": "res.append((row + 2, i + 1))",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 2, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res.append((row + 1, i + 1))",
      "mutated_line": "res.append((row + 0, i + 1))",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 0, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res.append((row + 1, i + 1))",
      "mutated_line": "res.append((row + 0, i + 1))",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 0, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res.append((row + 1, i + 1))",
      "mutated_line": "res.append((row + -1, i + 1))",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + -1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res.append((row + 1, i + 1))",
      "mutated_line": "res.append((row + 1, i + 2))",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 2))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res.append((row + 1, i + 1))",
      "mutated_line": "res.append((row + 1, i + 0))",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 0))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res.append((row + 1, i + 1))",
      "mutated_line": "res.append((row + 1, i + 0))",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 0))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res.append((row + 1, i + 1))",
      "mutated_line": "res.append((row + 1, i + -1))",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + -1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row - 1 == rev_row and i + 1 == m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row - 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row * 1 == rev_row and i + 1 == m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row * 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + 1 == rev_row and i - 1 == m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i - 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + 1 == rev_row and i * 1 == m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i * 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + 1 == rev_row and i + 1 == m + i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m + i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + 1 == rev_row and i + 1 == m * i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m * i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "res.append((rev_row, m - i))",
      "mutated_line": "res.append((rev_row, m + i))",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m + i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "res.append((rev_row, m - i))",
      "mutated_line": "res.append((rev_row, m * i))",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m * i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + 2 == rev_row and i + 1 == m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 2 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + 0 == rev_row and i + 1 == m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 0 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + 0 == rev_row and i + 1 == m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 0 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + -1 == rev_row and i + 1 == m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + -1 == rev_row and i + 1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + 1 == rev_row and i + 2 == m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 2 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + 1 == rev_row and i + 0 == m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 0 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + 1 == rev_row and i + 0 == m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + 0 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (row + 1 == rev_row and i + 1 == m - i):",
      "mutated_line": "if not (row + 1 == rev_row and i + -1 == m - i):",
      "code": "def generate_visit_order(n: int, m: int) -> list[tuple[int, int]] | int:\n    \"\"\"\n    Generates the order of visiting cells in an n x m field such that each cell is visited exactly once\n    and no vector of jumps is used twice.\n\n    Args:\n        n (int): The number of rows in the field.\n        m (int): The number of columns in the field.\n\n    Returns:\n        list[tuple[int, int]] | int: A list of tuples representing the cells in the order of visiting.\n                                      If it's impossible to visit every cell exactly once, returns -1.\n    \"\"\"\n    if n * m == 1:\n        return [(1, 1)]\n    res = []\n    for row in range((n + 1) // 2):\n        rev_row = n - row\n        cell_cnt = m if rev_row != row + 1 else (m + 1) // 2\n        for i in range(cell_cnt):\n            res.append((row + 1, i + 1))\n            if not (row + 1 == rev_row and i + -1 == m - i):\n                res.append((rev_row, m - i))\n    return res if len(res) == n * m else -1"
    }
  ]
}