{
  "task_id": "taco_12952",
  "entry_point": "convert_cell_notation",
  "mutant_count": 78,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "expn = 0",
      "mutated_line": "expn = 1",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 1\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "expn = 0",
      "mutated_line": "expn = -1",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = -1\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "expn = 0",
      "mutated_line": "expn = 1",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 1\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "col_num = 0",
      "mutated_line": "col_num = 1",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 1\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "col_num = 0",
      "mutated_line": "col_num = -1",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = -1\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "col_num = 0",
      "mutated_line": "col_num = 1",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 1\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num -= (ord(char) - ord('A') + 1) * 26 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num -= (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "expn += 1",
      "mutated_line": "expn -= 1",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn -= 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if 'R' and 'C' in address and re.match(r'\\w{1}\\d+\\w{1}\\d+', address):",
      "mutated_line": "if 'R' or 'C' in address or re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' or 'C' in address or re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 1\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return -1\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 1\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "registry = {0: from_excel, 1: to_excel}",
      "mutated_line": "registry = {1: from_excel, 1: to_excel}",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {1: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "registry = {0: from_excel, 1: to_excel}",
      "mutated_line": "registry = {-1: from_excel, 1: to_excel}",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {-1: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "registry = {0: from_excel, 1: to_excel}",
      "mutated_line": "registry = {1: from_excel, 1: to_excel}",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {1: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "registry = {0: from_excel, 1: to_excel}",
      "mutated_line": "registry = {0: from_excel, 2: to_excel}",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 2: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "registry = {0: from_excel, 1: to_excel}",
      "mutated_line": "registry = {0: from_excel, 0: to_excel}",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 0: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "registry = {0: from_excel, 1: to_excel}",
      "mutated_line": "registry = {0: from_excel, 0: to_excel}",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 0: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "registry = {0: from_excel, 1: to_excel}",
      "mutated_line": "registry = {0: from_excel, -1: to_excel}",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, -1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "(row, column) = item.split('C')",
      "mutated_line": "(row, column) = item.split('')",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "excel_col = chr(mod + 65) + excel_col",
      "mutated_line": "excel_col = chr(mod + 65) - excel_col",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) - excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "excel_col = chr(mod + 65) + excel_col",
      "mutated_line": "excel_col = chr(mod + 65) * excel_col",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) * excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A') + 1) / 26 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) / 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += ord(char) - ord('A') + 1 + 26 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += ord(char) - ord('A') + 1 + 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A') + 1) ** 26 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) ** 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "expn += 1",
      "mutated_line": "expn += 2",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 2\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "expn += 1",
      "mutated_line": "expn += 0",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 0\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "expn += 1",
      "mutated_line": "expn += 0",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 0\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "expn += 1",
      "mutated_line": "expn += -1",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += -1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 'R' and 'C' in address and re.match(r'\\w{1}\\d+\\w{1}\\d+', address):",
      "mutated_line": "if '' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if '' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 'R' and 'C' in address and re.match(r'\\w{1}\\d+\\w{1}\\d+', address):",
      "mutated_line": "if 'R' and 'C' not in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' not in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 2\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 0\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 0\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return -1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "row = ''.join([s for s in item if s.isdigit()])",
      "mutated_line": "row = 'MUTATED'.join([s for s in item if s.isdigit()])",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = 'MUTATED'.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "column = excel_to_column(item.replace(row, ''))",
      "mutated_line": "column = excel_to_column(item.replace(row, 'MUTATED'))",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, 'MUTATED'))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 'R{0}C{1}'.format(row, column)",
      "mutated_line": "return ''.format(row, column)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return ''.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return '{0}{1}'.format(column, row)",
      "mutated_line": "return ''.format(column, row)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return ''.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(div, mod) = divmod(div - 1, 26)",
      "mutated_line": "(div, mod) = divmod(div + 1, 26)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div + 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(div, mod) = divmod(div - 1, 26)",
      "mutated_line": "(div, mod) = divmod(div * 1, 26)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div * 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(div, mod) = divmod(div - 1, 26)",
      "mutated_line": "(div, mod) = divmod(div - 1, 27)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 27)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(div, mod) = divmod(div - 1, 26)",
      "mutated_line": "(div, mod) = divmod(div - 1, 25)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 25)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(div, mod) = divmod(div - 1, 26)",
      "mutated_line": "(div, mod) = divmod(div - 1, 0)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 0)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(div, mod) = divmod(div - 1, 26)",
      "mutated_line": "(div, mod) = divmod(div - 1, 1)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 1)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(div, mod) = divmod(div - 1, 26)",
      "mutated_line": "(div, mod) = divmod(div - 1, -26)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, -26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A') - 1) * 26 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') - 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A')) * 1 * 26 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A')) * 1 * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A') + 1) * (26 * expn)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * (26 * expn)\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A') + 1) * (26 + expn)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * (26 + expn)\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 'R' and 'C' in address and re.match(r'\\w{1}\\d+\\w{1}\\d+', address):",
      "mutated_line": "if 'R' and '' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and '' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 'R' and 'C' in address and re.match(r'\\w{1}\\d+\\w{1}\\d+', address):",
      "mutated_line": "if 'R' and 'C' in address and re.match('', address):",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(row, column) = (int(row.replace('R', '')), int(column))",
      "mutated_line": "(row, column) = (int(row.replace('', '')), int(column))",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(row, column) = (int(row.replace('R', '')), int(column))",
      "mutated_line": "(row, column) = (int(row.replace('R', 'MUTATED')), int(column))",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', 'MUTATED')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(div, mod) = divmod(div - 1, 26)",
      "mutated_line": "(div, mod) = divmod(div - 2, 26)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 2, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(div, mod) = divmod(div - 1, 26)",
      "mutated_line": "(div, mod) = divmod(div - 0, 26)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 0, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(div, mod) = divmod(div - 1, 26)",
      "mutated_line": "(div, mod) = divmod(div - 0, 26)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 0, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(div, mod) = divmod(div - 1, 26)",
      "mutated_line": "(div, mod) = divmod(div - -1, 26)",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - -1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "excel_col = chr(mod + 65) + excel_col",
      "mutated_line": "excel_col = chr(mod - 65) + excel_col",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod - 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "excel_col = chr(mod + 65) + excel_col",
      "mutated_line": "excel_col = chr(mod * 65) + excel_col",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod * 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) + ord('A') + 1) * 26 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) + ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) * ord('A') + 1) * 26 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) * ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A') + 2) * 26 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 2) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A') + 0) * 26 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 0) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A') + 0) * 26 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 0) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A') + -1) * 26 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + -1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A') + 1) * 27 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 27 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A') + 1) * 25 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 25 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A') + 1) * 0 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 0 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A') + 1) * 1 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 1 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('A') + 1) * -26 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * -26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "excel_col = chr(mod + 65) + excel_col",
      "mutated_line": "excel_col = chr(mod + 66) + excel_col",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 66) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "excel_col = chr(mod + 65) + excel_col",
      "mutated_line": "excel_col = chr(mod + 64) + excel_col",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 64) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "excel_col = chr(mod + 65) + excel_col",
      "mutated_line": "excel_col = chr(mod + 0) + excel_col",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 0) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "excel_col = chr(mod + 65) + excel_col",
      "mutated_line": "excel_col = chr(mod + 1) + excel_col",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 1) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "excel_col = chr(mod + 65) + excel_col",
      "mutated_line": "excel_col = chr(mod + -65) + excel_col",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + -65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('A') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "col_num += (ord(char) - ord('A') + 1) * 26 ** expn",
      "mutated_line": "col_num += (ord(char) - ord('') + 1) * 26 ** expn",
      "code": "import re\n\ndef convert_cell_notation(cell_notation: str) -> str:\n    \"\"\"\n    Converts cell notation between \"RXCY\" and \"Excel\" column-row formats.\n\n    :param cell_notation: The input cell notation to be converted.\n    :return: The converted cell notation in the opposite format.\n    \"\"\"\n\n    def from_excel(item):\n        row = ''.join([s for s in item if s.isdigit()])\n        column = excel_to_column(item.replace(row, ''))\n        return 'R{0}C{1}'.format(row, column)\n\n    def to_excel(item):\n        (row, column) = item.split('C')\n        (row, column) = (int(row.replace('R', '')), int(column))\n        column = column_to_excel(column)\n        return '{0}{1}'.format(column, row)\n\n    def column_to_excel(column):\n        column = int(column)\n        excel_col = str()\n        div = column\n        while div:\n            (div, mod) = divmod(div - 1, 26)\n            excel_col = chr(mod + 65) + excel_col\n        return excel_col\n\n    def excel_to_column(column):\n        expn = 0\n        col_num = 0\n        for char in reversed(column):\n            col_num += (ord(char) - ord('') + 1) * 26 ** expn\n            expn += 1\n        return col_num\n\n    def get_type(address):\n        if 'R' and 'C' in address and re.match('\\\\w{1}\\\\d+\\\\w{1}\\\\d+', address):\n            return 1\n        return 0\n    registry = {0: from_excel, 1: to_excel}\n    return registry[get_type(cell_notation)](cell_notation)"
    }
  ]
}