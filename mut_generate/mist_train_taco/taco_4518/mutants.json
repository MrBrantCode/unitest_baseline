{
  "task_id": "taco_4518",
  "entry_point": "calculate_minimum_detonation_time",
  "mutant_count": 101,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "answer = length - 1",
      "mutated_line": "answer = length + 1",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length + 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "answer = length - 1",
      "mutated_line": "answer = length * 1",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length * 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if self.parents[i] != i:",
      "mutated_line": "if self.parents[i] == i:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] == i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if i == j:",
      "mutated_line": "if i != j:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i != j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "mines = [list(mine) + [i] for i, mine in enumerate(mines)]",
      "mutated_line": "mines = [list(mine) - [i] for (i, mine) in enumerate(mines)]",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) - [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "mines = [list(mine) + [i] for i, mine in enumerate(mines)]",
      "mutated_line": "mines = [list(mine) * [i] for (i, mine) in enumerate(mines)]",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) * [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if x == mine[0] and abs(mine[1] - y) <= k:",
      "mutated_line": "if x == mine[0] or abs(mine[1] - y) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] or abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "if y == mine[1] and abs(mine[0] - x) <= k:",
      "mutated_line": "if y == mine[1] or abs(mine[0] - x) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] or abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "answer = length - 1",
      "mutated_line": "answer = length - 2",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 2\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "answer = length - 1",
      "mutated_line": "answer = length - 0",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 0\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "answer = length - 1",
      "mutated_line": "answer = length - 0",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 0\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "answer = length - 1",
      "mutated_line": "answer = length - -1",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - -1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i == self.parents[i]:",
      "mutated_line": "if i != self.parents[i]:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i != self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if x == mine[0] and abs(mine[1] - y) <= k:",
      "mutated_line": "if x != mine[0] and abs(mine[1] - y) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x != mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if x == mine[0] and abs(mine[1] - y) <= k:",
      "mutated_line": "if x == mine[0] and abs(mine[1] - y) < k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) < k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if x == mine[0] and abs(mine[1] - y) <= k:",
      "mutated_line": "if x == mine[0] and abs(mine[1] - y) > k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) > k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if x == mine[0] and abs(mine[1] - y) <= k:",
      "mutated_line": "if x == mine[0] and abs(mine[1] - y) == k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) == k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if y == mine[1] and abs(mine[0] - x) <= k:",
      "mutated_line": "if y != mine[1] and abs(mine[0] - x) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y != mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if y == mine[1] and abs(mine[0] - x) <= k:",
      "mutated_line": "if y == mine[1] and abs(mine[0] - x) < k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) < k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if y == mine[1] and abs(mine[0] - x) <= k:",
      "mutated_line": "if y == mine[1] and abs(mine[0] - x) > k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) > k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if y == mine[1] and abs(mine[0] - x) <= k:",
      "mutated_line": "if y == mine[1] and abs(mine[0] - x) == k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) == k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[4], mine[0], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[4], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[2], mine[0], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[2], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[0], mine[0], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[0], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[1], mine[0], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[1], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[-3], mine[0], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[-3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[3], mine[1], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[1], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[3], mine[-1], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[-1], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[3], mine[1], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[1], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[3], mine[0], mine[2])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[2])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[3], mine[0], mine[0])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[0])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[3], mine[0], mine[0])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[0])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[3], mine[0], mine[-1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[-1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[4], mine[0], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[4], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[2], mine[0], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[2], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[0], mine[0], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[0], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[1], mine[0], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[1], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[-3], mine[0], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[-3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[3], mine[1], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[1], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[3], mine[-1], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[-1], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[3], mine[1], mine[1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[1], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[3], mine[0], mine[2])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[2])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[3], mine[0], mine[0])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[0])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[3], mine[0], mine[0])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[0])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "(i, x, y) = (mine[3], mine[0], mine[1])",
      "mutated_line": "(i, x, y) = (mine[3], mine[0], mine[-1])",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[-1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "answer = min(answer, max(mins[i], length - i - 2))",
      "mutated_line": "answer = min(answer, max(mins[i], length - i + 2))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i + 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "answer = min(answer, max(mins[i], length - i - 2))",
      "mutated_line": "answer = min(answer, max(mins[i], (length - i) * 2))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], (length - i) * 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == mine[0] and abs(mine[1] - y) <= k:",
      "mutated_line": "if x == mine[1] and abs(mine[1] - y) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[1] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == mine[0] and abs(mine[1] - y) <= k:",
      "mutated_line": "if x == mine[-1] and abs(mine[1] - y) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[-1] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == mine[0] and abs(mine[1] - y) <= k:",
      "mutated_line": "if x == mine[1] and abs(mine[1] - y) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[1] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if x == mine[0] and abs(mine[1] - y) <= k:",
      "mutated_line": "if x == mine[0] and abs(mine[1] + y) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] + y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if x == mine[0] and abs(mine[1] - y) <= k:",
      "mutated_line": "if x == mine[0] and abs(mine[1] * y) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] * y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "sds.union(mine[3], i)",
      "mutated_line": "sds.union(mine[4], i)",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[4], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "sds.union(mine[3], i)",
      "mutated_line": "sds.union(mine[2], i)",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[2], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "sds.union(mine[3], i)",
      "mutated_line": "sds.union(mine[0], i)",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[0], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "sds.union(mine[3], i)",
      "mutated_line": "sds.union(mine[1], i)",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[1], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "sds.union(mine[3], i)",
      "mutated_line": "sds.union(mine[-3], i)",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[-3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if y == mine[1] and abs(mine[0] - x) <= k:",
      "mutated_line": "if y == mine[2] and abs(mine[0] - x) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[2] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if y == mine[1] and abs(mine[0] - x) <= k:",
      "mutated_line": "if y == mine[0] and abs(mine[0] - x) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[0] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if y == mine[1] and abs(mine[0] - x) <= k:",
      "mutated_line": "if y == mine[0] and abs(mine[0] - x) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[0] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if y == mine[1] and abs(mine[0] - x) <= k:",
      "mutated_line": "if y == mine[-1] and abs(mine[0] - x) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[-1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if y == mine[1] and abs(mine[0] - x) <= k:",
      "mutated_line": "if y == mine[1] and abs(mine[0] + x) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] + x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if y == mine[1] and abs(mine[0] - x) <= k:",
      "mutated_line": "if y == mine[1] and abs(mine[0] * x) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] * x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "sds.union(mine[3], i)",
      "mutated_line": "sds.union(mine[4], i)",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[4], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "sds.union(mine[3], i)",
      "mutated_line": "sds.union(mine[2], i)",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[2], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "sds.union(mine[3], i)",
      "mutated_line": "sds.union(mine[0], i)",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[0], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "sds.union(mine[3], i)",
      "mutated_line": "sds.union(mine[1], i)",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[1], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "sds.union(mine[3], i)",
      "mutated_line": "sds.union(mine[-3], i)",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[-3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "answer = min(answer, max(mins[i], length - i - 2))",
      "mutated_line": "answer = min(answer, max(mins[i], length + i - 2))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length + i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "answer = min(answer, max(mins[i], length - i - 2))",
      "mutated_line": "answer = min(answer, max(mins[i], length * i - 2))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length * i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "answer = min(answer, max(mins[i], length - i - 2))",
      "mutated_line": "answer = min(answer, max(mins[i], length - i - 3))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 3))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "answer = min(answer, max(mins[i], length - i - 2))",
      "mutated_line": "answer = min(answer, max(mins[i], length - i - 1))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 1))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "answer = min(answer, max(mins[i], length - i - 2))",
      "mutated_line": "answer = min(answer, max(mins[i], length - i - 0))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 0))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "answer = min(answer, max(mins[i], length - i - 2))",
      "mutated_line": "answer = min(answer, max(mins[i], length - i - 1))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 1))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "answer = min(answer, max(mins[i], length - i - 2))",
      "mutated_line": "answer = min(answer, max(mins[i], length - i - -2))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - -2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sds = SDS(n, list(map(lambda x: x[2], mines)))",
      "mutated_line": "sds = SDS(n, list(map(lambda x: x[3], mines)))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[3], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sds = SDS(n, list(map(lambda x: x[2], mines)))",
      "mutated_line": "sds = SDS(n, list(map(lambda x: x[1], mines)))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[1], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sds = SDS(n, list(map(lambda x: x[2], mines)))",
      "mutated_line": "sds = SDS(n, list(map(lambda x: x[0], mines)))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[0], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sds = SDS(n, list(map(lambda x: x[2], mines)))",
      "mutated_line": "sds = SDS(n, list(map(lambda x: x[1], mines)))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[1], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sds = SDS(n, list(map(lambda x: x[2], mines)))",
      "mutated_line": "sds = SDS(n, list(map(lambda x: x[-2], mines)))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[-2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mines.sort(key=lambda x: (x[0], x[1]))",
      "mutated_line": "mines.sort(key=lambda x: (x[1], x[1]))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[1], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mines.sort(key=lambda x: (x[0], x[1]))",
      "mutated_line": "mines.sort(key=lambda x: (x[-1], x[1]))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[-1], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mines.sort(key=lambda x: (x[0], x[1]))",
      "mutated_line": "mines.sort(key=lambda x: (x[1], x[1]))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[1], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mines.sort(key=lambda x: (x[0], x[1]))",
      "mutated_line": "mines.sort(key=lambda x: (x[0], x[2]))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[2]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mines.sort(key=lambda x: (x[0], x[1]))",
      "mutated_line": "mines.sort(key=lambda x: (x[0], x[0]))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mines.sort(key=lambda x: (x[0], x[1]))",
      "mutated_line": "mines.sort(key=lambda x: (x[0], x[0]))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mines.sort(key=lambda x: (x[0], x[1]))",
      "mutated_line": "mines.sort(key=lambda x: (x[0], x[-1]))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[-1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mines.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "mines.sort(key=lambda x: (x[2], x[0]))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[2], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mines.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "mines.sort(key=lambda x: (x[0], x[0]))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[0], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mines.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "mines.sort(key=lambda x: (x[0], x[0]))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[0], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mines.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "mines.sort(key=lambda x: (x[-1], x[0]))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[-1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mines.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "mines.sort(key=lambda x: (x[1], x[1]))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mines.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "mines.sort(key=lambda x: (x[1], x[-1]))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[-1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mines.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "mines.sort(key=lambda x: (x[1], x[1]))",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == mine[0] and abs(mine[1] - y) <= k:",
      "mutated_line": "if x == mine[0] and abs(mine[2] - y) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[2] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == mine[0] and abs(mine[1] - y) <= k:",
      "mutated_line": "if x == mine[0] and abs(mine[0] - y) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[0] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == mine[0] and abs(mine[1] - y) <= k:",
      "mutated_line": "if x == mine[0] and abs(mine[0] - y) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[0] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == mine[0] and abs(mine[1] - y) <= k:",
      "mutated_line": "if x == mine[0] and abs(mine[-1] - y) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[-1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[0] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if y == mine[1] and abs(mine[0] - x) <= k:",
      "mutated_line": "if y == mine[1] and abs(mine[1] - x) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[1] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if y == mine[1] and abs(mine[0] - x) <= k:",
      "mutated_line": "if y == mine[1] and abs(mine[-1] - x) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[-1] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if y == mine[1] and abs(mine[0] - x) <= k:",
      "mutated_line": "if y == mine[1] and abs(mine[1] - x) <= k:",
      "code": "def calculate_minimum_detonation_time(t, test_cases):\n\n    class SDS:\n\n        def __init__(self, n, mins):\n            self.n = n\n            self.parents = [i for i in range(n)]\n            self.mins = mins\n\n        def find(self, i):\n            if self.parents[i] != i:\n                self.parents[i] = self.find(self.parents[i])\n            return self.parents[i]\n\n        def union(self, i, j):\n            (i, j) = (self.find(i), self.find(j))\n            if i == j:\n                return\n            self.parents[j] = i\n            self.mins[i] = min(self.mins[j], self.mins[i])\n\n        def tolist(self):\n            result = []\n            for i in range(self.n):\n                if i == self.parents[i]:\n                    result.append(self.mins[i])\n            return (sorted(result), len(result))\n    result = []\n    for test_case in test_cases:\n        (n, k, mines) = test_case\n        sds = SDS(n, list(map(lambda x: x[2], mines)))\n        mines = [list(mine) + [i] for (i, mine) in enumerate(mines)]\n        mines.sort(key=lambda x: (x[0], x[1]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if x == mine[0] and abs(mine[1] - y) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        mines.sort(key=lambda x: (x[1], x[0]))\n        (i, x, y) = (None, None, None)\n        for mine in mines:\n            if y == mine[1] and abs(mine[1] - x) <= k:\n                sds.union(mine[3], i)\n            (i, x, y) = (mine[3], mine[0], mine[1])\n        (mins, length) = sds.tolist()\n        answer = length - 1\n        for i in range(length):\n            answer = min(answer, max(mins[i], length - i - 2))\n        result.append(answer)\n    return result"
    }
  ]
}