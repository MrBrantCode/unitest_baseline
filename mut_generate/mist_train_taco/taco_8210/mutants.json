{
  "task_id": "taco_8210",
  "entry_point": "minimum_explosions_needed",
  "mutant_count": 71,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 1\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = -1\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 1\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while l < r:",
      "mutated_line": "while l <= r:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l <= r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while l < r:",
      "mutated_line": "while l >= r:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l >= r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while l < r:",
      "mutated_line": "while l != r:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l != r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(l, r) = (1, max(healths) // B + 1)",
      "mutated_line": "(l, r) = (2, max(healths) // B + 1)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (2, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(l, r) = (1, max(healths) // B + 1)",
      "mutated_line": "(l, r) = (0, max(healths) // B + 1)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (0, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(l, r) = (1, max(healths) // B + 1)",
      "mutated_line": "(l, r) = (0, max(healths) // B + 1)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (0, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(l, r) = (1, max(healths) // B + 1)",
      "mutated_line": "(l, r) = (-1, max(healths) // B + 1)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (-1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "(l, r) = (1, max(healths) // B + 1)",
      "mutated_line": "(l, r) = (1, max(healths) // B - 1)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B - 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "(l, r) = (1, max(healths) // B + 1)",
      "mutated_line": "(l, r) = (1, max(healths) // B * 1)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B * 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) / 2",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) / 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) * 2",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) * 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if c >= 0:",
      "mutated_line": "if c > 0:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c > 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if c >= 0:",
      "mutated_line": "if c < 0:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c < 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if c >= 0:",
      "mutated_line": "if c == 0:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c == 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "(l, r) = (1, max(healths) // B + 1)",
      "mutated_line": "(l, r) = (1, max(healths) / B + 1)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) / B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "(l, r) = (1, max(healths) // B + 1)",
      "mutated_line": "(l, r) = (1, max(healths) * B + 1)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) * B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(l, r) = (1, max(healths) // B + 1)",
      "mutated_line": "(l, r) = (1, max(healths) // B + 2)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 2)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(l, r) = (1, max(healths) // B + 1)",
      "mutated_line": "(l, r) = (1, max(healths) // B + 0)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 0)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(l, r) = (1, max(healths) // B + 1)",
      "mutated_line": "(l, r) = (1, max(healths) // B + 0)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 0)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(l, r) = (1, max(healths) // B + 1)",
      "mutated_line": "(l, r) = (1, max(healths) // B + -1)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + -1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l - r) // 2",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l - r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = l * r // 2",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = l * r // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 3",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 3\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 1\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 0",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 0\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 1\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // -2",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // -2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "t = healths[i] - m * B",
      "mutated_line": "t = healths[i] + m * B",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] + m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "t = healths[i] - m * B",
      "mutated_line": "t = healths[i] * (m * B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] * (m * B)\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if t > 0:",
      "mutated_line": "if t >= 0:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t >= 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if t > 0:",
      "mutated_line": "if t <= 0:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t <= 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if t > 0:",
      "mutated_line": "if t != 0:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t != 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c += (t + A - B - 1) // (A - B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c += (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if c >= 0:",
      "mutated_line": "if c >= 1:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 1:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if c >= 0:",
      "mutated_line": "if c >= -1:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= -1:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if c >= 0:",
      "mutated_line": "if c >= 1:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 1:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "l = m + 1",
      "mutated_line": "l = m - 1",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m - 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "l = m + 1",
      "mutated_line": "l = m * 1",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m * 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "t = healths[i] - m * B",
      "mutated_line": "t = healths[i] - m / B",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m / B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "t = healths[i] - m * B",
      "mutated_line": "t = healths[i] - (m + B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - (m + B)\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "t = healths[i] - m * B",
      "mutated_line": "t = healths[i] - m ** B",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m ** B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if t > 0:",
      "mutated_line": "if t > 1:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 1:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if t > 0:",
      "mutated_line": "if t > -1:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > -1:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if t > 0:",
      "mutated_line": "if t > 1:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 1:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c -= (t + A - B - 1) / (A - B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) / (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c -= (t + A - B - 1) * (A - B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) * (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if c < 0:",
      "mutated_line": "if c <= 0:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c <= 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if c < 0:",
      "mutated_line": "if c >= 0:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c >= 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if c < 0:",
      "mutated_line": "if c != 0:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c != 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "l = m + 1",
      "mutated_line": "l = m + 2",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 2\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "l = m + 1",
      "mutated_line": "l = m + 0",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 0\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "l = m + 1",
      "mutated_line": "l = m + 0",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 0\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "l = m + 1",
      "mutated_line": "l = m + -1",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + -1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c -= (t + A - B + 1) // (A - B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B + 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c -= (t + A - B) * 1 // (A - B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B) * 1 // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c -= (t + A - B - 1) // (A + B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A + B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c -= (t + A - B - 1) // (A * B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A * B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if c < 0:",
      "mutated_line": "if c < 1:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 1:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if c < 0:",
      "mutated_line": "if c < -1:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < -1:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if c < 0:",
      "mutated_line": "if c < 1:",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 1) // (A - B)\n                if c < 1:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c -= (t + A + B - 1) // (A - B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A + B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c -= ((t + A) * B - 1) // (A - B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= ((t + A) * B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c -= (t + A - B - 2) // (A - B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 2) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c -= (t + A - B - 0) // (A - B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 0) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c -= (t + A - B - 0) // (A - B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - 0) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c -= (t + A - B - -1) // (A - B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t + A - B - -1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c -= (t - A - B - 1) // (A - B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t - A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "c -= (t + A - B - 1) // (A - B)",
      "mutated_line": "c -= (t * A - B - 1) // (A - B)",
      "code": "def minimum_explosions_needed(N, A, B, healths):\n    healths.sort()\n    ans = 0\n    (l, r) = (1, max(healths) // B + 1)\n    while l < r:\n        m = (l + r) // 2\n        c = m\n        for i in range(N):\n            t = healths[i] - m * B\n            if t > 0:\n                c -= (t * A - B - 1) // (A - B)\n                if c < 0:\n                    break\n        if c >= 0:\n            r = m\n        else:\n            l = m + 1\n    return l"
    }
  ]
}