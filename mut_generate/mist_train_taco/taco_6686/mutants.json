{
  "task_id": "taco_6686",
  "entry_point": "find_min_cycle_weight",
  "mutant_count": 56,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "k = 0",
      "mutated_line": "k = 1",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 1\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "k = 0",
      "mutated_line": "k = -1",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = -1\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "k = 0",
      "mutated_line": "k = 1",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 1\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "last = N - 2",
      "mutated_line": "last = N + 2",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N + 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "last = N - 2",
      "mutated_line": "last = N * 2",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N * 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "t = s[k] + sum(rest)",
      "mutated_line": "t = s[k] - sum(rest)",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] - sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "t = s[k] + sum(rest)",
      "mutated_line": "t = s[k] * sum(rest)",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] * sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "all_values = [(A[i], i, 0) for i in range(N)]",
      "mutated_line": "all_values = [(A[i], i, 1) for i in range(N)]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 1) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "all_values = [(A[i], i, 0) for i in range(N)]",
      "mutated_line": "all_values = [(A[i], i, -1) for i in range(N)]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, -1) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "all_values = [(A[i], i, 0) for i in range(N)]",
      "mutated_line": "all_values = [(A[i], i, 1) for i in range(N)]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 1) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "last = N - 2",
      "mutated_line": "last = N - 3",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 3\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "last = N - 2",
      "mutated_line": "last = N - 1",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 1\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "last = N - 2",
      "mutated_line": "last = N - 0",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 0\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "last = N - 2",
      "mutated_line": "last = N - 1",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 1\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "last = N - 2",
      "mutated_line": "last = N - -2",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - -2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if index < last:",
      "mutated_line": "if index <= last:",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index <= last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if index < last:",
      "mutated_line": "if index >= last:",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index >= last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if index < last:",
      "mutated_line": "if index != last:",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index != last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "last += 1",
      "mutated_line": "last -= 1",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last -= 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k -= 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "all_values.extend([(B[i], i, 1) for i in range(N)])",
      "mutated_line": "all_values.extend([(B[i], i, 2) for i in range(N)])",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 2) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "all_values.extend([(B[i], i, 1) for i in range(N)])",
      "mutated_line": "all_values.extend([(B[i], i, 0) for i in range(N)])",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 0) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "all_values.extend([(B[i], i, 1) for i in range(N)])",
      "mutated_line": "all_values.extend([(B[i], i, 0) for i in range(N)])",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 0) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "all_values.extend([(B[i], i, 1) for i in range(N)])",
      "mutated_line": "all_values.extend([(B[i], i, -1) for i in range(N)])",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, -1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "last += 1",
      "mutated_line": "last += 2",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 2\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "last += 1",
      "mutated_line": "last += 0",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 0\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "last += 1",
      "mutated_line": "last += 0",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 0\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "last += 1",
      "mutated_line": "last += -1",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += -1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 2\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 0\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 0\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += -1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "mutated_line": "first_values = [set(all_values[:N + 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N + 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "mutated_line": "first_values = [set(all_values[:N * 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N * 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "mutated_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N + 1]), set(all_values[:N])]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N + 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "mutated_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N * 1]), set(all_values[:N])]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N * 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "s = [sum([t[0] for t in v]) for v in first_values]",
      "mutated_line": "s = [sum([t[1] for t in v]) for v in first_values]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[1] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "s = [sum([t[0] for t in v]) for v in first_values]",
      "mutated_line": "s = [sum([t[-1] for t in v]) for v in first_values]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[-1] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "s = [sum([t[0] for t in v]) for v in first_values]",
      "mutated_line": "s = [sum([t[1] for t in v]) for v in first_values]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[1] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "mutated_line": "first_values = [set(all_values[:N - 3]), set(all_values[:N - 1]), set(all_values[:N])]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 3]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "mutated_line": "first_values = [set(all_values[:N - 1]), set(all_values[:N - 1]), set(all_values[:N])]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 1]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "mutated_line": "first_values = [set(all_values[:N - 0]), set(all_values[:N - 1]), set(all_values[:N])]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 0]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "mutated_line": "first_values = [set(all_values[:N - 1]), set(all_values[:N - 1]), set(all_values[:N])]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 1]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "mutated_line": "first_values = [set(all_values[:N - -2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - -2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "mutated_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 2]), set(all_values[:N])]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 2]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "mutated_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 0]), set(all_values[:N])]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 0]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "mutated_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 0]), set(all_values[:N])]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 0]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]",
      "mutated_line": "first_values = [set(all_values[:N - 2]), set(all_values[:N - -1]), set(all_values[:N])]",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - -1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])",
      "mutated_line": "indices = sorted([(index_of_value[A[i], i, 1], A[i]), (index_of_value[B[i], i, 1], B[i])])",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 1], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])",
      "mutated_line": "indices = sorted([(index_of_value[A[i], i, -1], A[i]), (index_of_value[B[i], i, 1], B[i])])",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, -1], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])",
      "mutated_line": "indices = sorted([(index_of_value[A[i], i, 1], A[i]), (index_of_value[B[i], i, 1], B[i])])",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 1], A[i]), (index_of_value[B[i], i, 1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])",
      "mutated_line": "indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 2], B[i])])",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 2], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])",
      "mutated_line": "indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 0], B[i])])",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 0], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])",
      "mutated_line": "indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 0], B[i])])",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 0], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, 1], B[i])])",
      "mutated_line": "indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, -1], B[i])])",
      "code": "def find_min_cycle_weight(N, A, B):\n    \"\"\"\n    Finds the minimum total weight of the edges in a directed cycle that visits every vertex exactly once in a directed weighted graph.\n\n    Parameters:\n    - N (int): The number of vertices.\n    - A (list of int): A list of integers representing the first values on each vertex.\n    - B (list of int): A list of integers representing the second values on each vertex.\n\n    Returns:\n    - int: The minimum total weight of the edges in the cycle.\n    \"\"\"\n    res = sum(A)\n    res = min(res, sum(B))\n    all_values = [(A[i], i, 0) for i in range(N)]\n    all_values.extend([(B[i], i, 1) for i in range(N)])\n    all_values.sort()\n    index_of_value = {v: i for (i, v) in enumerate(all_values)}\n    first_values = [set(all_values[:N - 2]), set(all_values[:N - 1]), set(all_values[:N])]\n    s = [sum([t[0] for t in v]) for v in first_values]\n    for i in range(N):\n        rest = []\n        k = 0\n        last = N - 2\n        indices = sorted([(index_of_value[A[i], i, 0], A[i]), (index_of_value[B[i], i, -1], B[i])])\n        for (index, value) in indices:\n            if index < last:\n                last += 1\n                k += 1\n            else:\n                rest.append(value)\n        t = s[k] + sum(rest)\n        res = min(res, t)\n    return res"
    }
  ]
}