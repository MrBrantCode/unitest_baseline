{
  "task_id": "taco_10962",
  "entry_point": "is_k_compression_permutation",
  "mutant_count": 20,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n - k + 1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if k > n:",
      "mutated_line": "if k >= n:",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k >= n:\n        return False\n    k_compression = []\n    for i in range(n - k + 1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if k > n:",
      "mutated_line": "if k <= n:",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k <= n:\n        return False\n    k_compression = []\n    for i in range(n - k + 1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if k > n:",
      "mutated_line": "if k != n:",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k != n:\n        return False\n    k_compression = []\n    for i in range(n - k + 1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):",
      "mutated_line": "if len(k_compression) == len(k_compression_set) or max(k_compression_set) == len(k_compression_set):",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n - k + 1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) or max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n - k + 1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return True\n    k_compression = []\n    for i in range(n - k + 1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(n - k + 1):",
      "mutated_line": "for i in range(n - k - 1):",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n - k - 1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(n - k + 1):",
      "mutated_line": "for i in range((n - k) * 1):",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range((n - k) * 1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):",
      "mutated_line": "if len(k_compression) != len(k_compression_set) and max(k_compression_set) == len(k_compression_set):",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n - k + 1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) != len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):",
      "mutated_line": "if len(k_compression) == len(k_compression_set) and max(k_compression_set) != len(k_compression_set):",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n - k + 1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) != len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n - k + 1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return False\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(n - k + 1):",
      "mutated_line": "for i in range(n + k + 1):",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n + k + 1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(n - k + 1):",
      "mutated_line": "for i in range(n * k + 1):",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n * k + 1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - k + 1):",
      "mutated_line": "for i in range(n - k + 2):",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n - k + 2):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - k + 1):",
      "mutated_line": "for i in range(n - k + 0):",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n - k + 0):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - k + 1):",
      "mutated_line": "for i in range(n - k + 0):",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n - k + 0):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - k + 1):",
      "mutated_line": "for i in range(n - k + -1):",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n - k + -1):\n        k_compression.append(min(a[i:i + k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "k_compression.append(min(a[i:i+k]))",
      "mutated_line": "k_compression.append(min(a[i:i - k]))",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n - k + 1):\n        k_compression.append(min(a[i:i - k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "k_compression.append(min(a[i:i+k]))",
      "mutated_line": "k_compression.append(min(a[i:i * k]))",
      "code": "def is_k_compression_permutation(a, k):\n    \"\"\"\n    Determines if the k-compression array of a is a permutation.\n\n    Parameters:\n    a (list of int): The array of integers representing the rating graph.\n    k (int): The length of the contiguous subarray for which we need to find the minimum.\n\n    Returns:\n    bool: True if the k-compression array is a permutation, False otherwise.\n    \"\"\"\n    n = len(a)\n    if k > n:\n        return False\n    k_compression = []\n    for i in range(n - k + 1):\n        k_compression.append(min(a[i:i * k]))\n    k_compression_set = set(k_compression)\n    if len(k_compression) == len(k_compression_set) and max(k_compression_set) == len(k_compression_set):\n        return True\n    return False"
    }
  ]
}