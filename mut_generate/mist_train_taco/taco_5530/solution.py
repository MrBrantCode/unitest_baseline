"""
QUESTION:
Основой любой социальной сети является отношение дружбы между двумя пользователями в том или ином смысле. В одной известной социальной сети дружба симметрична, то есть если a является другом b, то b также является другом a. 

В этой же сети есть функция, которая демонстрирует множество людей, имеющих высокую вероятность быть знакомыми для пользователя. Эта функция работает следующим образом. Зафиксируем пользователя x. Пусть некоторый другой человек y, не являющийся другом x на текущий момент, является другом не менее, чем для k% друзей x. Тогда он является предполагаемым другом для x.

У каждого человека в социальной сети есть свой уникальный идентификатор — это целое число от 1 до 10^9. Вам дан список пар пользователей, являющихся друзьями. Определите для каждого упомянутого пользователя множество его предполагаемых друзей.


-----Входные данные-----

В первой строке следуют два целых числа m и k (1 ≤ m ≤ 100, 0 ≤ k ≤ 100) — количество пар друзей и необходимый процент общих друзей для того, чтобы считаться предполагаемым другом.

В последующих m строках записано по два числа a_{i}, b_{i} (1 ≤ a_{i}, b_{i} ≤ 10^9, a_{i} ≠ b_{i}), обозначающих идентификаторы пользователей, являющихся друзьями. 

Гарантируется, что каждая пара людей фигурирует в списке не более одного раза.


-----Выходные данные-----

Для всех упомянутых людей в порядке возрастания id выведите информацию о предполагаемых друзьях. Информация должна иметь вид "id:  k id_1 id_2 ... id_{k}", где id — это id самого человека, k — количество его предполагаемых друзей, а id_1, id_2, ..., id_{k} — идентификаторы его предполагаемых друзей в возрастающем порядке. 


-----Примеры-----
Входные данные
5 51
10 23
23 42
39 42
10 39
39 58

Выходные данные
10: 1 42
23: 1 39
39: 1 23
42: 1 10
58: 2 10 42

Входные данные
5 100
1 2
1 3
1 4
2 3
2 4

Выходные данные
1: 0
2: 0
3: 1 4
4: 1 3
"""

def find_potential_friends(m, k, friend_pairs):
    users = set()
    friendsof = {}
    
    # Populate the users set and friendsof dictionary
    for a, b in friend_pairs:
        users.add(a)
        users.add(b)
        if a in friendsof:
            friendsof[a].add(b)
        else:
            friendsof[a] = {b}
        if b in friendsof:
            friendsof[b].add(a)
        else:
            friendsof[b] = {a}
    
    users_sorted = sorted(users)
    potential_friends = {}
    
    for u in users_sorted:
        this_friends = friendsof[u]
        possible = []
        
        for v in users_sorted:
            if v in this_friends or v == u:
                continue
            common = friendsof[v].intersection(this_friends)
            if len(common) * 100 >= k * len(this_friends):
                possible.append(v)
        
        potential_friends[u] = sorted(possible)
    
    return potential_friends