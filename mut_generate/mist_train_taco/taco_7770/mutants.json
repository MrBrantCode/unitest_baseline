{
  "task_id": "taco_7770",
  "entry_point": "minimum_time_to_reach_end",
  "mutant_count": 87,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = grid[0][0]",
      "mutated_line": "ans = grid[0][1]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][1]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = grid[0][0]",
      "mutated_line": "ans = grid[0][-1]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][-1]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = grid[0][0]",
      "mutated_line": "ans = grid[0][1]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][1]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i == n - 1 or j == n - 1:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 or j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = grid[0][0]",
      "mutated_line": "ans = grid[1][0]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[1][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = grid[0][0]",
      "mutated_line": "ans = grid[-1][0]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[-1][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = grid[0][0]",
      "mutated_line": "ans = grid[1][0]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[1][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(hp, [grid[0][0], 0, 0])",
      "mutated_line": "heapq.heappush(hp, [grid[0][0], 1, 0])",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 1, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(hp, [grid[0][0], 0, 0])",
      "mutated_line": "heapq.heappush(hp, [grid[0][0], -1, 0])",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], -1, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(hp, [grid[0][0], 0, 0])",
      "mutated_line": "heapq.heappush(hp, [grid[0][0], 1, 0])",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 1, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(hp, [grid[0][0], 0, 0])",
      "mutated_line": "heapq.heappush(hp, [grid[0][0], 0, 1])",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 1])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(hp, [grid[0][0], 0, 0])",
      "mutated_line": "heapq.heappush(hp, [grid[0][0], 0, -1])",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, -1])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(hp, [grid[0][0], 0, 0])",
      "mutated_line": "heapq.heappush(hp, [grid[0][0], 0, 1])",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 1])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[1, 1], [0, -1], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[1, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[-1, 1], [0, -1], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[-1, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[1, 1], [0, -1], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[1, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 2], [0, -1], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 2], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 0], [0, -1], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 0], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 0], [0, -1], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 0], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, -1], [0, -1], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, -1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [1, -1], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [1, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [-1, -1], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [-1, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [1, -1], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [1, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, +1], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, +1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [2, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [2, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [0, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [0, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [0, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [0, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [-1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [-1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [1, 1], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 1], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [1, -1], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, -1], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [1, 1], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 1], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [1, 0], [+1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [+1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 1]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 1]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, -1]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, -1]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 1]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 1]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited.add((0, 0))",
      "mutated_line": "visited.add((1, 0))",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((1, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited.add((0, 0))",
      "mutated_line": "visited.add((-1, 0))",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((-1, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited.add((0, 0))",
      "mutated_line": "visited.add((1, 0))",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((1, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited.add((0, 0))",
      "mutated_line": "visited.add((0, 1))",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 1))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited.add((0, 0))",
      "mutated_line": "visited.add((0, -1))",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, -1))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited.add((0, 0))",
      "mutated_line": "visited.add((0, 1))",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 1))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i != n - 1 and j == n - 1:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i != n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i == n - 1 and j != n - 1:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j != n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = i + d1",
      "mutated_line": "x = i - d1",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i - d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = i + d1",
      "mutated_line": "x = i * d1",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i * d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = j + d2",
      "mutated_line": "y = j - d2",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j - d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = j + d2",
      "mutated_line": "y = j * d2",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j * d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if 0 <= x < n and 0 <= y < n and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < n or 0 <= y < n or (x, y) not in visited:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n or 0 <= y < n or (x, y) not in visited:\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(hp, [grid[0][0], 0, 0])",
      "mutated_line": "heapq.heappush(hp, [grid[0][1], 0, 0])",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][1], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(hp, [grid[0][0], 0, 0])",
      "mutated_line": "heapq.heappush(hp, [grid[0][-1], 0, 0])",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][-1], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(hp, [grid[0][0], 0, 0])",
      "mutated_line": "heapq.heappush(hp, [grid[0][1], 0, 0])",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][1], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -2], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -2], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -0], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -0], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -0], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -0], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, --1], [1, 0], [-1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, --1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [1, 0], [-2, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-2, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [1, 0], [-0, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-0, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [1, 0], [-0, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-0, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
      "mutated_line": "directions = [[0, 1], [0, -1], [1, 0], [--1, 0]]",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [--1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i == n + 1 and j == n - 1:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n + 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i == n * 1 and j == n - 1:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n * 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i == n - 1 and j == n + 1:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n + 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i == n - 1 and j == n * 1:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n * 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= x < n and 0 <= y < n and (x, y) not in visited:",
      "mutated_line": "if 0 < x < n and 0 <= y < n and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 < x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= x < n and 0 <= y < n and (x, y) not in visited:",
      "mutated_line": "if 0 > x < n and 0 <= y < n and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 > x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= x < n and 0 <= y < n and (x, y) not in visited:",
      "mutated_line": "if 0 == x < n and 0 <= y < n and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 == x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= x < n and 0 <= y < n and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < n and 0 < y < n and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 < y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= x < n and 0 <= y < n and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < n and 0 > y < n and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 > y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= x < n and 0 <= y < n and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < n and 0 == y < n and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 == y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= x < n and 0 <= y < n and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < n and 0 <= y < n and ((x, y) in visited):",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(hp, [grid[0][0], 0, 0])",
      "mutated_line": "heapq.heappush(hp, [grid[1][0], 0, 0])",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[1][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(hp, [grid[0][0], 0, 0])",
      "mutated_line": "heapq.heappush(hp, [grid[-1][0], 0, 0])",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[-1][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "heapq.heappush(hp, [grid[0][0], 0, 0])",
      "mutated_line": "heapq.heappush(hp, [grid[1][0], 0, 0])",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[1][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i == n - 2 and j == n - 1:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 2 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i == n - 0 and j == n - 1:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 0 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i == n - 0 and j == n - 1:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 0 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i == n - -1 and j == n - 1:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - -1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i == n - 1 and j == n - 2:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 2:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i == n - 1 and j == n - 0:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 0:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i == n - 1 and j == n - 0:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 0:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i == n - 1 and j == n - 1:",
      "mutated_line": "if i == n - 1 and j == n - -1:",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - -1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= x < n and 0 <= y < n and (x, y) not in visited:",
      "mutated_line": "if 1 <= x < n and 0 <= y < n and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 1 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= x < n and 0 <= y < n and (x, y) not in visited:",
      "mutated_line": "if -1 <= x < n and 0 <= y < n and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if -1 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= x < n and 0 <= y < n and (x, y) not in visited:",
      "mutated_line": "if 1 <= x < n and 0 <= y < n and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 1 <= x < n and 0 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= x < n and 0 <= y < n and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < n and 1 <= y < n and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 1 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= x < n and 0 <= y < n and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < n and -1 <= y < n and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and -1 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= x < n and 0 <= y < n and (x, y) not in visited:",
      "mutated_line": "if 0 <= x < n and 1 <= y < n and ((x, y) not in visited):",
      "code": "import heapq\n\ndef minimum_time_to_reach_end(n, grid):\n    hp = []\n    ans = grid[0][0]\n    heapq.heappush(hp, [grid[0][0], 0, 0])\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = set()\n    visited.add((0, 0))\n    while hp:\n        (t, i, j) = heapq.heappop(hp)\n        ans = max(t, ans)\n        if i == n - 1 and j == n - 1:\n            return ans\n        for (d1, d2) in directions:\n            x = i + d1\n            y = j + d2\n            if 0 <= x < n and 1 <= y < n and ((x, y) not in visited):\n                visited.add((x, y))\n                heapq.heappush(hp, [grid[x][y], x, y])\n    return ans"
    }
  ]
}