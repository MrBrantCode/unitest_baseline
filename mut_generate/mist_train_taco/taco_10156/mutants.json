{
  "task_id": "taco_10156",
  "entry_point": "find_optimal_d",
  "mutant_count": 95,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while lo < hi:",
      "mutated_line": "while lo <= hi:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo <= hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while lo < hi:",
      "mutated_line": "while lo >= hi:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo >= hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while lo < hi:",
      "mutated_line": "while lo != hi:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo != hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + 1)[1] >= check(lo)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] >= check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + 1)[1] <= check(lo)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] <= check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + 1)[1] != check(lo)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] != check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "lo += 1",
      "mutated_line": "lo -= 1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo -= 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cur = tim = tot = totim = 0",
      "mutated_line": "cur = tim = tot = totim = 1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 1\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cur = tim = tot = totim = 0",
      "mutated_line": "cur = tim = tot = totim = -1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = -1\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cur = tim = tot = totim = 0",
      "mutated_line": "cur = tim = tot = totim = 1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 1\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "totim += x",
      "mutated_line": "totim -= x",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim -= x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "tim += x",
      "mutated_line": "tim -= x",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim -= x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "cur += 1",
      "mutated_line": "cur -= 1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur -= 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "tot += 1",
      "mutated_line": "tot -= 1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot -= 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(lo, hi) = (1, t)",
      "mutated_line": "(lo, hi) = (2, t)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (2, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(lo, hi) = (1, t)",
      "mutated_line": "(lo, hi) = (0, t)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (0, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(lo, hi) = (1, t)",
      "mutated_line": "(lo, hi) = (0, t)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (0, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(lo, hi) = (1, t)",
      "mutated_line": "(lo, hi) = (-1, t)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (-1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo + hi + 1) / 2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) / 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo + hi + 1) * 2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) * 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "lo += 1",
      "mutated_line": "lo += 2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 2\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "lo += 1",
      "mutated_line": "lo += 0",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 0\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "lo += 1",
      "mutated_line": "lo += 0",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 0\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "lo += 1",
      "mutated_line": "lo += -1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += -1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x > d:",
      "mutated_line": "if x >= d:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x >= d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x > d:",
      "mutated_line": "if x <= d:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x <= d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if x > d:",
      "mutated_line": "if x != d:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x != d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if totim > t:",
      "mutated_line": "if totim >= t:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim >= t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if totim > t:",
      "mutated_line": "if totim <= t:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim <= t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if totim > t:",
      "mutated_line": "if totim != t:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim != t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cur += 1",
      "mutated_line": "cur += 2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 2\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 0\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 0\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cur += 1",
      "mutated_line": "cur += -1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += -1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "tot += 1",
      "mutated_line": "tot += 2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 2\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "tot += 1",
      "mutated_line": "tot += 0",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 0\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "tot += 1",
      "mutated_line": "tot += 0",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 0\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "tot += 1",
      "mutated_line": "tot += -1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += -1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if cur == m:",
      "mutated_line": "if cur != m:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur != m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "totim += tim",
      "mutated_line": "totim -= tim",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim -= tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo + hi - 1) // 2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi - 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo + hi) * 1 // 2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi) * 1 // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo + hi + 1) // 3",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 3\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo + hi + 1) // 1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 1\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo + hi + 1) // 0",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 0\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo + hi + 1) // 1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 1\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo + hi + 1) // -2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // -2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if check(mid)[0]:",
      "mutated_line": "if check(mid)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[1]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if check(mid)[0]:",
      "mutated_line": "if check(mid)[-1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[-1]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if check(mid)[0]:",
      "mutated_line": "if check(mid)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[1]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid + 1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid + 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid * 1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid * 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + 1)[2] > check(lo)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[2] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + 1)[0] > check(lo)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[0] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + 1)[0] > check(lo)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[0] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + 1)[-1] > check(lo)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[-1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + 1)[1] > check(lo)[2]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[2]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + 1)[1] > check(lo)[0]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[0]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + 1)[1] > check(lo)[0]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[0]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + 1)[1] > check(lo)[-1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[-1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "max_tasks, optimal_d = check(lo)[1], lo",
      "mutated_line": "return (max_tasks, optimal_d)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[2], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "max_tasks, optimal_d = check(lo)[1], lo",
      "mutated_line": "return (max_tasks, optimal_d)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[0], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "max_tasks, optimal_d = check(lo)[1], lo",
      "mutated_line": "return (max_tasks, optimal_d)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[0], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "max_tasks, optimal_d = check(lo)[1], lo",
      "mutated_line": "return (max_tasks, optimal_d)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[-1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if totim > t:",
      "mutated_line": "if totim >= t:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim >= t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if totim > t:",
      "mutated_line": "if totim <= t:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim <= t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if totim > t:",
      "mutated_line": "if totim != t:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim != t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cur = tim = 0",
      "mutated_line": "cur = tim = 1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 1\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cur = tim = 0",
      "mutated_line": "cur = tim = -1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = -1\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cur = tim = 0",
      "mutated_line": "cur = tim = 1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 1\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo - hi + 1) // 2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo - hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo * hi + 1) // 2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo * hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo + hi + 2) // 2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 2) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo + hi + 0) // 2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 0) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo + hi + 0) // 2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 0) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = (lo + hi + 1) // 2",
      "mutated_line": "mid = (lo + hi + -1) // 2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + -1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid - 2",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 2\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid - 0",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 0\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid - 0",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 0\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid - -1",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - -1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo - 1)[1] > check(lo)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo - 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo * 1)[1] > check(lo)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo * 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return (all((x > d for x in p[i + 1:])), tot)",
      "mutated_line": "return (all((x >= d for x in p[i + 1:])), tot)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x >= d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return (all((x > d for x in p[i + 1:])), tot)",
      "mutated_line": "return (all((x <= d for x in p[i + 1:])), tot)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x <= d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return (all((x > d for x in p[i + 1:])), tot)",
      "mutated_line": "return (all((x != d for x in p[i + 1:])), tot)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x != d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + 2)[1] > check(lo)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 2)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + 0)[1] > check(lo)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 0)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + 0)[1] > check(lo)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 0)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if check(lo + 1)[1] > check(lo)[1]:",
      "mutated_line": "if check(lo + -1)[1] > check(lo)[1]:",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + -1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return (all((x > d for x in p[i + 1:])), tot)",
      "mutated_line": "return (all((x > d for x in p[i - 1:])), tot)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i - 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return (all((x > d for x in p[i + 1:])), tot)",
      "mutated_line": "return (all((x > d for x in p[i * 1:])), tot)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i * 1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (all((x > d for x in p[i + 1:])), tot)",
      "mutated_line": "return (all((x > d for x in p[i + 2:])), tot)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 2:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (all((x > d for x in p[i + 1:])), tot)",
      "mutated_line": "return (all((x > d for x in p[i + 0:])), tot)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 0:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (all((x > d for x in p[i + 1:])), tot)",
      "mutated_line": "return (all((x > d for x in p[i + 0:])), tot)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + 0:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (all((x > d for x in p[i + 1:])), tot)",
      "mutated_line": "return (all((x > d for x in p[i + -1:])), tot)",
      "code": "def find_optimal_d(n, m, t, p):\n\n    def check(d):\n        cur = tim = tot = totim = 0\n        for i in range(n):\n            x = p[i]\n            if x > d:\n                continue\n            totim += x\n            tim += x\n            if totim > t:\n                break\n            cur += 1\n            tot += 1\n            if cur == m:\n                totim += tim\n                if totim > t:\n                    break\n                cur = tim = 0\n        return (all((x > d for x in p[i + -1:])), tot)\n    (lo, hi) = (1, t)\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid)[0]:\n            lo = mid\n        else:\n            hi = mid - 1\n    if check(lo + 1)[1] > check(lo)[1]:\n        lo += 1\n    (max_tasks, optimal_d) = (check(lo)[1], lo)\n    return (max_tasks, optimal_d)"
    }
  ]
}