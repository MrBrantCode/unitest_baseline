{
  "task_id": "taco_17657",
  "entry_point": "find_min_increment",
  "mutant_count": 77,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if len(set(n_digits)) <= K:",
      "mutated_line": "if len(set(n_digits)) < K:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) < K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if len(set(n_digits)) <= K:",
      "mutated_line": "if len(set(n_digits)) > K:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) > K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if len(set(n_digits)) <= K:",
      "mutated_line": "if len(set(n_digits)) == K:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) == K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return 0  # Fallback, should not reach here given constraints",
      "mutated_line": "return 1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return 0  # Fallback, should not reach here given constraints",
      "mutated_line": "return -1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return 0  # Fallback, should not reach here given constraints",
      "mutated_line": "return 1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 1\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return -1\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 1\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if d == 9:",
      "mutated_line": "if d != 9:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d != 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(used_digits) > K:",
      "mutated_line": "if len(used_digits) >= K:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) >= K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(used_digits) > K:",
      "mutated_line": "if len(used_digits) <= K:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) <= K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(used_digits) > K:",
      "mutated_line": "if len(used_digits) != K:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) != K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(used_digits) < K:",
      "mutated_line": "if len(used_digits) <= K:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) <= K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(used_digits) < K:",
      "mutated_line": "if len(used_digits) >= K:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) >= K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(used_digits) < K:",
      "mutated_line": "if len(used_digits) != K:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) != K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if len(used_digits) == K:",
      "mutated_line": "if len(used_digits) != K:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) != K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "acc = 0",
      "mutated_line": "acc = 1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 1\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "acc = 0",
      "mutated_line": "acc = -1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = -1\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "acc = 0",
      "mutated_line": "acc = 1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 1\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return acc - N",
      "mutated_line": "return 0",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc + N\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return acc - N",
      "mutated_line": "return 0",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc * N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if d == 9:",
      "mutated_line": "if d == 10:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 10:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if d == 9:",
      "mutated_line": "if d == 8:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 8:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if d == 9:",
      "mutated_line": "if d == 0:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 0:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if d == 9:",
      "mutated_line": "if d == 1:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 1:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if d == 9:",
      "mutated_line": "if d == -9:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == -9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "d1 = d + 1",
      "mutated_line": "d1 = d - 1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d - 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "d1 = d + 1",
      "mutated_line": "d1 = d * 1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d * 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "d1 = d + 1",
      "mutated_line": "d1 = d - 1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d - 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "d1 = d + 1",
      "mutated_line": "d1 = d * 1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d * 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "while d1 not in used_digits and d1 != 10:",
      "mutated_line": "while d1 not in used_digits or d1 != 10:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits or d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "d1 += 1",
      "mutated_line": "d1 -= 1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 -= 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if d1 == 10:",
      "mutated_line": "if d1 != 10:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 != 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d2 = 0",
      "mutated_line": "d2 = 1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 1\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d2 = 0",
      "mutated_line": "d2 = -1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = -1\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d2 = 0",
      "mutated_line": "d2 = 1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 1\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for j in range(i + 1, len(n_digits)):",
      "mutated_line": "for j in range(i - 1, len(n_digits)):",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i - 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for j in range(i + 1, len(n_digits)):",
      "mutated_line": "for j in range(i * 1, len(n_digits)):",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i * 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "acc = 10 * acc + x",
      "mutated_line": "acc = 10 * acc - x",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc - x\n        return acc - N\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "acc = 10 * acc + x",
      "mutated_line": "acc = 10 * acc * x",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc * x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d1 = d + 1",
      "mutated_line": "d1 = d + 2",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 2\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d1 = d + 1",
      "mutated_line": "d1 = d + 0",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 0\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d1 = d + 1",
      "mutated_line": "d1 = d + 0",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 0\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d1 = d + 1",
      "mutated_line": "d1 = d + -1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + -1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d1 = d + 1",
      "mutated_line": "d1 = d + 2",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 2\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d1 = d + 1",
      "mutated_line": "d1 = d + 0",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 0\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d1 = d + 1",
      "mutated_line": "d1 = d + 0",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 0\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d1 = d + 1",
      "mutated_line": "d1 = d + -1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + -1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while d1 not in used_digits and d1 != 10:",
      "mutated_line": "while d1 in used_digits and d1 != 10:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while d1 not in used_digits and d1 != 10:",
      "mutated_line": "while d1 not in used_digits and d1 == 10:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 == 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "d1 += 1",
      "mutated_line": "d1 += 2",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 2\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "d1 += 1",
      "mutated_line": "d1 += 0",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 0\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "d1 += 1",
      "mutated_line": "d1 += 0",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 0\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "d1 += 1",
      "mutated_line": "d1 += -1",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += -1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if d1 == 10:",
      "mutated_line": "if d1 == 11:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 11:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if d1 == 10:",
      "mutated_line": "if d1 == 9:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 9:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if d1 == 10:",
      "mutated_line": "if d1 == 0:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 0:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if d1 == 10:",
      "mutated_line": "if d1 == 1:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 1:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if d1 == 10:",
      "mutated_line": "if d1 == -10:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == -10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(i + 1, len(n_digits)):",
      "mutated_line": "for j in range(i + 2, len(n_digits)):",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 2, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(i + 1, len(n_digits)):",
      "mutated_line": "for j in range(i + 0, len(n_digits)):",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 0, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(i + 1, len(n_digits)):",
      "mutated_line": "for j in range(i + 0, len(n_digits)):",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 0, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(i + 1, len(n_digits)):",
      "mutated_line": "for j in range(i + -1, len(n_digits)):",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + -1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "acc = 10 * acc + x",
      "mutated_line": "acc = 10 / acc + x",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 / acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "acc = 10 * acc + x",
      "mutated_line": "acc = 10 + acc + x",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 + acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "acc = 10 * acc + x",
      "mutated_line": "acc = 10 ** acc + x",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 ** acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while d1 not in used_digits and d1 != 10:",
      "mutated_line": "while d1 not in used_digits and d1 != 11:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 11:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while d1 not in used_digits and d1 != 10:",
      "mutated_line": "while d1 not in used_digits and d1 != 9:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 9:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while d1 not in used_digits and d1 != 10:",
      "mutated_line": "while d1 not in used_digits and d1 != 0:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 0:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while d1 not in used_digits and d1 != 10:",
      "mutated_line": "while d1 not in used_digits and d1 != 1:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 1:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while d1 not in used_digits and d1 != 10:",
      "mutated_line": "while d1 not in used_digits and d1 != -10:",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != -10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 10 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "acc = 10 * acc + x",
      "mutated_line": "acc = 11 * acc + x",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 11 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "acc = 10 * acc + x",
      "mutated_line": "acc = 9 * acc + x",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 9 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "acc = 10 * acc + x",
      "mutated_line": "acc = 0 * acc + x",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 0 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "acc = 10 * acc + x",
      "mutated_line": "acc = 1 * acc + x",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = 1 * acc + x\n        return acc - N\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "acc = 10 * acc + x",
      "mutated_line": "acc = -10 * acc + x",
      "code": "def find_min_increment(N: int, K: int) -> int:\n    n_str = str(N)\n    n_digits = list(map(int, n_str))\n    if len(set(n_digits)) <= K:\n        return 0\n    for (i, d) in enumerate(n_digits):\n        if d == 9:\n            continue\n        used_digits = set(n_digits[:i])\n        if len(used_digits) > K:\n            break\n        if len(used_digits) < K:\n            d1 = d + 1\n            used_digits.add(d1)\n        else:\n            d1 = d + 1\n            while d1 not in used_digits and d1 != 10:\n                d1 += 1\n            if d1 == 10:\n                continue\n        if len(used_digits) == K:\n            d2 = min(used_digits)\n        else:\n            d2 = 0\n        modified_digits = n_digits.copy()\n        modified_digits[i] = d1\n        for j in range(i + 1, len(n_digits)):\n            modified_digits[j] = d2\n        acc = 0\n        for x in modified_digits:\n            acc = -10 * acc + x\n        return acc - N\n    return 0"
    }
  ]
}