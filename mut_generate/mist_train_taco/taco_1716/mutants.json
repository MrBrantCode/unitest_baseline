{
  "task_id": "taco_1716",
  "entry_point": "calculate_max_energy_for_first_corridor",
  "mutant_count": 46,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if n == 2 or m + 1 == n:",
      "mutated_line": "if n == 2 and m + 1 == n:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 and m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = 1000000000",
      "mutated_line": "for (aa, bb, cc) in remaining_corridors:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000001\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = 1000000000",
      "mutated_line": "for (aa, bb, cc) in remaining_corridors:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 999999999\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = 1000000000",
      "mutated_line": "for (aa, bb, cc) in remaining_corridors:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 0\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = 1000000000",
      "mutated_line": "for (aa, bb, cc) in remaining_corridors:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = 1000000000",
      "mutated_line": "for (aa, bb, cc) in remaining_corridors:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = -1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "a1, b1, e1 = corridors[0]",
      "mutated_line": "(a1, b1, e1) = corridors[1]",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[1]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "a1, b1, e1 = corridors[0]",
      "mutated_line": "(a1, b1, e1) = corridors[-1]",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[-1]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "a1, b1, e1 = corridors[0]",
      "mutated_line": "(a1, b1, e1) = corridors[1]",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[1]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if n == 2 or m + 1 == n:",
      "mutated_line": "if n != 2 or m + 1 == n:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n != 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if n == 2 or m + 1 == n:",
      "mutated_line": "if n == 2 or m + 1 != n:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 != n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1000000000",
      "mutated_line": "return 1000000001",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000001\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1000000000",
      "mutated_line": "return 999999999",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 999999999\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1000000000",
      "mutated_line": "return 0",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 0\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1000000000",
      "mutated_line": "return 1",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1000000000",
      "mutated_line": "return -1000000000",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return -1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "uf = UnionFind(n + 1)",
      "mutated_line": "uf = UnionFind(n - 1)",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n - 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "uf = UnionFind(n + 1)",
      "mutated_line": "uf = UnionFind(n * 1)",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n * 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if uf.find(aa) != uf.find(bb):",
      "mutated_line": "if uf.find(aa) == uf.find(bb):",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) == uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if uf.find(a1) == uf.find(b1):",
      "mutated_line": "if uf.find(a1) != uf.find(b1):",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) != uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while a != self.parent[a]:",
      "mutated_line": "while a == self.parent[a]:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a == self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while acopy != a:",
      "mutated_line": "while acopy == a:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy == a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n == 2 or m + 1 == n:",
      "mutated_line": "if n == 3 or m + 1 == n:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 3 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n == 2 or m + 1 == n:",
      "mutated_line": "if n == 1 or m + 1 == n:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 1 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n == 2 or m + 1 == n:",
      "mutated_line": "if n == 0 or m + 1 == n:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 0 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n == 2 or m + 1 == n:",
      "mutated_line": "if n == 1 or m + 1 == n:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 1 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n == 2 or m + 1 == n:",
      "mutated_line": "if n == -2 or m + 1 == n:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == -2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n == 2 or m + 1 == n:",
      "mutated_line": "if n == 2 or m - 1 == n:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m - 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n == 2 or m + 1 == n:",
      "mutated_line": "if n == 2 or m * 1 == n:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m * 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "remaining_corridors = corridors[1:]",
      "mutated_line": "remaining_corridors = corridors[2:]",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[2:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "remaining_corridors = corridors[1:]",
      "mutated_line": "remaining_corridors = corridors[0:]",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[0:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "remaining_corridors = corridors[1:]",
      "mutated_line": "remaining_corridors = corridors[0:]",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[0:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "remaining_corridors = corridors[1:]",
      "mutated_line": "remaining_corridors = corridors[-1:]",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[-1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "uf = UnionFind(n + 1)",
      "mutated_line": "uf = UnionFind(n + 2)",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 2)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "uf = UnionFind(n + 1)",
      "mutated_line": "uf = UnionFind(n + 0)",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 0)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "uf = UnionFind(n + 1)",
      "mutated_line": "uf = UnionFind(n + 0)",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 0)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "uf = UnionFind(n + 1)",
      "mutated_line": "uf = UnionFind(n + -1)",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + -1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n == 2 or m + 1 == n:",
      "mutated_line": "if n == 2 or m + 2 == n:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 2 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n == 2 or m + 1 == n:",
      "mutated_line": "if n == 2 or m + 0 == n:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 0 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n == 2 or m + 1 == n:",
      "mutated_line": "if n == 2 or m + 0 == n:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 0 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n == 2 or m + 1 == n:",
      "mutated_line": "if n == 2 or m + -1 == n:",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + -1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "remaining_corridors.sort(key=lambda x: x[2])",
      "mutated_line": "remaining_corridors.sort(key=lambda x: x[3])",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[3])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "remaining_corridors.sort(key=lambda x: x[2])",
      "mutated_line": "remaining_corridors.sort(key=lambda x: x[1])",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[1])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "remaining_corridors.sort(key=lambda x: x[2])",
      "mutated_line": "remaining_corridors.sort(key=lambda x: x[0])",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[0])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "remaining_corridors.sort(key=lambda x: x[2])",
      "mutated_line": "remaining_corridors.sort(key=lambda x: x[1])",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[1])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "remaining_corridors.sort(key=lambda x: x[2])",
      "mutated_line": "remaining_corridors.sort(key=lambda x: x[-2])",
      "code": "def calculate_max_energy_for_first_corridor(n, m, corridors):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.parent = list(range(n))\n\n        def find(self, a):\n            acopy = a\n            while a != self.parent[a]:\n                a = self.parent[a]\n            while acopy != a:\n                (self.parent[acopy], acopy) = (a, self.parent[acopy])\n            return a\n\n        def union(self, a, b):\n            self.parent[self.find(b)] = self.find(a)\n    (a1, b1, e1) = corridors[0]\n    if n == 2 or m + 1 == n:\n        return 1000000000\n    remaining_corridors = corridors[1:]\n    remaining_corridors.sort(key=lambda x: x[-2])\n    uf = UnionFind(n + 1)\n    ans = 1000000000\n    for (aa, bb, cc) in remaining_corridors:\n        if uf.find(aa) != uf.find(bb):\n            uf.union(aa, bb)\n        if uf.find(a1) == uf.find(b1):\n            ans = cc\n            break\n    return ans"
    }
  ]
}