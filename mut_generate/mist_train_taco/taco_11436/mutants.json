{
  "task_id": "taco_11436",
  "entry_point": "find_optimal_subsequence",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n < 2:",
      "mutated_line": "if n <= 2:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n <= 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n < 2:",
      "mutated_line": "if n >= 2:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n >= 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n < 2:",
      "mutated_line": "if n != 2:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n != 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 3:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 3:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 1:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 1:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 0:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 0:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 1:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 1:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n < 2:",
      "mutated_line": "if n < -2:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < -2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(n - 2):",
      "mutated_line": "for i in range(n + 2):",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n + 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(n - 2):",
      "mutated_line": "for i in range(n * 2):",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n * 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper == p[i + 1] and maxper == p[i + 1]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] and maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "raise ValueError(\"The permutation must have a length of at least 2.\")",
      "mutated_line": "raise ValueError('')",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "best = [p[0]]",
      "mutated_line": "best = [p[1]]",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[1]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "best = [p[0]]",
      "mutated_line": "best = [p[-1]]",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[-1]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "best = [p[0]]",
      "mutated_line": "best = [p[1]]",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[1]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 2):",
      "mutated_line": "for i in range(n - 3):",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 3):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 2):",
      "mutated_line": "for i in range(n - 1):",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 1):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 2):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 0):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 2):",
      "mutated_line": "for i in range(n - 1):",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 1):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 2):",
      "mutated_line": "for i in range(n - -2):",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - -2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper != p[i + 1] or maxper == p[i + 1]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper != p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper == p[i + 1] or maxper != p[i + 1]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper != p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "best.append(p[-1])",
      "mutated_line": "best.append(p[+1])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[+1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "minper = min(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "minper = min(p[i], p[i - 1], p[i + 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i - 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "minper = min(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "minper = min(p[i], p[i * 1], p[i + 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i * 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "minper = min(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "minper = min(p[i], p[i + 1], p[i - 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i - 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "minper = min(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "minper = min(p[i], p[i + 1], p[i * 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i * 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "maxper = max(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "maxper = max(p[i], p[i - 1], p[i + 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i - 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "maxper = max(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "maxper = max(p[i], p[i * 1], p[i + 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i * 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "maxper = max(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "maxper = max(p[i], p[i + 1], p[i - 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i - 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "maxper = max(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "maxper = max(p[i], p[i + 1], p[i * 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i * 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "best.append(p[-1])",
      "mutated_line": "best.append(p[-2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-2])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "best.append(p[-1])",
      "mutated_line": "best.append(p[-0])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-0])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "best.append(p[-1])",
      "mutated_line": "best.append(p[-0])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-0])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "best.append(p[-1])",
      "mutated_line": "best.append(p[--1])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[--1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "minper = min(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "minper = min(p[i], p[i + 2], p[i + 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 2], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "minper = min(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "minper = min(p[i], p[i + 0], p[i + 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 0], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "minper = min(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "minper = min(p[i], p[i + 0], p[i + 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 0], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "minper = min(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "minper = min(p[i], p[i + -1], p[i + 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + -1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "minper = min(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "minper = min(p[i], p[i + 1], p[i + 3])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 3])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "minper = min(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "minper = min(p[i], p[i + 1], p[i + 1])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 1])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "minper = min(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "minper = min(p[i], p[i + 1], p[i + 0])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 0])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "minper = min(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "minper = min(p[i], p[i + 1], p[i + 1])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 1])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "minper = min(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "minper = min(p[i], p[i + 1], p[i + -2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + -2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxper = max(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "maxper = max(p[i], p[i + 2], p[i + 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 2], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxper = max(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "maxper = max(p[i], p[i + 0], p[i + 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 0], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxper = max(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "maxper = max(p[i], p[i + 0], p[i + 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 0], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxper = max(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "maxper = max(p[i], p[i + -1], p[i + 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + -1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxper = max(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "maxper = max(p[i], p[i + 1], p[i + 3])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 3])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxper = max(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "maxper = max(p[i], p[i + 1], p[i + 1])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 1])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxper = max(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "maxper = max(p[i], p[i + 1], p[i + 0])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 0])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxper = max(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "maxper = max(p[i], p[i + 1], p[i + 1])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 1])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxper = max(p[i], p[i + 1], p[i + 2])",
      "mutated_line": "maxper = max(p[i], p[i + 1], p[i + -2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + -2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper == p[i - 1] or maxper == p[i + 1]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i - 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper == p[i * 1] or maxper == p[i + 1]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i * 1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper == p[i + 1] or maxper == p[i - 1]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i - 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper == p[i + 1] or maxper == p[i * 1]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i * 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "best.append(p[i + 1])",
      "mutated_line": "best.append(p[i - 1])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i - 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "best.append(p[i + 1])",
      "mutated_line": "best.append(p[i * 1])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i * 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper == p[i + 2] or maxper == p[i + 1]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 2] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper == p[i + 0] or maxper == p[i + 1]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 0] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper == p[i + 0] or maxper == p[i + 1]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 0] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper == p[i + -1] or maxper == p[i + 1]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + -1] or maxper == p[i + 1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper == p[i + 1] or maxper == p[i + 2]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 2]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper == p[i + 1] or maxper == p[i + 0]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 0]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper == p[i + 1] or maxper == p[i + 0]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 0]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if minper == p[i + 1] or maxper == p[i + 1]:",
      "mutated_line": "if minper == p[i + 1] or maxper == p[i + -1]:",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + -1]:\n            best.append(p[i + 1])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "best.append(p[i + 1])",
      "mutated_line": "best.append(p[i + 2])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 2])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "best.append(p[i + 1])",
      "mutated_line": "best.append(p[i + 0])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 0])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "best.append(p[i + 1])",
      "mutated_line": "best.append(p[i + 0])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + 0])\n    best.append(p[-1])\n    return (len(best), best)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "best.append(p[i + 1])",
      "mutated_line": "best.append(p[i + -1])",
      "code": "def find_optimal_subsequence(p: list) -> tuple:\n    \"\"\"\n    Given a permutation p of length n, find its subsequence s1, s2, ..., sk of length at least 2\n    such that the sum of absolute differences between consecutive elements is maximized.\n    Among all such subsequences, choose the one whose length, k, is as small as possible.\n\n    Parameters:\n    p (list): A permutation of integers from 1 to n.\n\n    Returns:\n    tuple: A tuple containing the length of the found subsequence (k) and the subsequence itself.\n    \"\"\"\n    n = len(p)\n    if n < 2:\n        raise ValueError('The permutation must have a length of at least 2.')\n    best = [p[0]]\n    for i in range(n - 2):\n        minper = min(p[i], p[i + 1], p[i + 2])\n        maxper = max(p[i], p[i + 1], p[i + 2])\n        if minper == p[i + 1] or maxper == p[i + 1]:\n            best.append(p[i + -1])\n    best.append(p[-1])\n    return (len(best), best)"
    }
  ]
}