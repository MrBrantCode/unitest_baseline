{
  "task_id": "taco_5219",
  "entry_point": "count_different_grids",
  "mutant_count": 270,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244354",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244354\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244352",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244352\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 0",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 0\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 1\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = -998244353",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = -998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if N > M:",
      "mutated_line": "(N, M) = (M, N)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N >= M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if N > M:",
      "mutated_line": "(N, M) = (M, N)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N <= M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if N > M:",
      "mutated_line": "(N, M) = (M, N)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N != M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact = [0] * (M + 1)",
      "mutated_line": "fact = [0] / (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] / (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact = [0] * (M + 1)",
      "mutated_line": "fact = [0] + (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] + (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact = [0] * (M + 1)",
      "mutated_line": "fact = [0] ** (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] ** (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "powm = [0] * (M + 1)",
      "mutated_line": "powm = [0] / (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] / (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "powm = [0] * (M + 1)",
      "mutated_line": "powm = [0] + (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] + (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "powm = [0] * (M + 1)",
      "mutated_line": "powm = [0] ** (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] ** (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "pown = [0] * (M + 1)",
      "mutated_line": "pown = [0] / (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] / (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "pown = [0] * (M + 1)",
      "mutated_line": "pown = [0] + (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] + (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "pown = [0] * (M + 1)",
      "mutated_line": "pown = [0] ** (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] ** (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fact[0] = 1",
      "mutated_line": "fact[0] = 2",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 2\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fact[0] = 1",
      "mutated_line": "fact[0] = 0",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 0\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fact[0] = 1",
      "mutated_line": "fact[0] = 0",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 0\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fact[0] = 1",
      "mutated_line": "fact[0] = -1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = -1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "powm[0] = 1",
      "mutated_line": "powm[0] = 2",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 2\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "powm[0] = 1",
      "mutated_line": "powm[0] = 0",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 0\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "powm[0] = 1",
      "mutated_line": "powm[0] = 0",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 0\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "powm[0] = 1",
      "mutated_line": "powm[0] = -1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = -1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pown[0] = 1",
      "mutated_line": "pown[0] = 2",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 2\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pown[0] = 1",
      "mutated_line": "pown[0] = 0",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 0\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pown[0] = 1",
      "mutated_line": "pown[0] = 0",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 0\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pown[0] = 1",
      "mutated_line": "pown[0] = -1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = -1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "inv_fact = [0] * (M + 1)",
      "mutated_line": "inv_fact = [0] / (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] / (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "inv_fact = [0] * (M + 1)",
      "mutated_line": "inv_fact = [0] + (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] + (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "inv_fact = [0] * (M + 1)",
      "mutated_line": "inv_fact = [0] ** (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] ** (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 1\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = -1\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 1\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans -= (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans -= (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact = [0] * (M + 1)",
      "mutated_line": "fact = [0] * (M - 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M - 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact = [0] * (M + 1)",
      "mutated_line": "fact = [0] * (M * 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M * 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "powm = [0] * (M + 1)",
      "mutated_line": "powm = [0] * (M - 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M - 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "powm = [0] * (M + 1)",
      "mutated_line": "powm = [0] * (M * 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M * 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "pown = [0] * (M + 1)",
      "mutated_line": "pown = [0] * (M - 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M - 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "pown = [0] * (M + 1)",
      "mutated_line": "pown = [0] * (M * 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M * 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fact[0] = 1",
      "mutated_line": "fact[1] = 1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[1] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fact[0] = 1",
      "mutated_line": "fact[-1] = 1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[-1] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fact[0] = 1",
      "mutated_line": "fact[1] = 1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[1] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "powm[0] = 1",
      "mutated_line": "powm[1] = 1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[1] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "powm[0] = 1",
      "mutated_line": "powm[-1] = 1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[-1] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "powm[0] = 1",
      "mutated_line": "powm[1] = 1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[1] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pown[0] = 1",
      "mutated_line": "pown[1] = 1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[1] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pown[0] = 1",
      "mutated_line": "pown[-1] = 1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[-1] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pown[0] = 1",
      "mutated_line": "pown[1] = 1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[1] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, M + 1):",
      "mutated_line": "for i in range(2, M + 1):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(2, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, M + 1):",
      "mutated_line": "for i in range(0, M + 1):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(0, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, M + 1):",
      "mutated_line": "for i in range(0, M + 1):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(0, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, M + 1):",
      "mutated_line": "for i in range(-1, M + 1):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(-1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(1, M + 1):",
      "mutated_line": "for i in range(1, M - 1):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M - 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(1, M + 1):",
      "mutated_line": "for i in range(1, M * 1):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M * 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "fact[i] = fact[i - 1] * i % mod",
      "mutated_line": "fact[i] = fact[i - 1] * i * mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i * mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "fact[i] = fact[i - 1] * i % mod",
      "mutated_line": "fact[i] = fact[i - 1] * i + mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i + mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i - 1] * (M + 1) * mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) * mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i - 1] * (M + 1) + mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) + mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i - 1] * (N + 1) * mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) * mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i - 1] * (N + 1) + mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) + mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if m == 0:",
      "mutated_line": "if m != 0:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m != 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "inv_fact = [0] * (M + 1)",
      "mutated_line": "inv_fact = [0] * (M - 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M - 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "inv_fact = [0] * (M + 1)",
      "mutated_line": "inv_fact = [0] * (M * 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M * 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "inv_fact[M] = pow(fact[M], mod - 2)",
      "mutated_line": "inv_fact[M] = pow(fact[M], mod + 2)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod + 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "inv_fact[M] = pow(fact[M], mod - 2)",
      "mutated_line": "inv_fact[M] = pow(fact[M], mod * 2)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod * 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) * mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) * mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) + mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) + mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod",
      "mutated_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n - r] * mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] * mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod",
      "mutated_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n - r] + mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] + mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(N + 1):",
      "mutated_line": "for i in range(N - 1):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N - 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(N + 1):",
      "mutated_line": "for i in range(N * 1):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N * 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] / pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] / pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] + pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] + pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += ((-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i]) ** pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += ((-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i]) ** pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = ans % mod",
      "mutated_line": "ans = ans * mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans * mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = ans % mod",
      "mutated_line": "ans = ans + mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans + mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact = [0] * (M + 1)",
      "mutated_line": "fact = [1] * (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [1] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact = [0] * (M + 1)",
      "mutated_line": "fact = [-1] * (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [-1] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact = [0] * (M + 1)",
      "mutated_line": "fact = [1] * (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [1] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact = [0] * (M + 1)",
      "mutated_line": "fact = [0] * (M + 2)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 2)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact = [0] * (M + 1)",
      "mutated_line": "fact = [0] * (M + 0)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 0)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact = [0] * (M + 1)",
      "mutated_line": "fact = [0] * (M + 0)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 0)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact = [0] * (M + 1)",
      "mutated_line": "fact = [0] * (M + -1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + -1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "powm = [0] * (M + 1)",
      "mutated_line": "powm = [1] * (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [1] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "powm = [0] * (M + 1)",
      "mutated_line": "powm = [-1] * (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [-1] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "powm = [0] * (M + 1)",
      "mutated_line": "powm = [1] * (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [1] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "powm = [0] * (M + 1)",
      "mutated_line": "powm = [0] * (M + 2)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 2)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "powm = [0] * (M + 1)",
      "mutated_line": "powm = [0] * (M + 0)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 0)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "powm = [0] * (M + 1)",
      "mutated_line": "powm = [0] * (M + 0)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 0)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "powm = [0] * (M + 1)",
      "mutated_line": "powm = [0] * (M + -1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + -1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pown = [0] * (M + 1)",
      "mutated_line": "pown = [1] * (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [1] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pown = [0] * (M + 1)",
      "mutated_line": "pown = [-1] * (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [-1] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pown = [0] * (M + 1)",
      "mutated_line": "pown = [1] * (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [1] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pown = [0] * (M + 1)",
      "mutated_line": "pown = [0] * (M + 2)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 2)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pown = [0] * (M + 1)",
      "mutated_line": "pown = [0] * (M + 0)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 0)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pown = [0] * (M + 1)",
      "mutated_line": "pown = [0] * (M + 0)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 0)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pown = [0] * (M + 1)",
      "mutated_line": "pown = [0] * (M + -1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + -1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, M + 1):",
      "mutated_line": "for i in range(1, M + 2):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 2):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, M + 1):",
      "mutated_line": "for i in range(1, M + 0):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 0):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, M + 1):",
      "mutated_line": "for i in range(1, M + 0):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 0):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, M + 1):",
      "mutated_line": "for i in range(1, M + -1):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + -1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "fact[i] = fact[i - 1] * i % mod",
      "mutated_line": "fact[i] = fact[i - 1] / i % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] / i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "fact[i] = fact[i - 1] * i % mod",
      "mutated_line": "fact[i] = (fact[i - 1] + i) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = (fact[i - 1] + i) % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "fact[i] = fact[i - 1] * i % mod",
      "mutated_line": "fact[i] = fact[i - 1] ** i % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] ** i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i - 1] / (M + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] / (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = (powm[i - 1] + (M + 1)) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = (powm[i - 1] + (M + 1)) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i - 1] ** (M + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] ** (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i - 1] / (N + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] / (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = (pown[i - 1] + (N + 1)) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = (pown[i - 1] + (N + 1)) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i - 1] ** (N + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] ** (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 1:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if m == 0:",
      "mutated_line": "if m == -1:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == -1:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 1:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 2\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 0\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 0\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return -1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif m == 1:",
      "mutated_line": "elif m != 1:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m != 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "inv_fact = [0] * (M + 1)",
      "mutated_line": "inv_fact = [1] * (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [1] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "inv_fact = [0] * (M + 1)",
      "mutated_line": "inv_fact = [-1] * (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [-1] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "inv_fact = [0] * (M + 1)",
      "mutated_line": "inv_fact = [1] * (M + 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [1] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "inv_fact = [0] * (M + 1)",
      "mutated_line": "inv_fact = [0] * (M + 2)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 2)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "inv_fact = [0] * (M + 1)",
      "mutated_line": "inv_fact = [0] * (M + 0)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 0)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "inv_fact = [0] * (M + 1)",
      "mutated_line": "inv_fact = [0] * (M + 0)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 0)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "inv_fact = [0] * (M + 1)",
      "mutated_line": "inv_fact = [0] * (M + -1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + -1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "inv_fact[M] = pow(fact[M], mod - 2)",
      "mutated_line": "inv_fact[M] = pow(fact[M], mod - 3)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 3)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "inv_fact[M] = pow(fact[M], mod - 2)",
      "mutated_line": "inv_fact[M] = pow(fact[M], mod - 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 1)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "inv_fact[M] = pow(fact[M], mod - 2)",
      "mutated_line": "inv_fact[M] = pow(fact[M], mod - 0)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 0)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "inv_fact[M] = pow(fact[M], mod - 2)",
      "mutated_line": "inv_fact[M] = pow(fact[M], mod - 1)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 1)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "inv_fact[M] = pow(fact[M], mod - 2)",
      "mutated_line": "inv_fact[M] = pow(fact[M], mod - -2)",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - -2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in reversed(range(0, M)):",
      "mutated_line": "for i in reversed(range(1, M)):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(1, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in reversed(range(0, M)):",
      "mutated_line": "for i in reversed(range(-1, M)):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(-1, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in reversed(range(0, M)):",
      "mutated_line": "for i in reversed(range(1, M)):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(1, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] / (i + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] / (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = (inv_fact[i + 1] + (i + 1)) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = (inv_fact[i + 1] + (i + 1)) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] ** (i + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] ** (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod",
      "mutated_line": "return fact[n] * inv_fact[r] % mod / inv_fact[n - r] % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod / inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod",
      "mutated_line": "return (fact[n] * inv_fact[r] % mod + inv_fact[n - r]) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return (fact[n] * inv_fact[r] % mod + inv_fact[n - r]) % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod",
      "mutated_line": "return (fact[n] * inv_fact[r] % mod) ** inv_fact[n - r] % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return (fact[n] * inv_fact[r] % mod) ** inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(N + 1):",
      "mutated_line": "for i in range(N + 2):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 2):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(N + 1):",
      "mutated_line": "for i in range(N + 0):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 0):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(N + 1):",
      "mutated_line": "for i in range(N + 0):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 0):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(N + 1):",
      "mutated_line": "for i in range(N + -1):",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + -1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] / powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] / powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += ((-1) ** i * C(N, i) * C(M, i) * fact[i] + powm[N - i]) * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += ((-1) ** i * C(N, i) * C(M, i) * fact[i] + powm[N - i]) * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += ((-1) ** i * C(N, i) * C(M, i) * fact[i]) ** powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += ((-1) ** i * C(N, i) * C(M, i) * fact[i]) ** powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i - 1] * (M - 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M - 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i - 1] * (M * 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M * 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i - 1] * (N - 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N - 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i - 1] * (N * 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N * 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif m == 1:",
      "mutated_line": "elif m == 2:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 2:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif m == 1:",
      "mutated_line": "elif m == 0:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 0:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif m == 1:",
      "mutated_line": "elif m == 0:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 0:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif m == 1:",
      "mutated_line": "elif m == -1:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == -1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif m % 2 == 0:",
      "mutated_line": "elif m % 2 != 0:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 != 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i - 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i - 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i * 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i * 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod",
      "mutated_line": "return fact[n] * inv_fact[r] * mod * inv_fact[n - r] % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] * mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod",
      "mutated_line": "return (fact[n] * inv_fact[r] + mod) * inv_fact[n - r] % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return (fact[n] * inv_fact[r] + mod) * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (-1) ** i * C(N, i) * C(M, i) / fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) / fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += ((-1) ** i * C(N, i) * C(M, i) + fact[i]) * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += ((-1) ** i * C(N, i) * C(M, i) + fact[i]) * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += ((-1) ** i * C(N, i) * C(M, i)) ** fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += ((-1) ** i * C(N, i) * C(M, i)) ** fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M + i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M + i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M * i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M * i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "fact[i] = fact[i - 1] * i % mod",
      "mutated_line": "fact[i] = fact[i + 1] * i % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i + 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "fact[i] = fact[i - 1] * i % mod",
      "mutated_line": "fact[i] = fact[i * 1] * i % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i * 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i + 1] * (M + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i + 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i * 1] * (M + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i * 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i - 1] * (M + 2) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 2) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i - 1] * (M + 0) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 0) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i - 1] * (M + 0) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 0) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i - 1] * (M + -1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + -1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i + 1] * (N + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i + 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i * 1] * (N + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i * 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i - 1] * (N + 2) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 2) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i - 1] * (N + 0) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 0) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i - 1] * (N + 0) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 0) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i - 1] * (N + -1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + -1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "elif m % 2 == 0:",
      "mutated_line": "elif m * 2 == 0:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m * 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "elif m % 2 == 0:",
      "mutated_line": "elif m + 2 == 0:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m + 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif m % 2 == 0:",
      "mutated_line": "elif m % 2 == 1:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 1:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif m % 2 == 0:",
      "mutated_line": "elif m % 2 == -1:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == -1:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif m % 2 == 0:",
      "mutated_line": "elif m % 2 == 1:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 1:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m // 2) ** 2 * mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 * mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m // 2) ** 2 + mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 + mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // 2) ** 2 % mod * n * mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n * mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // 2) ** 2 % mod * n + mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n + mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i - 1] * (i + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i - 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i * 1] * (i + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i * 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i + 2) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 2) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i + 0) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 0) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i + 0) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 0) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i + 1] * (i + -1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + -1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod",
      "mutated_line": "return fact[n] / inv_fact[r] % mod * inv_fact[n - r] % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] / inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod",
      "mutated_line": "return (fact[n] + inv_fact[r]) % mod * inv_fact[n - r] % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return (fact[n] + inv_fact[r]) % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod",
      "mutated_line": "return fact[n] ** inv_fact[r] % mod * inv_fact[n - r] % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] ** inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod",
      "mutated_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n + r] % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n + r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod",
      "mutated_line": "return fact[n] * inv_fact[r] % mod * inv_fact[n * r] % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n * r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (-1) ** i * C(N, i) / C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) / C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += ((-1) ** i * C(N, i) + C(M, i)) * fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += ((-1) ** i * C(N, i) + C(M, i)) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += ((-1) ** i * C(N, i)) ** C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += ((-1) ** i * C(N, i)) ** C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N + i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N + i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N * i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N * i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "fact[i] = fact[i - 1] * i % mod",
      "mutated_line": "fact[i] = fact[i - 2] * i % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 2] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "fact[i] = fact[i - 1] * i % mod",
      "mutated_line": "fact[i] = fact[i - 0] * i % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 0] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "fact[i] = fact[i - 1] * i % mod",
      "mutated_line": "fact[i] = fact[i - 0] * i % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 0] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "fact[i] = fact[i - 1] * i % mod",
      "mutated_line": "fact[i] = fact[i - -1] * i % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - -1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i - 2] * (M + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 2] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i - 0] * (M + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 0] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i - 0] * (M + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 0] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "powm[i] = powm[i - 1] * (M + 1) % mod",
      "mutated_line": "powm[i] = powm[i - -1] * (M + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - -1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i - 2] * (N + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 2] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i - 0] * (N + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 0] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i - 0] * (N + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 0] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pown[i] = pown[i - 1] * (N + 1) % mod",
      "mutated_line": "pown[i] = pown[i - -1] * (N + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - -1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif m % 2 == 0:",
      "mutated_line": "elif m % 3 == 0:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 3 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif m % 2 == 0:",
      "mutated_line": "elif m % 1 == 0:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 1 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif m % 2 == 0:",
      "mutated_line": "elif m % 0 == 0:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 0 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif m % 2 == 0:",
      "mutated_line": "elif m % 1 == 0:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 1 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif m % 2 == 0:",
      "mutated_line": "elif m % -2 == 0:",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % -2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m // 2) * 2 % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) * 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return (pow(n, m // 2) + 2) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return (pow(n, m // 2) + 2) % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // 2) ** 2 % mod / n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod / n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return (pow(n, m // 2) ** 2 % mod + n) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return (pow(n, m // 2) ** 2 % mod + n) % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return (pow(n, m // 2) ** 2 % mod) ** n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return (pow(n, m // 2) ** 2 % mod) ** n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i + 2] * (i + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 2] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i + 0] * (i + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 0] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i + 0] * (i + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 0] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod",
      "mutated_line": "inv_fact[i] = inv_fact[i + -1] * (i + 1) % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + -1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (-1) ** i / C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i / C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += ((-1) ** i + C(N, i)) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += ((-1) ** i + C(N, i)) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += ((-1) ** i) ** C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += ((-1) ** i) ** C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m // 2) ** 3 % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 3 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m // 2) ** 1 % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 1 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m // 2) ** 0 % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 0 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m // 2) ** 1 % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 1 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m // 2) ** -2 % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** -2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // 2) ** 2 * mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 * mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return (pow(n, m // 2) ** 2 + mod) * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return (pow(n, m // 2) ** 2 + mod) * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += -1 * i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += -1 * i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (-1 + i) * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1 + i) * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m / 2) ** 2 % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m / 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m * 2) ** 2 % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m * 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // 2) * 2 % mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) * 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return (pow(n, m // 2) + 2) % mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return (pow(n, m // 2) + 2) % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (+1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (+1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m // 3) ** 2 % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 3) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m // 1) ** 2 % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 1) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m // 0) ** 2 % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 0) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m // 1) ** 2 % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 1) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return pow(n, m // 2) ** 2 % mod",
      "mutated_line": "return pow(n, m // -2) ** 2 % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // -2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // 2) ** 3 % mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 3 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // 2) ** 1 % mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 1 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // 2) ** 0 % mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 0 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // 2) ** 1 % mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 1 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // 2) ** -2 % mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** -2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (-2) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-2) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (-0) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-0) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (-0) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-0) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "mutated_line": "ans += (--1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (--1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m / 2) ** 2 % mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m / 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m * 2) ** 2 % mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m * 2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // 3) ** 2 % mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 3) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // 1) ** 2 % mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 1) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // 0) ** 2 % mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 0) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // 1) ** 2 % mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // 1) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return pow(n, m // 2) ** 2 % mod * n % mod",
      "mutated_line": "return pow(n, m // -2) ** 2 % mod * n % mod",
      "code": "def count_different_grids(N: int, M: int) -> int:\n    mod = 998244353\n    if N > M:\n        (N, M) = (M, N)\n    fact = [0] * (M + 1)\n    powm = [0] * (M + 1)\n    pown = [0] * (M + 1)\n    fact[0] = 1\n    powm[0] = 1\n    pown[0] = 1\n    for i in range(1, M + 1):\n        fact[i] = fact[i - 1] * i % mod\n        powm[i] = powm[i - 1] * (M + 1) % mod\n        pown[i] = pown[i - 1] * (N + 1) % mod\n\n    def pow(n, m):\n        if m == 0:\n            return 1\n        elif m == 1:\n            return n\n        elif m % 2 == 0:\n            return pow(n, m // 2) ** 2 % mod\n        else:\n            return pow(n, m // -2) ** 2 % mod * n % mod\n    inv_fact = [0] * (M + 1)\n    inv_fact[M] = pow(fact[M], mod - 2)\n    for i in reversed(range(0, M)):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def C(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n    ans = 0\n    for i in range(N + 1):\n        ans += (-1) ** i * C(N, i) * C(M, i) * fact[i] * powm[N - i] * pown[M - i]\n        ans = ans % mod\n    return ans"
    }
  ]
}