{
  "task_id": "taco_9378",
  "entry_point": "find_optimal_sequence",
  "mutant_count": 90,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-2] % 2 != 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 != 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-2] * 2 == 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] * 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-2] + 2 == 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] + 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-2] % 2 == 1:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 1:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-2] % 2 == -1:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == -1:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-2] % 2 == 1:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 1:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "elif C[-1] > 0:",
      "mutated_line": "elif C[-1] >= 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] >= 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "elif C[-1] > 0:",
      "mutated_line": "elif C[-1] <= 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] <= 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "elif C[-1] > 0:",
      "mutated_line": "elif C[-1] != 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] != 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-2] % 3 == 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 3 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-2] % 1 == 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 1 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-2] % 0 == 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 0 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-2] % 1 == 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 1 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-2] % -2 == 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % -2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i - 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i - 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i * 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i * 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif C[-1] > 0:",
      "mutated_line": "elif C[-1] > 1:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 1:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif C[-1] > 0:",
      "mutated_line": "elif C[-1] > -1:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > -1:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif C[-1] > 0:",
      "mutated_line": "elif C[-1] > 1:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 1:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] - [A.index(-1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] - [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] * [A.index(-1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] * [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "d = N - A[::-1].index(-2)",
      "mutated_line": "d = N + A[::-1].index(-2)",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N + A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "d = N - A[::-1].index(-2)",
      "mutated_line": "d = N * A[::-1].index(-2)",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N * A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[+2] % 2 == 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[+2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 2 for (i, a) in enumerate(A) if abs(a) == 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 2 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 0 for (i, a) in enumerate(A) if abs(a) == 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 0 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 0 for (i, a) in enumerate(A) if abs(a) == 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 0 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + -1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + -1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) != 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) != 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "elif C[-1] > 0:",
      "mutated_line": "elif C[+1] > 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[+1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i - 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i - 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i * 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i * 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-3] % 2 == 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-3] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-1] % 2 == 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-1] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-0] % 2 == 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-0] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[-1] % 2 == 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-1] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if C[-2] % 2 == 0:",
      "mutated_line": "if C[--2] % 2 == 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[--2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 3]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 3]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 1]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 0]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 0]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 1]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == -2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == -2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif C[-1] > 0:",
      "mutated_line": "elif C[-2] > 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-2] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif C[-1] > 0:",
      "mutated_line": "elif C[-0] > 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-0] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif C[-1] > 0:",
      "mutated_line": "elif C[-0] > 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-0] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif C[-1] > 0:",
      "mutated_line": "elif C[--1] > 0:",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[--1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i - 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i - 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i * 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i * 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) - 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) - 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) * 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) * 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "d = N - A[::-1].index(-2)",
      "mutated_line": "d = N - A[::-1].index(+2)",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(+2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 2 for (i, a) in enumerate(A) if abs(a) == 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 2 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 0 for (i, a) in enumerate(A) if abs(a) == 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 0 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 0 for (i, a) in enumerate(A) if abs(a) == 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 0 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + -1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + -1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) != 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) != 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 2 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 2 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 0 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 0 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 0 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 0 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + -1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + -1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) != 2] + [A.index(-1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) != 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 2]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 0]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 0]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 0]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 0]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + -1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + -1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d = N - A[::-1].index(-2)",
      "mutated_line": "d = N - A[::-1].index(-3)",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-3)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d = N - A[::-1].index(-2)",
      "mutated_line": "d = N - A[::-1].index(-1)",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-1)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d = N - A[::-1].index(-2)",
      "mutated_line": "d = N - A[::-1].index(-0)",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-0)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d = N - A[::-1].index(-2)",
      "mutated_line": "d = N - A[::-1].index(-1)",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-1)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d = N - A[::-1].index(-2)",
      "mutated_line": "d = N - A[::-1].index(--2)",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(--2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 3]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 3]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 1]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 0]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 0]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 1]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == -2]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == -2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 3] + [A.index(-1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 3] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 1] + [A.index(-1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 1] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 0] + [A.index(-1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 0] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 1] + [A.index(-1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 1] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == -2] + [A.index(-1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == -2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(+1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(+1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-2) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-2) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-0) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-0) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-0) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-0) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]",
      "mutated_line": "ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(--1) + 1]",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(--1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "d = N - A[::-1].index(-2)",
      "mutated_line": "d = N - A[::+1].index(-2)",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::+1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d = N - A[::-1].index(-2)",
      "mutated_line": "d = N - A[::-2].index(-2)",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-2].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d = N - A[::-1].index(-2)",
      "mutated_line": "d = N - A[::-0].index(-2)",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-0].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d = N - A[::-1].index(-2)",
      "mutated_line": "d = N - A[::-0].index(-2)",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::-0].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d = N - A[::-1].index(-2)",
      "mutated_line": "d = N - A[::--1].index(-2)",
      "code": "def find_optimal_sequence(N, A):\n    from collections import Counter\n    C = Counter(A)\n    if C[-2] % 2 == 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        return (len(ans), ans)\n    elif C[-1] > 0:\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2] + [A.index(-1) + 1]\n        return (len(ans), sorted(ans))\n    else:\n        d = N - A[::--1].index(-2)\n        ans = [i + 1 for (i, a) in enumerate(A) if abs(a) == 2]\n        del ans[ans.index(d)]\n        return (len(ans), ans)"
    }
  ]
}