{
  "task_id": "taco_9345",
  "entry_point": "least_prime_divisor",
  "mutant_count": 114,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"Helper function to find the least prime divisor of x.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if x % 2 == 0:",
      "mutated_line": "if x % 2 != 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 != 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "factors = [0] * n",
      "mutated_line": "factors = [0] / n",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] / n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "factors = [0] * n",
      "mutated_line": "factors = [0] + n",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] + n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "factors = [0] * n",
      "mutated_line": "factors = [0] ** n",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] ** n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "index = [0] * n",
      "mutated_line": "index = [0] / n",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] / n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "index = [0] * n",
      "mutated_line": "index = [0] + n",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] + n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "index = [0] * n",
      "mutated_line": "index = [0] ** n",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] ** n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "L -= 1  # Convert to 0-based index",
      "mutated_line": "L += 1",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L += 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "R -= 1  # Convert to 0-based index",
      "mutated_line": "R += 1",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R += 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if x % 2 == 0:",
      "mutated_line": "if x * 2 == 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x * 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if x % 2 == 0:",
      "mutated_line": "if x + 2 == 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x + 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x % 2 == 0:",
      "mutated_line": "if x % 2 == 1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 1:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x % 2 == 0:",
      "mutated_line": "if x % 2 == -1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == -1:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x % 2 == 0:",
      "mutated_line": "if x % 2 == 1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 1:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 2",
      "mutated_line": "return 3",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 3\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 1\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 2",
      "mutated_line": "return 0",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 0\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 1\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 2",
      "mutated_line": "return -2",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return -2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(4, int(math.sqrt(x)) + 1, 2):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(4, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(2, int(math.sqrt(x)) + 1, 2):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(2, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(0, int(math.sqrt(x)) + 1, 2):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(0, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(1, int(math.sqrt(x)) + 1, 2):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(1, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(-3, int(math.sqrt(x)) + 1, 2):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(-3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(3, int(math.sqrt(x)) - 1, 2):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) - 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(3, int(math.sqrt(x)) * 1, 2):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) * 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(3, int(math.sqrt(x)) + 1, 3):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 3):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(3, int(math.sqrt(x)) + 1, 1):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 1):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(3, int(math.sqrt(x)) + 1, 0):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 0):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(3, int(math.sqrt(x)) + 1, 1):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 1):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(3, int(math.sqrt(x)) + 1, -2):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, -2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x % i == 0:",
      "mutated_line": "if x % i != 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i != 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while x != 1:",
      "mutated_line": "while x == 1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x == 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "L -= 1  # Convert to 0-based index",
      "mutated_line": "L -= 2",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 2\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "L -= 1  # Convert to 0-based index",
      "mutated_line": "L -= 0",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 0\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "L -= 1  # Convert to 0-based index",
      "mutated_line": "L -= 0",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 0\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "L -= 1  # Convert to 0-based index",
      "mutated_line": "L -= -1",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= -1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "R -= 1  # Convert to 0-based index",
      "mutated_line": "R -= 2",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 2\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "R -= 1  # Convert to 0-based index",
      "mutated_line": "R -= 0",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 0\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "R -= 1  # Convert to 0-based index",
      "mutated_line": "R -= 0",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 0\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "R -= 1  # Convert to 0-based index",
      "mutated_line": "R -= -1",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= -1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if type_op == 0:",
      "mutated_line": "if type_op != 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op != 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x % 2 == 0:",
      "mutated_line": "if x % 3 == 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 3 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x % 2 == 0:",
      "mutated_line": "if x % 1 == 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 1 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x % 2 == 0:",
      "mutated_line": "if x % 0 == 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 0 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x % 2 == 0:",
      "mutated_line": "if x % 1 == 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 1 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x % 2 == 0:",
      "mutated_line": "if x % -2 == 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % -2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(3, int(math.sqrt(x)) + 2, 2):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 2, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(3, int(math.sqrt(x)) + 0, 2):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 0, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(3, int(math.sqrt(x)) + 0, 2):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 0, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(3, int(math.sqrt(x)) + 1, 2):",
      "mutated_line": "for i in range(3, int(math.sqrt(x)) + -1, 2):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + -1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if x % i == 0:",
      "mutated_line": "if x * i == 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x * i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if x % i == 0:",
      "mutated_line": "if x + i == 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x + i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x % i == 0:",
      "mutated_line": "if x % i == 1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 1:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x % i == 0:",
      "mutated_line": "if x % i == -1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == -1:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x % i == 0:",
      "mutated_line": "if x % i == 1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 1:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "factors = [0] * n",
      "mutated_line": "factors = [1] * n",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [1] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "factors = [0] * n",
      "mutated_line": "factors = [-1] * n",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [-1] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "factors = [0] * n",
      "mutated_line": "factors = [1] * n",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [1] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "index = [0] * n",
      "mutated_line": "index = [1] * n",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [1] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "index = [0] * n",
      "mutated_line": "index = [-1] * n",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [-1] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "index = [0] * n",
      "mutated_line": "index = [1] * n",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [1] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while x != 1:",
      "mutated_line": "while x != 2:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 2:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while x != 1:",
      "mutated_line": "while x != 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 0:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while x != 1:",
      "mutated_line": "while x != 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 0:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while x != 1:",
      "mutated_line": "while x != -1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != -1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while x % lpd == 0:",
      "mutated_line": "while x % lpd != 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd != 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "factors[r] += 1",
      "mutated_line": "factors[r] -= 1",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] -= 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if type_op == 0:",
      "mutated_line": "if type_op == 1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 1:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if type_op == 0:",
      "mutated_line": "if type_op == -1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == -1:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if type_op == 0:",
      "mutated_line": "if type_op == 1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 1:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "elif type_op == 1:",
      "mutated_line": "elif type_op != 1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op != 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "while x % lpd == 0:",
      "mutated_line": "while x * lpd == 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x * lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "while x % lpd == 0:",
      "mutated_line": "while x + lpd == 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x + lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while x % lpd == 0:",
      "mutated_line": "while x % lpd == 1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 1:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while x % lpd == 0:",
      "mutated_line": "while x % lpd == -1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == -1:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while x % lpd == 0:",
      "mutated_line": "while x % lpd == 1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 1:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "factors[r] += 1",
      "mutated_line": "factors[r] += 2",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 2\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "factors[r] += 1",
      "mutated_line": "factors[r] += 0",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 0\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "factors[r] += 1",
      "mutated_line": "factors[r] += 0",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 0\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "factors[r] += 1",
      "mutated_line": "factors[r] += -1",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += -1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "for ran in range(L, R + 1):",
      "mutated_line": "for ran in range(L, R - 1):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R - 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "for ran in range(L, R + 1):",
      "mutated_line": "for ran in range(L, R * 1):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R * 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if index[ran] < factors[ran]:",
      "mutated_line": "if index[ran] <= factors[ran]:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] <= factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if index[ran] < factors[ran]:",
      "mutated_line": "if index[ran] >= factors[ran]:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] >= factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if index[ran] < factors[ran]:",
      "mutated_line": "if index[ran] != factors[ran]:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] != factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "index[ran] += 1",
      "mutated_line": "index[ran] -= 1",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] -= 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif type_op == 1:",
      "mutated_line": "elif type_op == 2:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 2:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif type_op == 1:",
      "mutated_line": "elif type_op == 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 0:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif type_op == 1:",
      "mutated_line": "elif type_op == 0:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 0:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif type_op == 1:",
      "mutated_line": "elif type_op == -1:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == -1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "result = 1",
      "mutated_line": "result = 2",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 2\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "result = 1",
      "mutated_line": "result = 0",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 0\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "result = 1",
      "mutated_line": "result = 0",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 0\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "result = 1",
      "mutated_line": "result = -1",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = -1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for ran in range(L, R + 1):",
      "mutated_line": "for ran in range(L, R + 2):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 2):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for ran in range(L, R + 1):",
      "mutated_line": "for ran in range(L, R + 0):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 0):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for ran in range(L, R + 1):",
      "mutated_line": "for ran in range(L, R + 0):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 0):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for ran in range(L, R + 1):",
      "mutated_line": "for ran in range(L, R + -1):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + -1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "index[ran] += 1",
      "mutated_line": "index[ran] += 2",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 2\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "index[ran] += 1",
      "mutated_line": "index[ran] += 0",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 0\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "index[ran] += 1",
      "mutated_line": "index[ran] += 0",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 0\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "index[ran] += 1",
      "mutated_line": "index[ran] += -1",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += -1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "for ran in range(L, R + 1):",
      "mutated_line": "for ran in range(L, R - 1):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R - 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "for ran in range(L, R + 1):",
      "mutated_line": "for ran in range(L, R * 1):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R * 1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if index[ran] < factors[ran]:",
      "mutated_line": "if index[ran] <= factors[ran]:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] <= factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if index[ran] < factors[ran]:",
      "mutated_line": "if index[ran] >= factors[ran]:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] >= factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if index[ran] < factors[ran]:",
      "mutated_line": "if index[ran] != factors[ran]:",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 1):\n                if index[ran] != factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "for ran in range(L, R + 1):",
      "mutated_line": "for ran in range(L, R + 2):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 2):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "for ran in range(L, R + 1):",
      "mutated_line": "for ran in range(L, R + 0):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 0):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "for ran in range(L, R + 1):",
      "mutated_line": "for ran in range(L, R + 0):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + 0):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "for ran in range(L, R + 1):",
      "mutated_line": "for ran in range(L, R + -1):",
      "code": "import math\n\ndef least_prime_divisor(x):\n    \"\"\"Helper function to find the least prime divisor of x.\"\"\"\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\ndef process_operations(arr, operations):\n    \"\"\"\n    Process the given operations on the array and return the results of Get operations.\n\n    Parameters:\n    - arr: List of integers representing the initial array.\n    - operations: List of tuples (type, L, R) where type is 0 for Update and 1 for Get,\n                  L and R are the indices for the operation.\n\n    Returns:\n    - List of results for each Get operation.\n    \"\"\"\n    n = len(arr)\n    Matrix = []\n    factors = [0] * n\n    index = [0] * n\n    results = []\n    for r in range(n):\n        li = []\n        x = arr[r]\n        while x != 1:\n            lpd = least_prime_divisor(x)\n            while x % lpd == 0:\n                x //= lpd\n                li.append(lpd)\n                factors[r] += 1\n        Matrix.append(li)\n    for opr in operations:\n        (type_op, L, R) = opr\n        L -= 1\n        R -= 1\n        if type_op == 0:\n            for ran in range(L, R + 1):\n                if index[ran] < factors[ran]:\n                    index[ran] += 1\n        elif type_op == 1:\n            result = 1\n            for ran in range(L, R + -1):\n                if index[ran] < factors[ran]:\n                    result = max(result, Matrix[ran][index[ran]])\n            results.append(result)\n    return results"
    }
  ]
}