{
  "task_id": "taco_18003",
  "entry_point": "get_dist",
  "mutant_count": 130,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 2) * (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) * (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return x ** 2 + y ** 2 + 1 / 2",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return x ** 2 + y ** 2 + 1 / 2\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if angle < 0:",
      "mutated_line": "if angle <= 0:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle <= 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if angle < 0:",
      "mutated_line": "if angle >= 0:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle >= 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if angle < 0:",
      "mutated_line": "if angle != 0:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle != 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "angle += math.pi * 2",
      "mutated_line": "angle -= math.pi * 2",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle -= math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "ufo.dist -= ufo.v",
      "mutated_line": "ufo.dist += ufo.v",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist += ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if diff > math.pi:",
      "mutated_line": "if diff >= math.pi:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff >= math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if diff > math.pi:",
      "mutated_line": "if diff <= math.pi:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff <= math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if diff > math.pi:",
      "mutated_line": "if diff != math.pi:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff != math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if (diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad) and ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if (diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad) and ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return True\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 1\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = -1\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 1\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 50,
      "original_line": "ans += reache(ufos_objects, R)",
      "mutated_line": "ans -= reache(ufos_objects, R)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans -= reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 - y ** 2) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 - y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 * y ** 2) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 * y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 2) ** (1 * 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 * 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 2) ** (1 // 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 // 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if angle < 0:",
      "mutated_line": "if angle < 1:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 1:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if angle < 0:",
      "mutated_line": "if angle < -1:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < -1:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if angle < 0:",
      "mutated_line": "if angle < 1:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 1:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "angle += math.pi * 2",
      "mutated_line": "angle += math.pi / 2",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi / 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "angle += math.pi * 2",
      "mutated_line": "angle += math.pi + 2",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi + 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "angle += math.pi * 2",
      "mutated_line": "angle += math.pi ** 2",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi ** 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if ufo.dist <= R:",
      "mutated_line": "if ufo.dist < R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist < R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if ufo.dist <= R:",
      "mutated_line": "if ufo.dist > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist > R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if ufo.dist <= R:",
      "mutated_line": "if ufo.dist == R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist == R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "diff = abs(ufo.angle - laser)",
      "mutated_line": "diff = abs(ufo.angle + laser)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle + laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "diff = abs(ufo.angle - laser)",
      "mutated_line": "diff = abs(ufo.angle * laser)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle * laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "diff = math.pi * 2 - diff",
      "mutated_line": "diff = math.pi * 2 + diff",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 + diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "diff = math.pi * 2 - diff",
      "mutated_line": "diff = math.pi * 2 * diff",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 * diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if (diff <= math.pi / 2 or ufo.dist * math.sin(diff) <= ufo.rad) or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if (diff <= math.pi / 2 or ufo.dist * math.sin(diff) <= ufo.rad) or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist < ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist < ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist > ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist > ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist == ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist == ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) >= R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) >= R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) <= R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) <= R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) != R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) != R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x * 2 + y ** 2) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x * 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x + 2 + y ** 2) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x + 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y * 2) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y * 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + (y + 2)) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + (y + 2)) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 2) ** (2 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (2 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 2) ** (0 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (0 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 2) ** (0 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (0 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 2) ** (-1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (-1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 2) ** (1 / 3)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 3)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 2) ** (1 / 1)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 1)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 2) ** (1 / 0)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 0)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 2) ** (1 / 1)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 1)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 2) ** (1 / -2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / -2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "angle += math.pi * 2",
      "mutated_line": "angle += math.pi * 3",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 3\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "angle += math.pi * 2",
      "mutated_line": "angle += math.pi * 1",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 1\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "angle += math.pi * 2",
      "mutated_line": "angle += math.pi * 0",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 0\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "angle += math.pi * 2",
      "mutated_line": "angle += math.pi * 1",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 1\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "angle += math.pi * 2",
      "mutated_line": "angle += math.pi * -2",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * -2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "diff = math.pi * 2 - diff",
      "mutated_line": "diff = math.pi / 2 - diff",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi / 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "diff = math.pi * 2 - diff",
      "mutated_line": "diff = math.pi + 2 - diff",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi + 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "diff = math.pi * 2 - diff",
      "mutated_line": "diff = math.pi ** 2 - diff",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi ** 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff < math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff < math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff > math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff > math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff == math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff == math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) < ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) < ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) > ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) > ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) == ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) == ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) - (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) - (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) * (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) * (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return False\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 3 + y ** 2) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 3 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 1 + y ** 2) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 1 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 0 + y ** 2) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 0 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 1 + y ** 2) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 1 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** -2 + y ** 2) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** -2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 3) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 3) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 1) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 1) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 0) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 0) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** 1) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 1) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (x ** 2 + y ** 2) ** (1 / 2)",
      "mutated_line": "return (x ** 2 + y ** -2) ** (1 / 2)",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** -2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "diff = math.pi * 2 - diff",
      "mutated_line": "diff = math.pi * 3 - diff",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 3 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "diff = math.pi * 2 - diff",
      "mutated_line": "diff = math.pi * 1 - diff",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 1 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "diff = math.pi * 2 - diff",
      "mutated_line": "diff = math.pi * 0 - diff",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 0 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "diff = math.pi * 2 - diff",
      "mutated_line": "diff = math.pi * 1 - diff",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 1 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "diff = math.pi * 2 - diff",
      "mutated_line": "diff = math.pi * -2 - diff",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * -2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi * 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi * 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi // 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi // 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi / 2 and ufo.dist / math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist / math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi / 2 and ufo.dist + math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist + math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi / 2 and ufo.dist ** math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist ** math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist / math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist / math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist + math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist + math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist ** math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist ** math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) * (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) * (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2 + 1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2 + 1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi / 3 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 3 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi / 1 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 1 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi / 0 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 0 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi / 1 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 1 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "mutated_line": "if diff <= math.pi / -2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / -2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 + (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 + (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 * (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 * (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 * 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 * 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 // 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 // 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad * 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad * 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad + 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad + 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - ufo.dist * math.sin(diff) * 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - ufo.dist * math.sin(diff) * 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff) + 2)) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff) + 2)) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (2 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (2 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (0 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (0 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (0 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (0 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (-1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (-1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 3) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 3) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 1) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 1) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 0) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 0) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 1) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 1) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / -2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / -2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 3 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 3 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 1 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 1 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 0 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 0 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 1 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 1 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** -2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** -2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist / math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist / math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist + math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist + math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist ** math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist ** math.sin(diff)) ** 2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 3) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 3) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 1) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 1) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 0) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 0) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 1) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 1) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** 2) ** (1 / 2) > R:",
      "mutated_line": "if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** -2) ** (1 / 2) > R:",
      "code": "import math\n\nclass Ufo:\n\n    def __init__(self, x, y, r, v):\n        self.dist = get_dist(x, y)\n        self.angle = get_angle(y, x)\n        self.rad = r\n        self.v = v\n\ndef get_dist(x, y):\n    return (x ** 2 + y ** 2) ** (1 / 2)\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return angle\n\ndef reache(ufos, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        ufo.dist -= ufo.v\n        if ufo.dist <= R:\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n    return len(remove_lst)\n\ndef is_dead(ufo, laser, R):\n    diff = abs(ufo.angle - laser)\n    if diff > math.pi:\n        diff = math.pi * 2 - diff\n    if diff <= math.pi / 2 and ufo.dist * math.sin(diff) <= ufo.rad or ufo.dist <= ufo.rad:\n        if ufo.dist * math.cos(diff) + (ufo.rad ** 2 - (ufo.dist * math.sin(diff)) ** -2) ** (1 / 2) > R:\n            return True\n    return False\n\ndef shoot(ufos, laser, R):\n    remove_lst = []\n    for (i, ufo) in enumerate(ufos):\n        if is_dead(ufo, laser, R):\n            remove_lst.append(i)\n    for i in reversed(remove_lst):\n        ufos.pop(i)\n\ndef calculate_invading_ufos(R, ufos):\n    ufos_objects = [Ufo(x0, y0, r, v) for (x0, y0, r, v) in ufos]\n    ans = 0\n    while ufos_objects:\n        ans += reache(ufos_objects, R)\n        if ufos_objects:\n            laser = min(ufos_objects, key=lambda ufo: ufo.dist).angle\n            shoot(ufos_objects, laser, R)\n    return ans"
    }
  ]
}