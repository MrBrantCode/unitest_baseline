{
  "task_id": "taco_18029",
  "entry_point": "minimum_rap_battles_for_ordering",
  "mutant_count": 84,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lo = 0",
      "mutated_line": "lo = 1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 1\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lo = 0",
      "mutated_line": "lo = -1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = -1\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lo = 0",
      "mutated_line": "lo = 1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 1\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "curr_k = -1",
      "mutated_line": "curr_k = +1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = +1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while lo <= hi:",
      "mutated_line": "while lo < hi:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while lo <= hi:",
      "mutated_line": "while lo > hi:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo > hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while lo <= hi:",
      "mutated_line": "while lo == hi:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo == hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "curr_k = -1",
      "mutated_line": "curr_k = -2",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -2\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "curr_k = -1",
      "mutated_line": "curr_k = -0",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -0\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "curr_k = -1",
      "mutated_line": "curr_k = -0",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -0\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "curr_k = -1",
      "mutated_line": "curr_k = --1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = --1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "mid = lo + (hi - lo) // 2",
      "mutated_line": "mid = lo - (hi - lo) // 2",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo - (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "mid = lo + (hi - lo) // 2",
      "mutated_line": "mid = lo * ((hi - lo) // 2)",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo * ((hi - lo) // 2)\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "can_do = True",
      "mutated_line": "can_do = False",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = False\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "in_degree = [0] * n",
      "mutated_line": "in_degree = [0] / n",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] / n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "in_degree = [0] * n",
      "mutated_line": "in_degree = [0] + n",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] + n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "in_degree = [0] * n",
      "mutated_line": "in_degree = [0] ** n",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] ** n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "in_degree[edge[1]] += 1",
      "mutated_line": "in_degree[edge[1]] -= 1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] -= 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(res) < n:",
      "mutated_line": "if len(res) <= n:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) <= n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(res) < n:",
      "mutated_line": "if len(res) >= n:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) >= n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(res) < n:",
      "mutated_line": "if len(res) != n:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) != n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "mid = lo + (hi - lo) // 2",
      "mutated_line": "mid = lo + (hi - lo) / 2",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) / 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "mid = lo + (hi - lo) // 2",
      "mutated_line": "mid = lo + (hi - lo) * 2",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) * 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_degree[edge[1]] += 1",
      "mutated_line": "in_degree[edge[1]] += 2",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 2\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_degree[edge[1]] += 1",
      "mutated_line": "in_degree[edge[1]] += 0",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 0\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_degree[edge[1]] += 1",
      "mutated_line": "in_degree[edge[1]] += 0",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 0\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_degree[edge[1]] += 1",
      "mutated_line": "in_degree[edge[1]] += -1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += -1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if in_degree[i] == 0:",
      "mutated_line": "if in_degree[i] != 0:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] != 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if len(candidates) > 0:",
      "mutated_line": "if len(candidates) >= 0:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) >= 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if len(candidates) > 0:",
      "mutated_line": "if len(candidates) <= 0:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) <= 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if len(candidates) > 0:",
      "mutated_line": "if len(candidates) != 0:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) != 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "in_degree[i] -= 1",
      "mutated_line": "in_degree[i] += 1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] += 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "can_do = False",
      "mutated_line": "can_do = True",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = True\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid + 1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid + 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid * 1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid * 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "lo = mid + 1",
      "mutated_line": "lo = mid - 1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid - 1\n    return curr_k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "lo = mid + 1",
      "mutated_line": "lo = mid * 1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid * 1\n    return curr_k"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "mid = lo + (hi - lo) // 2",
      "mutated_line": "mid = lo + (hi + lo) // 2",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi + lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "mid = lo + (hi - lo) // 2",
      "mutated_line": "mid = lo + hi * lo // 2",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + hi * lo // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mid = lo + (hi - lo) // 2",
      "mutated_line": "mid = lo + (hi - lo) // 3",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 3\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mid = lo + (hi - lo) // 2",
      "mutated_line": "mid = lo + (hi - lo) // 1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 1\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mid = lo + (hi - lo) // 2",
      "mutated_line": "mid = lo + (hi - lo) // 0",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 0\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mid = lo + (hi - lo) // 2",
      "mutated_line": "mid = lo + (hi - lo) // 1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 1\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mid = lo + (hi - lo) // 2",
      "mutated_line": "mid = lo + (hi - lo) // -2",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // -2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "in_degree = [0] * n",
      "mutated_line": "in_degree = [1] * n",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [1] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "in_degree = [0] * n",
      "mutated_line": "in_degree = [-1] * n",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [-1] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "in_degree = [0] * n",
      "mutated_line": "in_degree = [1] * n",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [1] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if in_degree[i] == 0:",
      "mutated_line": "if in_degree[i] == 1:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 1:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if in_degree[i] == 0:",
      "mutated_line": "if in_degree[i] == -1:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == -1:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if in_degree[i] == 0:",
      "mutated_line": "if in_degree[i] == 1:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 1:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ele = candidates.pop(0)",
      "mutated_line": "ele = candidates.pop(1)",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(1)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ele = candidates.pop(0)",
      "mutated_line": "ele = candidates.pop(-1)",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(-1)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ele = candidates.pop(0)",
      "mutated_line": "ele = candidates.pop(1)",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(1)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(candidates) > 0:",
      "mutated_line": "if len(candidates) > 1:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 1:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(candidates) > 0:",
      "mutated_line": "if len(candidates) > -1:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > -1:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(candidates) > 0:",
      "mutated_line": "if len(candidates) > 1:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 1:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "can_do = False",
      "mutated_line": "can_do = True",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = True\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "in_degree[i] -= 1",
      "mutated_line": "in_degree[i] -= 2",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 2\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "in_degree[i] -= 1",
      "mutated_line": "in_degree[i] -= 0",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 0\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "in_degree[i] -= 1",
      "mutated_line": "in_degree[i] -= 0",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 0\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "in_degree[i] -= 1",
      "mutated_line": "in_degree[i] -= -1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= -1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if in_degree[i] == 0:",
      "mutated_line": "if in_degree[i] != 0:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] != 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid - 2",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 2\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid - 0",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 0\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid - 0",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 0\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "hi = mid - 1",
      "mutated_line": "hi = mid - -1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - -1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "lo = mid + 1",
      "mutated_line": "lo = mid + 2",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 2\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "lo = mid + 1",
      "mutated_line": "lo = mid + 0",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 0\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "lo = mid + 1",
      "mutated_line": "lo = mid + 0",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 0\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "lo = mid + 1",
      "mutated_line": "lo = mid + -1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + -1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj_list[edge[0]].append(edge[1])",
      "mutated_line": "adj_list[edge[0]].append(edge[2])",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[2])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj_list[edge[0]].append(edge[1])",
      "mutated_line": "adj_list[edge[0]].append(edge[0])",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[0])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj_list[edge[0]].append(edge[1])",
      "mutated_line": "adj_list[edge[0]].append(edge[0])",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[0])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj_list[edge[0]].append(edge[1])",
      "mutated_line": "adj_list[edge[0]].append(edge[-1])",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[-1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_degree[edge[1]] += 1",
      "mutated_line": "in_degree[edge[2]] += 1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[2]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_degree[edge[1]] += 1",
      "mutated_line": "in_degree[edge[0]] += 1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[0]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_degree[edge[1]] += 1",
      "mutated_line": "in_degree[edge[0]] += 1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[0]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_degree[edge[1]] += 1",
      "mutated_line": "in_degree[edge[-1]] += 1",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[-1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if in_degree[i] == 0:",
      "mutated_line": "if in_degree[i] == 1:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 1:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if in_degree[i] == 0:",
      "mutated_line": "if in_degree[i] == -1:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == -1:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if in_degree[i] == 0:",
      "mutated_line": "if in_degree[i] == 1:",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 1:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj_list[edge[0]].append(edge[1])",
      "mutated_line": "adj_list[edge[1]].append(edge[1])",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[1]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj_list[edge[0]].append(edge[1])",
      "mutated_line": "adj_list[edge[-1]].append(edge[1])",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[-1]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj_list[edge[0]].append(edge[1])",
      "mutated_line": "adj_list[edge[1]].append(edge[1])",
      "code": "def minimum_rap_battles_for_ordering(n, m, edges):\n    lo = 0\n    hi = m\n    curr_k = -1\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n        can_do = True\n        adj_list = {x: [] for x in range(n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[1]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        if len(res) < n:\n            can_do = False\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return curr_k"
    }
  ]
}