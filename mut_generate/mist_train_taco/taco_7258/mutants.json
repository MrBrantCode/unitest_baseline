{
  "task_id": "taco_7258",
  "entry_point": "count_winning_paths",
  "mutant_count": 184,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 - 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 * 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h + w + 1) / 2",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) / 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = h + w + 1 + 2",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = h + w + 1 + 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h + w + 1) ** 2",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) ** 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fac = [1] * N",
      "mutated_line": "fac = [1] / N",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] / N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fac = [1] * N",
      "mutated_line": "fac = [1] + N",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] + N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fac = [1] * N",
      "mutated_line": "fac = [1] ** N",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] ** N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inv = [1] * N",
      "mutated_line": "inv = [1] / N",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] / N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inv = [1] * N",
      "mutated_line": "inv = [1] + N",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] + N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inv = [1] * N",
      "mutated_line": "inv = [1] ** N",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] ** N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 * 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 + 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 8\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 6\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 0\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 1\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + -7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h + w - 1) * 2",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w - 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h + w) * 1 * 2",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w) * 1 * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h + w + 1) * 3",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 3\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h + w + 1) * 1",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 1\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h + w + 1) * 0",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 0\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h + w + 1) * 1",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 1\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h + w + 1) * -2",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * -2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, N):",
      "mutated_line": "for i in range(3, N):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(3, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, N):",
      "mutated_line": "for i in range(1, N):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(1, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(0, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, N):",
      "mutated_line": "for i in range(1, N):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(1, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, N):",
      "mutated_line": "for i in range(-2, N):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(-2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "fac[i] = i * fac[i - 1] % MOD",
      "mutated_line": "fac[i] = i * fac[i - 1] * MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] * MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "fac[i] = i * fac[i - 1] % MOD",
      "mutated_line": "fac[i] = i * fac[i - 1] + MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] + MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "inv[i] = -(MOD // i) * inv[MOD % i] % MOD",
      "mutated_line": "inv[i] = -(MOD // i) * inv[MOD % i] * MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] * MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "inv[i] = -(MOD // i) * inv[MOD % i] % MOD",
      "mutated_line": "inv[i] = -(MOD // i) * inv[MOD % i] + MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] + MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, N):",
      "mutated_line": "for i in range(3, N):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(3, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, N):",
      "mutated_line": "for i in range(1, N):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(1, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(0, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, N):",
      "mutated_line": "for i in range(1, N):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(1, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(2, N):",
      "mutated_line": "for i in range(-2, N):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(-2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inv[i] = inv[i] * inv[i - 1] % MOD",
      "mutated_line": "inv[i] = inv[i] * inv[i - 1] * MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] * MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inv[i] = inv[i] * inv[i - 1] % MOD",
      "mutated_line": "inv[i] = inv[i] * inv[i - 1] + MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] + MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[u] * inv[v] % MOD * inv[u - v] % MOD",
      "mutated_line": "return fac[u] * inv[v] % MOD * inv[u - v] * MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] * MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[u] * inv[v] % MOD * inv[u - v] % MOD",
      "mutated_line": "return fac[u] * inv[v] % MOD * inv[u - v] + MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] + MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n - 1):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n - 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n * 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 11 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 9 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 0 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 1 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = -10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 10 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 8 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 0 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 1 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** -9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h - w + 1) * 2",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h - w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h * w + 1) * 2",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h * w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h + w + 2) * 2",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 2) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h + w + 0) * 2",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 0) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h + w + 0) * 2",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 0) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "N = (h + w + 1) * 2",
      "mutated_line": "N = (h + w + -1) * 2",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + -1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac = [1] * N",
      "mutated_line": "fac = [2] * N",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [2] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac = [1] * N",
      "mutated_line": "fac = [0] * N",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [0] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac = [1] * N",
      "mutated_line": "fac = [0] * N",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [0] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac = [1] * N",
      "mutated_line": "fac = [-1] * N",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [-1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv = [1] * N",
      "mutated_line": "inv = [2] * N",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [2] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv = [1] * N",
      "mutated_line": "inv = [0] * N",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [0] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv = [1] * N",
      "mutated_line": "inv = [0] * N",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [0] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "inv = [1] * N",
      "mutated_line": "inv = [-1] * N",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [-1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "fac[i] = i * fac[i - 1] % MOD",
      "mutated_line": "fac[i] = i / fac[i - 1] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i / fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "fac[i] = i * fac[i - 1] % MOD",
      "mutated_line": "fac[i] = (i + fac[i - 1]) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = (i + fac[i - 1]) % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "fac[i] = i * fac[i - 1] % MOD",
      "mutated_line": "fac[i] = i ** fac[i - 1] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i ** fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "inv[i] = -(MOD // i) * inv[MOD % i] % MOD",
      "mutated_line": "inv[i] = -(MOD // i) / inv[MOD % i] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) / inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "inv[i] = -(MOD // i) * inv[MOD % i] % MOD",
      "mutated_line": "inv[i] = (-(MOD // i) + inv[MOD % i]) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = (-(MOD // i) + inv[MOD % i]) % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "inv[i] = -(MOD // i) * inv[MOD % i] % MOD",
      "mutated_line": "inv[i] = (-(MOD // i)) ** inv[MOD % i] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = (-(MOD // i)) ** inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inv[i] = inv[i] * inv[i - 1] % MOD",
      "mutated_line": "inv[i] = inv[i] / inv[i - 1] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] / inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inv[i] = inv[i] * inv[i - 1] % MOD",
      "mutated_line": "inv[i] = (inv[i] + inv[i - 1]) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = (inv[i] + inv[i - 1]) % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inv[i] = inv[i] * inv[i - 1] % MOD",
      "mutated_line": "inv[i] = inv[i] ** inv[i - 1] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] ** inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[u] * inv[v] % MOD * inv[u - v] % MOD",
      "mutated_line": "return fac[u] * inv[v] % MOD / inv[u - v] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD / inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[u] * inv[v] % MOD * inv[u - v] % MOD",
      "mutated_line": "return (fac[u] * inv[v] % MOD + inv[u - v]) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return (fac[u] * inv[v] % MOD + inv[u - v]) % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[u] * inv[v] % MOD * inv[u - v] % MOD",
      "mutated_line": "return (fac[u] * inv[v] % MOD) ** inv[u - v] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return (fac[u] * inv[v] % MOD) ** inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 2):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 2):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 0):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 0):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + -1):",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + -1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if black_cells[j][1] <= black_cells[i][1]:",
      "mutated_line": "if black_cells[j][1] < black_cells[i][1]:",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] < black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if black_cells[j][1] <= black_cells[i][1]:",
      "mutated_line": "if black_cells[j][1] > black_cells[i][1]:",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] > black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if black_cells[j][1] <= black_cells[i][1]:",
      "mutated_line": "if black_cells[j][1] == black_cells[i][1]:",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] == black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "inv[i] = -(MOD // i) * inv[MOD % i] % MOD",
      "mutated_line": "inv[i] = +(MOD // i) * inv[MOD % i] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = +(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[u] * inv[v] % MOD * inv[u - v] % MOD",
      "mutated_line": "return fac[u] * inv[v] * MOD * inv[u - v] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] * MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[u] * inv[v] % MOD * inv[u - v] % MOD",
      "mutated_line": "return (fac[u] * inv[v] + MOD) * inv[u - v] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return (fac[u] * inv[v] + MOD) * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] + 2, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] + 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C((black_cells[i][0] + black_cells[i][1]) * 2, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C((black_cells[i][0] + black_cells[i][1]) * 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] + 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] + 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] * 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] * 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) * MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) * MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD + MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD + MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "fac[i] = i * fac[i - 1] % MOD",
      "mutated_line": "fac[i] = i * fac[i + 1] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i + 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "fac[i] = i * fac[i - 1] % MOD",
      "mutated_line": "fac[i] = i * fac[i * 1] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i * 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "inv[i] = -(MOD // i) * inv[MOD % i] % MOD",
      "mutated_line": "inv[i] = -(MOD / i) * inv[MOD % i] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD / i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "inv[i] = -(MOD // i) * inv[MOD % i] % MOD",
      "mutated_line": "inv[i] = -(MOD * i) * inv[MOD % i] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD * i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "inv[i] = -(MOD // i) * inv[MOD % i] % MOD",
      "mutated_line": "inv[i] = -(MOD // i) * inv[MOD * i] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD * i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "inv[i] = -(MOD // i) * inv[MOD % i] % MOD",
      "mutated_line": "inv[i] = -(MOD // i) * inv[MOD + i] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD + i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inv[i] = inv[i] * inv[i - 1] % MOD",
      "mutated_line": "inv[i] = inv[i] * inv[i + 1] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i + 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inv[i] = inv[i] * inv[i - 1] % MOD",
      "mutated_line": "inv[i] = inv[i] * inv[i * 1] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i * 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[u] * inv[v] % MOD * inv[u - v] % MOD",
      "mutated_line": "return fac[u] / inv[v] % MOD * inv[u - v] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] / inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[u] * inv[v] % MOD * inv[u - v] % MOD",
      "mutated_line": "return (fac[u] + inv[v]) % MOD * inv[u - v] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return (fac[u] + inv[v]) % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[u] * inv[v] % MOD * inv[u - v] % MOD",
      "mutated_line": "return fac[u] ** inv[v] % MOD * inv[u - v] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] ** inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[u] * inv[v] % MOD * inv[u - v] % MOD",
      "mutated_line": "return fac[u] * inv[v] % MOD * inv[u + v] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u + v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[u] * inv[v] % MOD * inv[u - v] % MOD",
      "mutated_line": "return fac[u] * inv[v] % MOD * inv[u * v] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u * v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] - black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] - black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] * black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] * black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 3, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 3, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 1, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 1, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 0, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 0, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 1, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 1, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - -2, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - -2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 2))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 2))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 0))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 0))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 0))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 0))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - -1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - -1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if black_cells[j][1] <= black_cells[i][1]:",
      "mutated_line": "if black_cells[j][2] <= black_cells[i][1]:",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][2] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if black_cells[j][1] <= black_cells[i][1]:",
      "mutated_line": "if black_cells[j][0] <= black_cells[i][1]:",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][0] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if black_cells[j][1] <= black_cells[i][1]:",
      "mutated_line": "if black_cells[j][0] <= black_cells[i][1]:",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][0] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if black_cells[j][1] <= black_cells[i][1]:",
      "mutated_line": "if black_cells[j][-1] <= black_cells[i][1]:",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][-1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if black_cells[j][1] <= black_cells[i][1]:",
      "mutated_line": "if black_cells[j][1] <= black_cells[i][2]:",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][2]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if black_cells[j][1] <= black_cells[i][1]:",
      "mutated_line": "if black_cells[j][1] <= black_cells[i][0]:",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][0]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if black_cells[j][1] <= black_cells[i][1]:",
      "mutated_line": "if black_cells[j][1] <= black_cells[i][0]:",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][0]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if black_cells[j][1] <= black_cells[i][1]:",
      "mutated_line": "if black_cells[j][1] <= black_cells[i][-1]:",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][-1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD + d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD + d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD) * (d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD) * (d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fac[i] = i * fac[i - 1] % MOD",
      "mutated_line": "fac[i] = i * fac[i - 2] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 2] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fac[i] = i * fac[i - 1] % MOD",
      "mutated_line": "fac[i] = i * fac[i - 0] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 0] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fac[i] = i * fac[i - 1] % MOD",
      "mutated_line": "fac[i] = i * fac[i - 0] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 0] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fac[i] = i * fac[i - 1] % MOD",
      "mutated_line": "fac[i] = i * fac[i - -1] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - -1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "inv[i] = inv[i] * inv[i - 1] % MOD",
      "mutated_line": "inv[i] = inv[i] * inv[i - 2] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 2] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "inv[i] = inv[i] * inv[i - 1] % MOD",
      "mutated_line": "inv[i] = inv[i] * inv[i - 0] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 0] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "inv[i] = inv[i] * inv[i - 1] % MOD",
      "mutated_line": "inv[i] = inv[i] * inv[i - 0] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 0] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "inv[i] = inv[i] * inv[i - 1] % MOD",
      "mutated_line": "inv[i] = inv[i] * inv[i - -1] % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - -1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][1] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][1] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][-1] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][-1] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][1] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][1] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] - MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] - MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] * MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] * MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) * MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) * MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - (d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) + MOD)) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - (d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) + MOD)) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][1] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][1] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][-1] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][-1] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][1] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][1] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][2] - 2, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][2] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][0] - 2, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][0] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][0] - 2, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][0] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))",
      "mutated_line": "d.append(C(black_cells[i][0] + black_cells[i][-1] - 2, black_cells[i][0] - 1))",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][-1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] / C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] / C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - (d[j] + C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0])) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - (d[j] + C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0])) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] ** C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] ** C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] + black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] + black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C((black_cells[i][0] + black_cells[i][1] - black_cells[j][0]) * black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C((black_cells[i][0] + black_cells[i][1] - black_cells[j][0]) * black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] + black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] + black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] * black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] * black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] + black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] + black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C((black_cells[i][0] + black_cells[i][1]) * black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C((black_cells[i][0] + black_cells[i][1]) * black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] - black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] - black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] * black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] * black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][2], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][2], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][0], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][0], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][0], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][0], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][-1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][-1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][1] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][1] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][-1] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][-1] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][1] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][1] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][1]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][1]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][-1]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][-1]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][1]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][1]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][1] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][1] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][-1] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][-1] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][1] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][1] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][1] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][1] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][-1] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][-1] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][1] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][1] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][2] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][2] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][0] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][0] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][0] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][0] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "mutated_line": "d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][-1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD",
      "code": "def count_winning_paths(h: int, w: int, n: int, black_cells: list) -> int:\n    MOD = 10 ** 9 + 7\n    N = (h + w + 1) * 2\n    fac = [1] * N\n    inv = [1] * N\n    for i in range(2, N):\n        fac[i] = i * fac[i - 1] % MOD\n        inv[i] = -(MOD // i) * inv[MOD % i] % MOD\n    for i in range(2, N):\n        inv[i] = inv[i] * inv[i - 1] % MOD\n\n    def C(u, v):\n        return fac[u] * inv[v] % MOD * inv[u - v] % MOD\n    black_cells.sort()\n    black_cells.append((h, w))\n    d = []\n    for i in range(n + 1):\n        d.append(C(black_cells[i][0] + black_cells[i][1] - 2, black_cells[i][0] - 1))\n        for j in range(i):\n            if black_cells[j][1] <= black_cells[i][1]:\n                d[i] = (d[i] + MOD - d[j] * C(black_cells[i][0] + black_cells[i][-1] - black_cells[j][0] - black_cells[j][1], black_cells[i][0] - black_cells[j][0]) % MOD) % MOD\n    return d[n]"
    }
  ]
}