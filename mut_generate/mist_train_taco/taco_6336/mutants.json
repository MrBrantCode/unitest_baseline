{
  "task_id": "taco_6336",
  "entry_point": "minimum_seconds_to_pass_level",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "costs = [0] * n",
      "mutated_line": "costs = [0] / n",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] / n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "costs = [0] * n",
      "mutated_line": "costs = [0] + n",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] + n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "costs = [0] * n",
      "mutated_line": "costs = [0] ** n",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] ** n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "costs[i] += y * (i - p + 1)",
      "mutated_line": "costs[i] -= y * (i - p + 1)",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] -= y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n + 1, p - 2, -1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n + 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n * 1, p - 2, -1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n * 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 1, p + 2, -1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p + 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 1, p * 2, -1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p * 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 1, p - 2, +1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, +1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if i + k < n:",
      "mutated_line": "if i + k <= n:",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k <= n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if i + k < n:",
      "mutated_line": "if i + k >= n:",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k >= n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if i + k < n:",
      "mutated_line": "if i + k != n:",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k != n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if blocks[i] == '0':",
      "mutated_line": "if blocks[i] != '0':",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] != '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "costs[i] += x",
      "mutated_line": "costs[i] -= x",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] -= x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(p - 1, n):",
      "mutated_line": "for i in range(p + 1, n):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p + 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(p - 1, n):",
      "mutated_line": "for i in range(p * 1, n):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p * 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "costs[i] += y * (i - p + 1)",
      "mutated_line": "costs[i] += y / (i - p + 1)",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y / (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "costs[i] += y * (i - p + 1)",
      "mutated_line": "costs[i] += y + (i - p + 1)",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y + (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "costs[i] += y * (i - p + 1)",
      "mutated_line": "costs[i] += y ** (i - p + 1)",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y ** (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "costs = [0] * n",
      "mutated_line": "costs = [1] * n",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [1] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "costs = [0] * n",
      "mutated_line": "costs = [-1] * n",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [-1] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "costs = [0] * n",
      "mutated_line": "costs = [1] * n",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [1] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 2, p - 2, -1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 2, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 0, p - 2, -1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 0, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 0, p - 2, -1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 0, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - -1, p - 2, -1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - -1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 1, p - 3, -1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 3, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 1, p - 1, -1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 1, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 1, p - 0, -1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 0, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 1, p - 1, -1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 1, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 1, p - -2, -1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - -2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 1, p - 2, -2):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -2):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 1, p - 2, -0):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -0):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 1, p - 2, -0):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -0):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(n - 1, p - 2, -1):",
      "mutated_line": "for i in range(n - 1, p - 2, --1):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, --1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if i + k < n:",
      "mutated_line": "if i - k < n:",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i - k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if i + k < n:",
      "mutated_line": "if i * k < n:",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i * k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if blocks[i] == '0':",
      "mutated_line": "if blocks[i] == '':",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(p - 1, n):",
      "mutated_line": "for i in range(p - 2, n):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 2, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(p - 1, n):",
      "mutated_line": "for i in range(p - 0, n):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 0, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(p - 1, n):",
      "mutated_line": "for i in range(p - 0, n):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 0, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(p - 1, n):",
      "mutated_line": "for i in range(p - -1, n):",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - -1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "costs[i] += y * (i - p + 1)",
      "mutated_line": "costs[i] += y * (i - p - 1)",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p - 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "costs[i] += y * (i - p + 1)",
      "mutated_line": "costs[i] += y * ((i - p) * 1)",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * ((i - p) * 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "costs[i] = costs[i + k]",
      "mutated_line": "costs[i] = costs[i - k]",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i - k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "costs[i] = costs[i + k]",
      "mutated_line": "costs[i] = costs[i * k]",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i * k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "costs[i] += y * (i - p + 1)",
      "mutated_line": "costs[i] += y * (i + p + 1)",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i + p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "costs[i] += y * (i - p + 1)",
      "mutated_line": "costs[i] += y * (i * p + 1)",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i * p + 1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "costs[i] += y * (i - p + 1)",
      "mutated_line": "costs[i] += y * (i - p + 2)",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 2)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "costs[i] += y * (i - p + 1)",
      "mutated_line": "costs[i] += y * (i - p + 0)",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 0)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "costs[i] += y * (i - p + 1)",
      "mutated_line": "costs[i] += y * (i - p + 0)",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 0)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "costs[i] += y * (i - p + 1)",
      "mutated_line": "costs[i] += y * (i - p + -1)",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + -1)\n    return min(costs[p - 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return min(costs[p - 1:])",
      "mutated_line": "return min(costs[p + 1:])",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p + 1:])"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return min(costs[p - 1:])",
      "mutated_line": "return min(costs[p * 1:])",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p * 1:])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return min(costs[p - 1:])",
      "mutated_line": "return min(costs[p - 2:])",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 2:])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return min(costs[p - 1:])",
      "mutated_line": "return min(costs[p - 0:])",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 0:])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return min(costs[p - 1:])",
      "mutated_line": "return min(costs[p - 0:])",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - 0:])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return min(costs[p - 1:])",
      "mutated_line": "return min(costs[p - -1:])",
      "code": "def minimum_seconds_to_pass_level(n, p, k, blocks, x, y):\n    costs = [0] * n\n    for i in range(n - 1, p - 2, -1):\n        if i + k < n:\n            costs[i] = costs[i + k]\n        if blocks[i] == '0':\n            costs[i] += x\n    for i in range(p - 1, n):\n        costs[i] += y * (i - p + 1)\n    return min(costs[p - -1:])"
    }
  ]
}