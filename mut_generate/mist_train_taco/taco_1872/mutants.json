{
  "task_id": "taco_1872",
  "entry_point": "can_avoid_bad_case",
  "mutant_count": 93,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 'Yes'",
      "mutated_line": "return ''",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f[a, b] = 1",
      "mutated_line": "f[a, b] = 2",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 2\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f[a, b] = 1",
      "mutated_line": "f[a, b] = 0",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 0\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f[a, b] = 1",
      "mutated_line": "f[a, b] = 0",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 0\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f[a, b] = 1",
      "mutated_line": "f[a, b] = -1",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = -1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f[na, nb] = 1",
      "mutated_line": "f[na, nb] = 2",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 2\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f[na, nb] = 1",
      "mutated_line": "f[na, nb] = 0",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 0\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f[na, nb] = 1",
      "mutated_line": "f[na, nb] = 0",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 0\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f[na, nb] = 1",
      "mutated_line": "f[na, nb] = -1",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = -1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if bfs[a, b] < 0:",
      "mutated_line": "if bfs[a, b] <= 0:",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] <= 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if bfs[a, b] < 0:",
      "mutated_line": "if bfs[a, b] >= 0:",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] >= 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if bfs[a, b] < 0:",
      "mutated_line": "if bfs[a, b] != 0:",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] != 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "f = defaultdict(lambda: 0)",
      "mutated_line": "f = defaultdict(lambda : 1)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 1)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "f = defaultdict(lambda: 0)",
      "mutated_line": "f = defaultdict(lambda : -1)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : -1)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "f = defaultdict(lambda: 0)",
      "mutated_line": "f = defaultdict(lambda : 1)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 1)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "dir = 0 if dir == 'x' else 1",
      "mutated_line": "dir = 0 if dir != 'x' else 1",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir != 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dir = 0 if dir == 'x' else 1",
      "mutated_line": "dir = 1 if dir == 'x' else 1",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 1 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dir = 0 if dir == 'x' else 1",
      "mutated_line": "dir = -1 if dir == 'x' else 1",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = -1 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dir = 0 if dir == 'x' else 1",
      "mutated_line": "dir = 1 if dir == 'x' else 1",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 1 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dir = 0 if dir == 'x' else 1",
      "mutated_line": "dir = 0 if dir == 'x' else 2",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 2\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dir = 0 if dir == 'x' else 1",
      "mutated_line": "dir = 0 if dir == 'x' else 0",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 0\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dir = 0 if dir == 'x' else 1",
      "mutated_line": "dir = 0 if dir == 'x' else 0",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 0\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dir = 0 if dir == 'x' else 1",
      "mutated_line": "dir = 0 if dir == 'x' else -1",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else -1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(na, nb) = (a + 1 - dir, b + dir)",
      "mutated_line": "(na, nb) = (a + 1 + dir, b + dir)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 + dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(na, nb) = (a + 1 - dir, b + dir)",
      "mutated_line": "(na, nb) = ((a + 1) * dir, b + dir)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = ((a + 1) * dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(na, nb) = (a + 1 - dir, b + dir)",
      "mutated_line": "(na, nb) = (a + 1 - dir, b - dir)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b - dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(na, nb) = (a + 1 - dir, b + dir)",
      "mutated_line": "(na, nb) = (a + 1 - dir, b * dir)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b * dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "move = [(0, 1), (1, 0)]",
      "mutated_line": "move = [(1, 1), (1, 0)]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(1, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "move = [(0, 1), (1, 0)]",
      "mutated_line": "move = [(-1, 1), (1, 0)]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(-1, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "move = [(0, 1), (1, 0)]",
      "mutated_line": "move = [(1, 1), (1, 0)]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(1, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "move = [(0, 1), (1, 0)]",
      "mutated_line": "move = [(0, 2), (1, 0)]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 2), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "move = [(0, 1), (1, 0)]",
      "mutated_line": "move = [(0, 0), (1, 0)]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 0), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "move = [(0, 1), (1, 0)]",
      "mutated_line": "move = [(0, 0), (1, 0)]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 0), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "move = [(0, 1), (1, 0)]",
      "mutated_line": "move = [(0, -1), (1, 0)]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, -1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "move = [(0, 1), (1, 0)]",
      "mutated_line": "move = [(0, 1), (2, 0)]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (2, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "move = [(0, 1), (1, 0)]",
      "mutated_line": "move = [(0, 1), (0, 0)]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (0, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "move = [(0, 1), (1, 0)]",
      "mutated_line": "move = [(0, 1), (0, 0)]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (0, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "move = [(0, 1), (1, 0)]",
      "mutated_line": "move = [(0, 1), (-1, 0)]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (-1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "move = [(0, 1), (1, 0)]",
      "mutated_line": "move = [(0, 1), (1, 1)]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 1)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "move = [(0, 1), (1, 0)]",
      "mutated_line": "move = [(0, 1), (1, -1)]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, -1)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "move = [(0, 1), (1, 0)]",
      "mutated_line": "move = [(0, 1), (1, 1)]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 1)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if f[na, nb] and (c, d) != (na, nb):",
      "mutated_line": "if f[na, nb] or (c, d) != (na, nb):",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] or (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "bfs = defaultdict(lambda: -1)",
      "mutated_line": "bfs = defaultdict(lambda : +1)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : +1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if bfs[a, b] < 0:",
      "mutated_line": "if bfs[a, b] < 1:",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 1:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if bfs[a, b] < 0:",
      "mutated_line": "if bfs[a, b] < -1:",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < -1:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if bfs[a, b] < 0:",
      "mutated_line": "if bfs[a, b] < 1:",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 1:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "bfs[a, b] = 0",
      "mutated_line": "bfs[a, b] = 1",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 1\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "bfs[a, b] = 0",
      "mutated_line": "bfs[a, b] = -1",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = -1\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "bfs[a, b] = 0",
      "mutated_line": "bfs[a, b] = 1",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 1\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dir = 0 if dir == 'x' else 1",
      "mutated_line": "dir = 0 if dir == '' else 1",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == '' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(na, nb) = (a + 1 - dir, b + dir)",
      "mutated_line": "(na, nb) = (a - 1 - dir, b + dir)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a - 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(na, nb) = (a + 1 - dir, b + dir)",
      "mutated_line": "(na, nb) = (a * 1 - dir, b + dir)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a * 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "v[a, b].append(((na, nb), 1))",
      "mutated_line": "v[a, b].append(((na, nb), 2))",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 2))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "v[a, b].append(((na, nb), 1))",
      "mutated_line": "v[a, b].append(((na, nb), 0))",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 0))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "v[a, b].append(((na, nb), 1))",
      "mutated_line": "v[a, b].append(((na, nb), 0))",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 0))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "v[a, b].append(((na, nb), 1))",
      "mutated_line": "v[a, b].append(((na, nb), -1))",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), -1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "v[na, nb].append(((a, b), 1))",
      "mutated_line": "v[na, nb].append(((a, b), 2))",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 2))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "v[na, nb].append(((a, b), 1))",
      "mutated_line": "v[na, nb].append(((a, b), 0))",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 0))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "v[na, nb].append(((a, b), 1))",
      "mutated_line": "v[na, nb].append(((a, b), 0))",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 0))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "v[na, nb].append(((a, b), 1))",
      "mutated_line": "v[na, nb].append(((a, b), -1))",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), -1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "(na, nb) = (a + dx, b + dy)",
      "mutated_line": "(na, nb) = (a - dx, b + dy)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a - dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "(na, nb) = (a + dx, b + dy)",
      "mutated_line": "(na, nb) = (a * dx, b + dy)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a * dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "(na, nb) = (a + dx, b + dy)",
      "mutated_line": "(na, nb) = (a + dx, b - dy)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b - dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "(na, nb) = (a + dx, b + dy)",
      "mutated_line": "(na, nb) = (a + dx, b * dy)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b * dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if f[na, nb] and (c, d) != (na, nb):",
      "mutated_line": "if f[na, nb] and (c, d) == (na, nb):",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) == (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "bfs = defaultdict(lambda: -1)",
      "mutated_line": "bfs = defaultdict(lambda : -2)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -2)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "bfs = defaultdict(lambda: -1)",
      "mutated_line": "bfs = defaultdict(lambda : -0)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -0)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "bfs = defaultdict(lambda: -1)",
      "mutated_line": "bfs = defaultdict(lambda : -0)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -0)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "bfs = defaultdict(lambda: -1)",
      "mutated_line": "bfs = defaultdict(lambda : --1)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : --1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(na, nb) = (a + 1 - dir, b + dir)",
      "mutated_line": "(na, nb) = (a + 2 - dir, b + dir)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 2 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(na, nb) = (a + 1 - dir, b + dir)",
      "mutated_line": "(na, nb) = (a + 0 - dir, b + dir)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 0 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(na, nb) = (a + 1 - dir, b + dir)",
      "mutated_line": "(na, nb) = (a + 0 - dir, b + dir)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 0 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(na, nb) = (a + 1 - dir, b + dir)",
      "mutated_line": "(na, nb) = (a + -1 - dir, b + dir)",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + -1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if bfs[nx, ny] >= 0:",
      "mutated_line": "if bfs[nx, ny] > 0:",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] > 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if bfs[nx, ny] >= 0:",
      "mutated_line": "if bfs[nx, ny] < 0:",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] < 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if bfs[nx, ny] >= 0:",
      "mutated_line": "if bfs[nx, ny] == 0:",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] == 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v[a, b].append(((na, nb), 0))",
      "mutated_line": "v[a, b].append(((na, nb), 1))",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 1))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v[a, b].append(((na, nb), 0))",
      "mutated_line": "v[a, b].append(((na, nb), -1))",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), -1))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v[a, b].append(((na, nb), 0))",
      "mutated_line": "v[a, b].append(((na, nb), 1))",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 1))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "v[na, nb].append(((a, b), 0))",
      "mutated_line": "v[na, nb].append(((a, b), 1))",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 1))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "v[na, nb].append(((a, b), 0))",
      "mutated_line": "v[na, nb].append(((a, b), -1))",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), -1))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "v[na, nb].append(((a, b), 0))",
      "mutated_line": "v[na, nb].append(((a, b), 1))",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 1))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "nb = 1 - bfs[x, y]",
      "mutated_line": "nb = 1 + bfs[x, y]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 + bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "nb = 1 - bfs[x, y]",
      "mutated_line": "nb = 1 * bfs[x, y]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 * bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if bfs[nx, ny] >= 0:",
      "mutated_line": "if bfs[nx, ny] >= 1:",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 1:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if bfs[nx, ny] >= 0:",
      "mutated_line": "if bfs[nx, ny] >= -1:",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= -1:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if bfs[nx, ny] >= 0:",
      "mutated_line": "if bfs[nx, ny] >= 1:",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 1:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if bfs[nx, ny] != nb:",
      "mutated_line": "if bfs[nx, ny] == nb:",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] == nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "nb = 1 - bfs[x, y]",
      "mutated_line": "nb = 2 - bfs[x, y]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 2 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "nb = 1 - bfs[x, y]",
      "mutated_line": "nb = 0 - bfs[x, y]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 0 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "nb = 1 - bfs[x, y]",
      "mutated_line": "nb = 0 - bfs[x, y]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 0 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "nb = 1 - bfs[x, y]",
      "mutated_line": "nb = -1 - bfs[x, y]",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = -1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return 'No'\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return 'No'",
      "mutated_line": "return ''",
      "code": "def can_avoid_bad_case(n, futons):\n    from collections import defaultdict, deque\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for (a, b, dir) in futons:\n        f[a, b] = 1\n        dir = 0 if dir == 'x' else 1\n        (na, nb) = (a + 1 - dir, b + dir)\n        f[na, nb] = 1\n        l.append((a, b, na, nb))\n        l.append((na, nb, a, b))\n        v[a, b].append(((na, nb), 1))\n        v[na, nb].append(((a, b), 1))\n    move = [(0, 1), (1, 0)]\n    for (a, b, c, d) in l:\n        for (dx, dy) in move:\n            (na, nb) = (a + dx, b + dy)\n            if f[na, nb] and (c, d) != (na, nb):\n                v[a, b].append(((na, nb), 0))\n                v[na, nb].append(((a, b), 0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for (a, b, c, d) in l:\n        if bfs[a, b] < 0:\n            q.append((a, b))\n            bfs[a, b] = 0\n            while q:\n                (x, y) = q.popleft()\n                for (node, k) in v[x, y]:\n                    (nx, ny) = node\n                    if k:\n                        nb = 1 - bfs[x, y]\n                    else:\n                        nb = bfs[x, y]\n                    if bfs[nx, ny] >= 0:\n                        if bfs[nx, ny] != nb:\n                            return ''\n                    else:\n                        bfs[nx, ny] = nb\n                        q.append((nx, ny))\n    return 'Yes'"
    }
  ]
}