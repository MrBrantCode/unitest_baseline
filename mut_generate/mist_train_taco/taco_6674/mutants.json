{
  "task_id": "taco_6674",
  "entry_point": "generate_maze",
  "mutant_count": 539,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L * 2 - 2",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 - 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L * 2 * 2",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 * 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 1",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 1\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = -1",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = -1\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 1",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 1\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 1",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 1\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = -1",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = -1\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 1",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 1\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "p = [0] * 9",
      "mutated_line": "p = [0] / 9",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] / 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "p = [0] * 9",
      "mutated_line": "p = [0] + 9",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] + 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "p = [0] * 9",
      "mutated_line": "p = [0] ** 9",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] ** 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return 1 <= x <= n or 1 <= y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n or 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "T //= 6",
      "mutated_line": "T //= 7",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 7\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "T //= 6",
      "mutated_line": "T //= 5",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 5\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "T //= 6",
      "mutated_line": "T //= 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 0\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "T //= 6",
      "mutated_line": "T //= 1",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 1\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "T //= 6",
      "mutated_line": "T //= -6",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= -6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L / 2 + 2",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L / 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L + 2 + 2",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L + 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L ** 2 + 2",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L ** 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L * 2 + 3",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 3\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L * 2 + 1",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 1\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L * 2 + 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 0\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L * 2 + 1",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 1\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L * 2 + -2",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + -2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[1] / 9 for i in range(7)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] / 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[1] + 9 for i in range(7)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] + 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[1] ** 9 for i in range(7)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] ** 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][3] = f[2][2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][3] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][1] = f[2][2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][1] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][0] = f[2][2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][0] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][1] = f[2][2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][1] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][-2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][-2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][3] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][3] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][1] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][1] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][0] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][0] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][1] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][1] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][-2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][-2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][7] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][7] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][5] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][5] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][0] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][0] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][1] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][1] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][-6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][-6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][6] = f[3][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][6] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][6] = f[3][4] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][4] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][6] = f[3][0] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][0] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][6] = f[3][1] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][1] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][6] = f[3][-5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][-5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][6] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][6] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][4] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][4] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][0] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][0] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][1] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][1] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][-5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][-5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][7] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][7] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][5] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][5] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][0] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][0] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][1] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][1] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][-6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][-6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][3] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][3] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][1] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][1] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][0] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][0] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][1] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][1] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][-2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][-2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][6] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][6] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][4] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][4] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][0] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][0] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][1] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][1] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][-5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][-5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][7] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][7] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][5] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][0] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][0] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][1] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][1] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][-6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][-6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p = [0] * 9",
      "mutated_line": "p = [0] * 10",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 10\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p = [0] * 9",
      "mutated_line": "p = [0] * 8",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 8\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p = [0] * 9",
      "mutated_line": "p = [0] * 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 0\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p = [0] * 9",
      "mutated_line": "p = [0] * 1",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 1\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p = [0] * 9",
      "mutated_line": "p = [0] * -9",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * -9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[2] = (3, 1, 3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[2] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[0] = (3, 1, 3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[0] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[0] = (3, 1, 3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[0] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[-1] = (3, 1, 3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[-1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (4, 1, 3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (4, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (2, 1, 3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (2, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (0, 1, 3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (0, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (1, 1, 3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (1, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (-3, 1, 3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (-3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (3, 2, 3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 2, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (3, 0, 3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 0, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (3, 0, 3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 0, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (3, -1, 3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, -1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (3, 1, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 4, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (3, 1, 2, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 2, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (3, 1, 0, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 0, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (3, 1, 1, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 1, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (3, 1, -3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, -3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (3, 1, 3, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 3)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (3, 1, 3, 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 1)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (3, 1, 3, 0)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 0)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (3, 1, 3, 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 1)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[1] = (3, 1, 3, 2)",
      "mutated_line": "p[1] = (3, 1, 3, -2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, -2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[3] = (4, 1, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[3] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[1] = (4, 1, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[1] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[0] = (4, 1, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[0] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[1] = (4, 1, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[1] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[-2] = (4, 1, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[-2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (5, 1, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (5, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (3, 1, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (3, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (0, 1, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (0, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (1, 1, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (1, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (-4, 1, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (-4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (4, 2, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 2, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (4, 0, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 0, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (4, 0, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 0, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (4, -1, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, -1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (4, 1, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 5, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (4, 1, 3, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 3, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (4, 1, 0, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 0, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (4, 1, 1, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 1, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (4, 1, -4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, -4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (4, 1, 4, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 3)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (4, 1, 4, 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 1)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (4, 1, 4, 0)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 0)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (4, 1, 4, 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 1)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[2] = (4, 1, 4, 2)",
      "mutated_line": "p[2] = (4, 1, 4, -2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, -2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[4] = (4, 2, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[4] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[2] = (4, 2, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[2] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[0] = (4, 2, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[0] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[1] = (4, 2, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[1] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[-3] = (4, 2, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[-3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (5, 2, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (5, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (3, 2, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (3, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (0, 2, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (0, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (1, 2, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (1, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (-4, 2, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (-4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, 3, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 3, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, 1, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 1, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, 0, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 0, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, 1, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 1, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, -2, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, -2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, 2, 6, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 6, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, 2, 4, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 4, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, 2, 0, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 0, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, 2, 1, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 1, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, 2, -5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, -5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, 2, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 3)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, 2, 5, 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 1)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, 2, 5, 0)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 0)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, 2, 5, 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 1)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[3] = (4, 2, 5, 2)",
      "mutated_line": "p[3] = (4, 2, 5, -2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, -2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[5] = (4, 3, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[5] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[3] = (4, 3, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[3] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[0] = (4, 3, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[0] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[1] = (4, 3, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[1] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[-4] = (4, 3, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[-4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (5, 3, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (5, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (3, 3, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (3, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (0, 3, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (0, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (1, 3, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (1, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (-4, 3, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (-4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, 4, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 4, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, 2, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 2, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, 0, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 0, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, 1, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 1, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, -3, 5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, -3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, 3, 6, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 6, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, 3, 4, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 4, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, 3, 0, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 0, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, 3, 1, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 1, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, 3, -5, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, -5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, 3, 5, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 4)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, 3, 5, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 2)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, 3, 5, 0)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 0)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, 3, 5, 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 1)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p[4] = (4, 3, 5, 3)",
      "mutated_line": "p[4] = (4, 3, 5, -3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, -3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[6] = (1, 3, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[6] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[4] = (1, 3, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[4] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[0] = (1, 3, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[0] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[1] = (1, 3, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[1] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[-5] = (1, 3, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[-5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (2, 3, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (2, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (0, 3, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (0, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (0, 3, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (0, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (-1, 3, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (-1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, 4, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 4, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, 2, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 2, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, 0, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 0, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, 1, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 1, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, -3, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, -3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, 3, 3, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 3, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, 3, 1, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 1, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, 3, 0, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 0, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, 3, 1, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 1, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, 3, -2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, -2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, 3, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 4)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, 3, 2, 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 2)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, 3, 2, 0)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 0)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, 3, 2, 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 1)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p[5] = (1, 3, 2, 3)",
      "mutated_line": "p[5] = (1, 3, 2, -3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, -3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[7] = (1, 4, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[7] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[5] = (1, 4, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[5] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[0] = (1, 4, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[0] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[1] = (1, 4, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[1] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[-6] = (1, 4, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[-6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (2, 4, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (2, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (0, 4, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (0, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (0, 4, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (0, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (-1, 4, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (-1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, 5, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 5, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, 3, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 3, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, 0, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 0, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, 1, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 1, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, -4, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, -4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, 4, 3, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 3, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, 4, 1, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 1, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, 4, 0, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 0, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, 4, 1, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 1, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, 4, -2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, -2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, 4, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 5)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, 4, 2, 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 3)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, 4, 2, 0)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 0)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, 4, 2, 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 1)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p[6] = (1, 4, 2, 4)",
      "mutated_line": "p[6] = (1, 4, 2, -4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, -4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[8] = (2, 4, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[8] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[6] = (2, 4, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[6] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[0] = (2, 4, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[0] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[1] = (2, 4, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[1] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[-7] = (2, 4, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[-7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (3, 4, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (3, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (1, 4, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (1, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (0, 4, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (0, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (1, 4, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (1, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (-2, 4, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (-2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, 5, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 5, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, 3, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 3, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, 0, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 0, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, 1, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 1, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, -4, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, -4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, 4, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 3, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, 4, 1, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 1, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, 4, 0, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 0, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, 4, 1, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 1, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, 4, -2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, -2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, 4, 2, 6)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 6)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, 4, 2, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 4)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, 4, 2, 0)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 0)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, 4, 2, 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 1)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p[7] = (2, 4, 2, 5)",
      "mutated_line": "p[7] = (2, 4, 2, -5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, -5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[9] = (3, 4, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[9] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[7] = (3, 4, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[7] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[0] = (3, 4, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[0] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[1] = (3, 4, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[1] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[-8] = (3, 4, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[-8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (4, 4, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (4, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (2, 4, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (2, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (0, 4, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (0, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (1, 4, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (1, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (-3, 4, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (-3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, 5, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 5, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, 3, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 3, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, 0, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 0, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, 1, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 1, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, -4, 3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, -4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, 4, 4, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 4, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, 4, 2, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 2, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, 4, 0, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 0, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, 4, 1, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 1, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, 4, -3, 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, -3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, 4, 3, 6)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 6)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, 4, 3, 4)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 4)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, 4, 3, 0)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 0)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, 4, 3, 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 1)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p[8] = (3, 4, 3, 5)",
      "mutated_line": "p[8] = (3, 4, 3, -5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, -5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "x1 += D",
      "mutated_line": "x1 -= D",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 -= D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "y1 += D",
      "mutated_line": "y1 -= D",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 -= D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "x2 += D",
      "mutated_line": "x2 -= D",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 -= D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "y2 += D",
      "mutated_line": "y2 -= D",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 -= D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for i in range(L - 1):",
      "mutated_line": "for i in range(L + 1):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L + 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for i in range(L - 1):",
      "mutated_line": "for i in range(L * 1):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L * 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return 1 < x <= n and 1 <= y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 < x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return 1 > x <= n and 1 <= y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 > x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return 1 == x <= n and 1 <= y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 == x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return 1 <= x <= n and 1 < y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 < y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return 1 <= x <= n and 1 > y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 > y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return 1 <= x <= n and 1 == y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 == y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "a.append(T % 6)",
      "mutated_line": "a.append(T * 6)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T * 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "a.append(T % 6)",
      "mutated_line": "a.append(T + 6)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T + 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L * 3 + 2",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 3 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L * 1 + 2",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 1 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L * 0 + 2",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 0 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L * 1 + 2",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 1 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n = m = L * 2 + 2",
      "mutated_line": "n = m = L * -2 + 2",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * -2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(2, 2, 2, 2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(2, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(0, 2, 2, 2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(0, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(0, 2, 2, 2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(0, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(-1, 2, 2, 2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(-1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 3, 2, 2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 3, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 1, 2, 2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 1, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 0, 2, 2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 0, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 1, 2, 2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 1, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, -2, 2, 2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, -2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 3, 2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 3, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 1, 2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 1, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 0, 2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 0, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 1, 2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 1, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, -2, 2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, -2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 3), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 3), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 1), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 1), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 0), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 0), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 1), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 1), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, -2), (2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, -2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (3, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (3, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (1, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (1, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (0, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (0, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (1, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (1, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (-2, 1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (-2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (2, 2, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 2, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (2, 0, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 0, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (2, 0, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 0, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (2, -1, 2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, -1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (2, 1, 3, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 3, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (2, 1, 1, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 1, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (2, 1, 0, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 0, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (2, 1, 1, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 1, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (2, 1, -2, 2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, -2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 3)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 3)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 1)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 1)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 0)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 0)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 1)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 1)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans = [(1, 2, 2, 2), (2, 1, 2, 2)]",
      "mutated_line": "ans = [(1, 2, 2, 2), (2, 1, 2, -2)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, -2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[1] * 10 for i in range(7)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 10 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[1] * 8 for i in range(7)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 8 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[1] * 0 for i in range(7)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 0 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[1] * 1 for i in range(7)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 1 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[1] * -9 for i in range(7)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * -9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[2][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[2][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[0][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[0][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[0][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[0][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[-1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[-1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[3][2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[3][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[1][2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[1][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[0][2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[0][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[1][2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[1][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[-2][2] = f[2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[-2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[3][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[3][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[1][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[1][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[0][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[0][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[1][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[1][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[-2][6] = f[3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[-2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][6] = f[4][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[4][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][6] = f[2][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[2][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][6] = f[0][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[0][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][6] = f[1][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[1][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0",
      "mutated_line": "f[1][2] = f[2][2] = f[2][6] = f[-3][5] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[-3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[5][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[5][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[3][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[3][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[0][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[0][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[1][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[1][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[-4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[-4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[5][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[5][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[3][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[3][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[0][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[0][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[1][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[1][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[-4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[-4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[6][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[6][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[4][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[4][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[0][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[0][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[1][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[1][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[-5][2] = f[5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[-5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[6][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[6][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[4][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[4][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[0][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[0][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[1][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[1][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[-5][5] = f[5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[-5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[6][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[6][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[4][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[4][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[0][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[0][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[1][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[1][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0",
      "mutated_line": "f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[-5][6] = 0",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[-5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p = [0] * 9",
      "mutated_line": "p = [1] * 9",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [1] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p = [0] * 9",
      "mutated_line": "p = [-1] * 9",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [-1] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p = [0] * 9",
      "mutated_line": "p = [1] * 9",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [1] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "bit = a[L - i - 1]",
      "mutated_line": "bit = a[L - i + 1]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i + 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "bit = a[L - i - 1]",
      "mutated_line": "bit = a[(L - i) * 1]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[(L - i) * 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(1, 9):",
      "mutated_line": "for j in range(2, 9):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(2, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(1, 9):",
      "mutated_line": "for j in range(0, 9):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(0, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(1, 9):",
      "mutated_line": "for j in range(0, 9):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(0, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(1, 9):",
      "mutated_line": "for j in range(-1, 9):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(-1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(1, 9):",
      "mutated_line": "for j in range(1, 10):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 10):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(1, 9):",
      "mutated_line": "for j in range(1, 8):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 8):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(1, 9):",
      "mutated_line": "for j in range(1, 0):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 0):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(1, 9):",
      "mutated_line": "for j in range(1, 1):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 1):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(1, 9):",
      "mutated_line": "for j in range(1, -9):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, -9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "D = 2 * i",
      "mutated_line": "D = 2 / i",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 / i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "D = 2 * i",
      "mutated_line": "D = 2 + i",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 + i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "D = 2 * i",
      "mutated_line": "D = 2 ** i",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 ** i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(L - 1):",
      "mutated_line": "for i in range(L - 2):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 2):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(L - 1):",
      "mutated_line": "for i in range(L - 0):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 0):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(L - 1):",
      "mutated_line": "for i in range(L - 0):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 0):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(L - 1):",
      "mutated_line": "for i in range(L - -1):",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - -1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 - i * 2, 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 - i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 * (i * 2), 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 * (i * 2), 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 2, 1 - i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 - i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 2, 1 * (i * 2))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 * (i * 2))\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 - i * 2, 5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 - i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 * (i * 2), 5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 * (i * 2), 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, 5 - i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 - i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, 5 * (i * 2))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 * (i * 2))\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return 2 <= x <= n and 1 <= y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 2 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return 0 <= x <= n and 1 <= y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 0 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return 0 <= x <= n and 1 <= y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 0 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return -1 <= x <= n and 1 <= y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return -1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return 1 <= x <= n and 2 <= y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 2 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return 1 <= x <= n and 0 <= y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 0 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return 1 <= x <= n and 0 <= y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 0 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 1 <= x <= n and 1 <= y <= m",
      "mutated_line": "return 1 <= x <= n and -1 <= y <= m",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and -1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "a.append(T % 6)",
      "mutated_line": "a.append(T % 7)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 7)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "a.append(T % 6)",
      "mutated_line": "a.append(T % 5)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 5)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "a.append(T % 6)",
      "mutated_line": "a.append(T % 0)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 0)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "a.append(T % 6)",
      "mutated_line": "a.append(T % 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 1)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "a.append(T % 6)",
      "mutated_line": "a.append(T % -6)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % -6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[2] * 9 for i in range(7)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[2] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[0] * 9 for i in range(7)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[0] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[0] * 9 for i in range(7)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[0] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[-1] * 9 for i in range(7)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[-1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[1] * 9 for i in range(8)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(8)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[1] * 9 for i in range(6)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(6)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[1] * 9 for i in range(0)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(0)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[1] * 9 for i in range(1)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(1)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [[1] * 9 for i in range(7)]",
      "mutated_line": "f = [[1] * 9 for i in range(-7)]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(-7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "bit = a[L - i - 1]",
      "mutated_line": "bit = a[L + i - 1]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L + i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "bit = a[L - i - 1]",
      "mutated_line": "bit = a[L * i - 1]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L * i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "bit = a[L - i - 1]",
      "mutated_line": "bit = a[L - i - 2]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 2]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "bit = a[L - i - 1]",
      "mutated_line": "bit = a[L - i - 0]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 0]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "bit = a[L - i - 1]",
      "mutated_line": "bit = a[L - i - 0]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 0]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "bit = a[L - i - 1]",
      "mutated_line": "bit = a[L - i - -1]",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - -1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "D = 2 * i",
      "mutated_line": "D = 3 * i",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 3 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "D = 2 * i",
      "mutated_line": "D = 1 * i",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 1 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "D = 2 * i",
      "mutated_line": "D = 0 * i",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 0 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "D = 2 * i",
      "mutated_line": "D = 1 * i",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 1 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "D = 2 * i",
      "mutated_line": "D = -2 * i",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = -2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (6 + i * 2, 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (6 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (4 + i * 2, 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (4 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (0 + i * 2, 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (0 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (1 + i * 2, 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (1 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (-5 + i * 2, 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (-5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i / 2, 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i / 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + (i + 2), 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + (i + 2), 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i ** 2, 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i ** 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 2, 2 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 2 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 2, 0 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 0 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 2, 0 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 0 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 2, -1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, -1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 2, 1 + i / 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i / 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 2, 1 + (i + 2))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + (i + 2))\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 2, 1 + i ** 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i ** 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (2 + i * 2, 5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (2 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (0 + i * 2, 5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (0 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (0 + i * 2, 5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (0 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (-1 + i * 2, 5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (-1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i / 2, 5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i / 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + (i + 2), 5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + (i + 2), 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i ** 2, 5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i ** 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, 6 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 6 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, 4 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 4 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, 0 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 0 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 1 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, -5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, -5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, 5 + i / 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i / 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, 5 + (i + 2))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + (i + 2))\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, 5 + i ** 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i ** 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans.append((x1, y1, x1 + 1, y1))",
      "mutated_line": "ans.append((x1, y1, x1 - 1, y1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 - 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans.append((x1, y1, x1 + 1, y1))",
      "mutated_line": "ans.append((x1, y1, x1 * 1, y1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 * 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 - 1, x1 + 1, y1 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 - 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 * 1, x1 + 1, y1 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 * 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 1, x1 - 1, y1 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 - 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 1, x1 * 1, y1 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 * 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 1, x1 + 1, y1 - 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 - 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 1, x1 + 1, y1 * 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 * 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans.append((x2, y2, x2, y2 + 1))",
      "mutated_line": "ans.append((x2, y2, x2, y2 - 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 - 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans.append((x2, y2, x2, y2 + 1))",
      "mutated_line": "ans.append((x2, y2, x2, y2 * 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 * 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 - 1, y2, x2 + 1, y2 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 - 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 * 1, y2, x2 + 1, y2 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 * 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 1, y2, x2 - 1, y2 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 - 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 1, y2, x2 * 1, y2 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 * 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 1, y2, x2 + 1, y2 - 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 - 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 1, y2, x2 + 1, y2 * 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 * 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 3, 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 3, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 1, 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 1, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 0, 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 0, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 1, 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 1, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * -2, 1 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * -2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 2, 1 + i * 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 3)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 2, 1 + i * 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 1)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 2, 1 + i * 0)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 0)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 2, 1 + i * 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 1)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(x1, y1) = (5 + i * 2, 1 + i * 2)",
      "mutated_line": "(x1, y1) = (5 + i * 2, 1 + i * -2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * -2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 3, 5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 3, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 1, 5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 1, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 0, 5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 0, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 1, 5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 1, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * -2, 5 + i * 2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * -2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, 5 + i * 3)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 3)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, 5 + i * 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 1)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, 5 + i * 0)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 0)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, 5 + i * 1)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 1)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(x2, y2) = (1 + i * 2, 5 + i * 2)",
      "mutated_line": "(x2, y2) = (1 + i * 2, 5 + i * -2)",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * -2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans.append((x1, y1, x1 + 1, y1))",
      "mutated_line": "ans.append((x1, y1, x1 + 2, y1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 2, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans.append((x1, y1, x1 + 1, y1))",
      "mutated_line": "ans.append((x1, y1, x1 + 0, y1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 0, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans.append((x1, y1, x1 + 1, y1))",
      "mutated_line": "ans.append((x1, y1, x1 + 0, y1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 0, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans.append((x1, y1, x1 + 1, y1))",
      "mutated_line": "ans.append((x1, y1, x1 + -1, y1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + -1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 2, x1 + 1, y1 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 2, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 0, x1 + 1, y1 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 0, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 0, x1 + 1, y1 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 0, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + -1, x1 + 1, y1 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + -1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 1, x1 + 2, y1 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 2, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 1, x1 + 0, y1 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 0, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 1, x1 + 0, y1 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 0, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 1, x1 + -1, y1 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + -1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 2))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 2))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 0))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 0))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 0))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 0))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + 1))",
      "mutated_line": "ans.append((x1, y1 + 1, x1 + 1, y1 + -1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + -1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans.append((x2, y2, x2, y2 + 1))",
      "mutated_line": "ans.append((x2, y2, x2, y2 + 2))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 2))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans.append((x2, y2, x2, y2 + 1))",
      "mutated_line": "ans.append((x2, y2, x2, y2 + 0))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 0))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans.append((x2, y2, x2, y2 + 1))",
      "mutated_line": "ans.append((x2, y2, x2, y2 + 0))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 0))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans.append((x2, y2, x2, y2 + 1))",
      "mutated_line": "ans.append((x2, y2, x2, y2 + -1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + -1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 2, y2, x2 + 1, y2 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 2, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 0, y2, x2 + 1, y2 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 0, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 0, y2, x2 + 1, y2 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 0, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + -1, y2, x2 + 1, y2 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + -1, y2, x2 + 1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 1, y2, x2 + 2, y2 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 2, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 1, y2, x2 + 0, y2 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 0, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 1, y2, x2 + 0, y2 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 0, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 1, y2, x2 + -1, y2 + 1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + -1, y2 + 1))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 2))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 2))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 0))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 0))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 0))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + 0))\n    k = len(ans)\n    return (n, m, k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + 1))",
      "mutated_line": "ans.append((x2 + 1, y2, x2 + 1, y2 + -1))",
      "code": "def generate_maze(T: int) -> tuple:\n\n    def corr(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    a = []\n    while T:\n        a.append(T % 6)\n        T //= 6\n    L = len(a)\n    n = m = L * 2 + 2\n    ans = [(1, 2, 2, 2), (2, 1, 2, 2)]\n    f = [[1] * 9 for i in range(7)]\n    f[1][2] = f[2][2] = f[2][6] = f[3][5] = 0\n    f[4][5] = f[4][6] = f[5][2] = f[5][5] = f[5][6] = 0\n    p = [0] * 9\n    p[1] = (3, 1, 3, 2)\n    p[2] = (4, 1, 4, 2)\n    p[3] = (4, 2, 5, 2)\n    p[4] = (4, 3, 5, 3)\n    p[5] = (1, 3, 2, 3)\n    p[6] = (1, 4, 2, 4)\n    p[7] = (2, 4, 2, 5)\n    p[8] = (3, 4, 3, 5)\n    for i in range(L):\n        bit = a[L - i - 1]\n        for j in range(1, 9):\n            if not f[bit][j]:\n                continue\n            (x1, y1, x2, y2) = p[j]\n            D = 2 * i\n            x1 += D\n            y1 += D\n            x2 += D\n            y2 += D\n            if corr(x2, y2):\n                ans.append((x1, y1, x2, y2))\n    for i in range(L - 1):\n        (x1, y1) = (5 + i * 2, 1 + i * 2)\n        (x2, y2) = (1 + i * 2, 5 + i * 2)\n        ans.append((x1, y1, x1 + 1, y1))\n        ans.append((x1, y1 + 1, x1 + 1, y1 + 1))\n        ans.append((x2, y2, x2, y2 + 1))\n        ans.append((x2 + 1, y2, x2 + 1, y2 + -1))\n    k = len(ans)\n    return (n, m, k, ans)"
    }
  ]
}