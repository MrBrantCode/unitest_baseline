{
  "task_id": "taco_7090",
  "entry_point": "determine_game_winner",
  "mutant_count": 179,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = [None] * n",
      "mutated_line": "ans = [None] / n",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] / n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = [None] * n",
      "mutated_line": "ans = [None] + n",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] + n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = [None] * n",
      "mutated_line": "ans = [None] ** n",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] ** n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp = [[0] * (2 * k) for _ in range(n)]",
      "mutated_line": "dp = [[0] / (2 * k) for _ in range(n)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] / (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp = [[0] * (2 * k) for _ in range(n)]",
      "mutated_line": "dp = [[0] + 2 * k for _ in range(n)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] + 2 * k for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp = [[0] * (2 * k) for _ in range(n)]",
      "mutated_line": "dp = [[0] ** (2 * k) for _ in range(n)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] ** (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n + 1, -1, -1):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n + 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n * 1, -1, -1):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n * 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n - 1, +1, -1):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, +1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n - 1, -1, +1):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, +1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if v == 0:",
      "mutated_line": "if v != 0:",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v != 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "lis[x - 1].append(y - 1)",
      "mutated_line": "lis[x - 1].append(y + 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y + 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "lis[x - 1].append(y - 1)",
      "mutated_line": "lis[x - 1].append(y * 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y * 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "lis[y - 1].append(x - 1)",
      "mutated_line": "lis[y - 1].append(x + 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x + 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "lis[y - 1].append(x - 1)",
      "mutated_line": "lis[y - 1].append(x * 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x * 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = deque([0])",
      "mutated_line": "q = deque([1])",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([1])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = deque([0])",
      "mutated_line": "q = deque([-1])",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([-1])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = deque([0])",
      "mutated_line": "q = deque([1])",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([1])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if nex != p[v]:",
      "mutated_line": "if nex == p[v]:",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex == p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp = [[0] * (2 * k) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (2 / k) for _ in range(n)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 / k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp = [[0] * (2 * k) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (2 + k) for _ in range(n)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 + k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp = [[0] * (2 * k) for _ in range(n)]",
      "mutated_line": "dp = [[0] * 2 ** k for _ in range(n)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * 2 ** k for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n - 2, -1, -1):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 2, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n - 0, -1, -1):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 0, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n - 0, -1, -1):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 0, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n - -1, -1, -1):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - -1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n - 1, -2, -1):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -2, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n - 1, -0, -1):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -0, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n - 1, -0, -1):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -0, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n - 1, --1, -1):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, --1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n - 1, -1, -2):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -2):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n - 1, -1, -0):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -0):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n - 1, -1, -0):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -0):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ind in range(n - 1, -1, -1):",
      "mutated_line": "for ind in range(n - 1, -1, --1):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, --1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[v][0] ^= presents[v]",
      "mutated_line": "dp[v][1] ^= presents[v]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][1] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[v][0] ^= presents[v]",
      "mutated_line": "dp[v][-1] ^= presents[v]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][-1] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[v][0] ^= presents[v]",
      "mutated_line": "dp[v][1] ^= presents[v]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][1] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if nex != p[v]:",
      "mutated_line": "if nex == p[v]:",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex == p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if v == 0:",
      "mutated_line": "if v == 1:",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 1:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if v == 0:",
      "mutated_line": "if v == -1:",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == -1:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if v == 0:",
      "mutated_line": "if v == 1:",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 1:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "now = 0",
      "mutated_line": "now = 1",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 1\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "now = 0",
      "mutated_line": "now = -1",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = -1\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "now = 0",
      "mutated_line": "now = 1",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 1\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "now = 0",
      "mutated_line": "now = 1",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 1\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "now = 0",
      "mutated_line": "now = -1",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = -1\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "now = 0",
      "mutated_line": "now = 1",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 1\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lis[x - 1].append(y - 1)",
      "mutated_line": "lis[x - 1].append(y - 2)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 2)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lis[x - 1].append(y - 1)",
      "mutated_line": "lis[x - 1].append(y - 0)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 0)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lis[x - 1].append(y - 1)",
      "mutated_line": "lis[x - 1].append(y - 0)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 0)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lis[x - 1].append(y - 1)",
      "mutated_line": "lis[x - 1].append(y - -1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - -1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lis[y - 1].append(x - 1)",
      "mutated_line": "lis[y - 1].append(x - 2)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 2)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lis[y - 1].append(x - 1)",
      "mutated_line": "lis[y - 1].append(x - 0)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 0)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lis[y - 1].append(x - 1)",
      "mutated_line": "lis[y - 1].append(x - 0)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 0)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lis[y - 1].append(x - 1)",
      "mutated_line": "lis[y - 1].append(x - -1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - -1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp = [[0] * (2 * k) for _ in range(n)]",
      "mutated_line": "dp = [[1] * (2 * k) for _ in range(n)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[1] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp = [[0] * (2 * k) for _ in range(n)]",
      "mutated_line": "dp = [[-1] * (2 * k) for _ in range(n)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[-1] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp = [[0] * (2 * k) for _ in range(n)]",
      "mutated_line": "dp = [[1] * (2 * k) for _ in range(n)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[1] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp = [[0] * (2 * k) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (3 * k) for _ in range(n)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (3 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp = [[0] * (2 * k) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (1 * k) for _ in range(n)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (1 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp = [[0] * (2 * k) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (0 * k) for _ in range(n)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (0 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp = [[0] * (2 * k) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (1 * k) for _ in range(n)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (1 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp = [[0] * (2 * k) for _ in range(n)]",
      "mutated_line": "dp = [[0] * (-2 * k) for _ in range(n)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (-2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, 2 / k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 / k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, 2 + k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 + k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, 2 ** k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 ** k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[v] = min(now, 1)",
      "mutated_line": "ans[v] = min(now, 2)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 2)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[v] = min(now, 1)",
      "mutated_line": "ans[v] = min(now, 0)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 0)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[v] = min(now, 1)",
      "mutated_line": "ans[v] = min(now, 0)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 0)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[v] = min(now, 1)",
      "mutated_line": "ans[v] = min(now, -1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, -1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(2 / k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 / k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(2 + k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 + k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(2 ** k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 ** k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(2 / k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 / k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(2 + k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 + k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(2 ** k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 ** k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, 2 / k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 / k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, 2 + k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 + k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, 2 ** k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 ** k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans[v] = min(now, 1)",
      "mutated_line": "ans[v] = min(now, 2)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans[v] = min(now, 1)",
      "mutated_line": "ans[v] = min(now, 0)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans[v] = min(now, 1)",
      "mutated_line": "ans[v] = min(now, 0)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans[v] = min(now, 1)",
      "mutated_line": "ans[v] = min(now, -1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "lis[x - 1].append(y - 1)",
      "mutated_line": "lis[x + 1].append(y - 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x + 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "lis[x - 1].append(y - 1)",
      "mutated_line": "lis[x * 1].append(y - 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x * 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "lis[y - 1].append(x - 1)",
      "mutated_line": "lis[y + 1].append(x - 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y + 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "lis[y - 1].append(x - 1)",
      "mutated_line": "lis[y * 1].append(x - 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y * 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for nk in range(2 * k):",
      "mutated_line": "for nk in range(2 / k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 / k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for nk in range(2 * k):",
      "mutated_line": "for nk in range(2 + k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 + k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for nk in range(2 * k):",
      "mutated_line": "for nk in range(2 ** k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 ** k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, 3 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 3 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, 1 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 1 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, 0 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 0 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, 1 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 1 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, -2 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, -2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(3 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(3 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(1 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(1 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(0 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(0 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(1 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(1 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(-2 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(-2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[(i + 1) * (2 * k)] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) * (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[i + 1 + 2 * k] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[i + 1 + 2 * k] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(3 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(3 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(1 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(1 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(0 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(0 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(1 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(1 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for i in range(2 * k):",
      "mutated_line": "for i in range(-2 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(-2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][(i + 1) * (2 * k)] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) * (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][i + 1 + 2 * k] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][i + 1 + 2 * k] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, 3 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 3 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, 1 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 1 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, 0 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 0 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, 1 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 1 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for i in range(k, 2 * k):",
      "mutated_line": "for i in range(k, -2 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, -2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lis[x - 1].append(y - 1)",
      "mutated_line": "lis[x - 2].append(y - 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 2].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lis[x - 1].append(y - 1)",
      "mutated_line": "lis[x - 0].append(y - 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 0].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lis[x - 1].append(y - 1)",
      "mutated_line": "lis[x - 0].append(y - 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 0].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "lis[x - 1].append(y - 1)",
      "mutated_line": "lis[x - -1].append(y - 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - -1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lis[y - 1].append(x - 1)",
      "mutated_line": "lis[y - 2].append(x - 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 2].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lis[y - 1].append(x - 1)",
      "mutated_line": "lis[y - 0].append(x - 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 0].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lis[y - 1].append(x - 1)",
      "mutated_line": "lis[y - 0].append(x - 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 0].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "lis[y - 1].append(x - 1)",
      "mutated_line": "lis[y - -1].append(x - 1)",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - -1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for nk in range(2 * k):",
      "mutated_line": "for nk in range(3 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(3 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for nk in range(2 * k):",
      "mutated_line": "for nk in range(1 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(1 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for nk in range(2 * k):",
      "mutated_line": "for nk in range(0 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(0 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for nk in range(2 * k):",
      "mutated_line": "for nk in range(1 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(1 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for nk in range(2 * k):",
      "mutated_line": "for nk in range(-2 * k):",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(-2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][(nk + 1) * (2 * k)] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) * (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][nk + 1 + 2 * k] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][nk + 1 + 2 * k] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "pcopy = [dp[p[v]][i] for i in range(2 * k)]",
      "mutated_line": "pcopy = [dp[p[v]][i] for i in range(2 / k)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 / k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "pcopy = [dp[p[v]][i] for i in range(2 * k)]",
      "mutated_line": "pcopy = [dp[p[v]][i] for i in range(2 + k)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 + k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "pcopy = [dp[p[v]][i] for i in range(2 * k)]",
      "mutated_line": "pcopy = [dp[p[v]][i] for i in range(2 ** k)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 ** k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[(i - 1) % (2 * k)] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i - 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[i * 1 % (2 * k)] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[i * 1 % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[(i + 1) % (2 / k)] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 / k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[(i + 1) % (2 + k)] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 + k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[(i + 1) % 2 ** k] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % 2 ** k] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][(i - 1) % (2 * k)] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i - 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][i * 1 % (2 * k)] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][i * 1 % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][(i + 1) % (2 / k)] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 / k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][(i + 1) % (2 + k)] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 + k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][(i + 1) % 2 ** k] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % 2 ** k] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][(nk - 1) % (2 * k)] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk - 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][nk * 1 % (2 * k)] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][nk * 1 % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][(nk + 1) % (2 / k)] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 / k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][(nk + 1) % (2 + k)] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 + k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][(nk + 1) % 2 ** k] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % 2 ** k] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "pcopy = [dp[p[v]][i] for i in range(2 * k)]",
      "mutated_line": "pcopy = [dp[p[v]][i] for i in range(3 * k)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(3 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "pcopy = [dp[p[v]][i] for i in range(2 * k)]",
      "mutated_line": "pcopy = [dp[p[v]][i] for i in range(1 * k)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(1 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "pcopy = [dp[p[v]][i] for i in range(2 * k)]",
      "mutated_line": "pcopy = [dp[p[v]][i] for i in range(0 * k)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(0 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "pcopy = [dp[p[v]][i] for i in range(2 * k)]",
      "mutated_line": "pcopy = [dp[p[v]][i] for i in range(1 * k)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(1 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "pcopy = [dp[p[v]][i] for i in range(2 * k)]",
      "mutated_line": "pcopy = [dp[p[v]][i] for i in range(-2 * k)]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(-2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[(i + 2) % (2 * k)] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 2) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[(i + 0) % (2 * k)] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 0) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[(i + 0) % (2 * k)] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 0) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[(i + -1) % (2 * k)] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + -1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[(i + 1) % (3 * k)] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (3 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[(i + 1) % (1 * k)] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (1 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[(i + 1) % (0 * k)] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (0 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[(i + 1) % (1 * k)] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (1 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "pcopy[(i + 1) % (2 * k)] ^= dp[v][i]",
      "mutated_line": "pcopy[(i + 1) % (-2 * k)] ^= dp[v][i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (-2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][(i + 2) % (2 * k)] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 2) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][(i + 0) % (2 * k)] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 0) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][(i + 0) % (2 * k)] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 0) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][(i + -1) % (2 * k)] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + -1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][(i + 1) % (3 * k)] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (3 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][(i + 1) % (1 * k)] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (1 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][(i + 1) % (0 * k)] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (0 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][(i + 1) % (1 * k)] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (1 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "dp[v][(i + 1) % (2 * k)] ^= pcopy[i]",
      "mutated_line": "dp[v][(i + 1) % (-2 * k)] ^= pcopy[i]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (-2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][(nk + 2) % (2 * k)] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 2) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][(nk + 0) % (2 * k)] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 0) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][(nk + 0) % (2 * k)] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 0) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][(nk + -1) % (2 * k)] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + -1) % (2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][(nk + 1) % (3 * k)] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (3 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][(nk + 1) % (1 * k)] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (1 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][(nk + 1) % (0 * k)] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (0 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][(nk + 1) % (1 * k)] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (1 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dp[v][(nk + 1) % (2 * k)] ^= dp[nex][nk]",
      "mutated_line": "dp[v][(nk + 1) % (-2 * k)] ^= dp[nex][nk]",
      "code": "def determine_game_winner(n, k, edges, presents):\n    from collections import deque\n    lis = [[] for _ in range(n)]\n    for (x, y) in edges:\n        lis[x - 1].append(y - 1)\n        lis[y - 1].append(x - 1)\n    p = [i for i in range(n)]\n    vlis = []\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        vlis.append(v)\n        for nex in lis[v]:\n            if nex != p[v]:\n                p[nex] = v\n                q.append(nex)\n    dp = [[0] * (2 * k) for _ in range(n)]\n    for ind in range(n - 1, -1, -1):\n        v = vlis[ind]\n        dp[v][0] ^= presents[v]\n        for nex in lis[v]:\n            if nex != p[v]:\n                for nk in range(2 * k):\n                    dp[v][(nk + 1) % (-2 * k)] ^= dp[nex][nk]\n    ans = [None] * n\n    for v in vlis:\n        if v == 0:\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n        else:\n            pcopy = [dp[p[v]][i] for i in range(2 * k)]\n            for i in range(2 * k):\n                pcopy[(i + 1) % (2 * k)] ^= dp[v][i]\n            for i in range(2 * k):\n                dp[v][(i + 1) % (2 * k)] ^= pcopy[i]\n            now = 0\n            for i in range(k, 2 * k):\n                now ^= dp[v][i]\n            ans[v] = min(now, 1)\n    return ans"
    }
  ]
}