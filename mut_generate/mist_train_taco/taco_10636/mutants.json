{
  "task_id": "taco_10636",
  "entry_point": "minimum_time_to_reach_end",
  "mutant_count": 149,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s or k == n + 1 or s[-1][1] != k:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s or k == n + 1 or s[-1][1] != k:\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i = j = 0",
      "mutated_line": "i = j = 1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 1\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i = j = 0",
      "mutated_line": "i = j = -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = -1\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i = j = 0",
      "mutated_line": "i = j = 1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 1\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if len(p[x]) > 1:",
      "mutated_line": "if len(p[x]) >= 1:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) >= 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if len(p[x]) > 1:",
      "mutated_line": "if len(p[x]) <= 1:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) <= 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if len(p[x]) > 1:",
      "mutated_line": "if len(p[x]) != 1:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) != 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if i != n + 1:",
      "mutated_line": "if i == n + 1:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i == n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k, s = 1, [(1, 2)]",
      "mutated_line": "(k, s) = (2, [(1, 2)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (2, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k, s = 1, [(1, 2)]",
      "mutated_line": "(k, s) = (0, [(1, 2)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (0, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k, s = 1, [(1, 2)]",
      "mutated_line": "(k, s) = (0, [(1, 2)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (0, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k, s = 1, [(1, 2)]",
      "mutated_line": "(k, s) = (-1, [(1, 2)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (-1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if x == k:",
      "mutated_line": "if x != k:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x != k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "k = x + 1",
      "mutated_line": "k = x - 1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x - 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "k = x + 1",
      "mutated_line": "k = x * 1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x * 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k != n + 1 and (s[-1][1] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k != n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n + 1 and (s[-1][1] == k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] == k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 2 / (n - 1) if s else -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 / (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 2 + (n - 1) if s else -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 + (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 2 ** (n - 1) if s else -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 ** (n - 1) if s else -1"
    },
    {
      "operator": "UOI",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 2 * (n - 1) if s else +1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else +1"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "while j < l and v[j][1] <= u[i][0]:",
      "mutated_line": "while j < l or v[j][1] <= u[i][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l or v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j -= 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if u[i][1] <= v[j][0]:",
      "mutated_line": "if u[i][1] < v[j][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] < v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if u[i][1] <= v[j][0]:",
      "mutated_line": "if u[i][1] > v[j][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] > v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if u[i][1] <= v[j][0]:",
      "mutated_line": "if u[i][1] == v[j][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] == v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if u[i][0] >= v[j][0]:",
      "mutated_line": "if u[i][0] > v[j][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] > v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if u[i][0] >= v[j][0]:",
      "mutated_line": "if u[i][0] < v[j][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] < v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if u[i][0] >= v[j][0]:",
      "mutated_line": "if u[i][0] == v[j][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] == v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(p[x]) > 1:",
      "mutated_line": "if len(p[x]) > 2:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 2:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(p[x]) > 1:",
      "mutated_line": "if len(p[x]) > 0:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 0:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(p[x]) > 1:",
      "mutated_line": "if len(p[x]) > 0:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 0:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(p[x]) > 1:",
      "mutated_line": "if len(p[x]) > -1:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > -1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "t, i = [], 1",
      "mutated_line": "(t, i) = ([], 2)",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 2)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "t, i = [], 1",
      "mutated_line": "(t, i) = ([], 0)",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 0)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "t, i = [], 1",
      "mutated_line": "(t, i) = ([], 0)",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 0)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "t, i = [], 1",
      "mutated_line": "(t, i) = ([], -1)",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], -1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if i != j:",
      "mutated_line": "if i == j:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i == j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "i = j + 1",
      "mutated_line": "i = j - 1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j - 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "i = j + 1",
      "mutated_line": "i = j * 1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j * 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if i != n + 1:",
      "mutated_line": "if i != n - 1:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n - 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if i != n + 1:",
      "mutated_line": "if i != n * 1:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n * 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "k = x + 1",
      "mutated_line": "k = x + 2",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 2\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "k = x + 1",
      "mutated_line": "k = x + 0",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 0\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "k = x + 1",
      "mutated_line": "k = x + 0",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 0\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "k = x + 1",
      "mutated_line": "k = x + -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + -1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n - 1 and (s[-1][1] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n - 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n * 1 and (s[-1][1] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n * 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 3 * (n - 1) if s else -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 3 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 1 * (n - 1) if s else -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 1 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 0 * (n - 1) if s else -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 0 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 1 * (n - 1) if s else -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 1 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return -2 * (n - 1) if s else -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return -2 * (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 2 * (n + 1) if s else -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n + 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 2 * (n * 1) if s else -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n * 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 2 * (n - 1) if s else -2",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -2"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 2 * (n - 1) if s else -0",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 2 * (n - 1) if s else -0",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 2 * (n - 1) if s else --1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else --1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while j < l and v[j][1] <= u[i][0]:",
      "mutated_line": "while j <= l and v[j][1] <= u[i][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j <= l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while j < l and v[j][1] <= u[i][0]:",
      "mutated_line": "while j >= l and v[j][1] <= u[i][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j >= l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while j < l and v[j][1] <= u[i][0]:",
      "mutated_line": "while j != l and v[j][1] <= u[i][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j != l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while j < l and v[j][1] <= u[i][0]:",
      "mutated_line": "while j < l and v[j][1] < u[i][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] < u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while j < l and v[j][1] <= u[i][0]:",
      "mutated_line": "while j < l and v[j][1] > u[i][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] > u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while j < l and v[j][1] <= u[i][0]:",
      "mutated_line": "while j < l and v[j][1] == u[i][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] == u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 2\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 0\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 0\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += -1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if j == l:",
      "mutated_line": "if j != l:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j != l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "i = j + 1",
      "mutated_line": "i = j + 2",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 2\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "i = j + 1",
      "mutated_line": "i = j + 0",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 0\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "i = j + 1",
      "mutated_line": "i = j + 0",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 0\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "i = j + 1",
      "mutated_line": "i = j + -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + -1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if i != n + 1:",
      "mutated_line": "if i != n + 2:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 2:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if i != n + 1:",
      "mutated_line": "if i != n + 0:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 0:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if i != n + 1:",
      "mutated_line": "if i != n + 0:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 0:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if i != n + 1:",
      "mutated_line": "if i != n + -1:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + -1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k, s = 1, [(1, 2)]",
      "mutated_line": "(k, s) = (1, [(2, 2)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(2, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k, s = 1, [(1, 2)]",
      "mutated_line": "(k, s) = (1, [(0, 2)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(0, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k, s = 1, [(1, 2)]",
      "mutated_line": "(k, s) = (1, [(0, 2)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(0, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k, s = 1, [(1, 2)]",
      "mutated_line": "(k, s) = (1, [(-1, 2)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(-1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k, s = 1, [(1, 2)]",
      "mutated_line": "(k, s) = (1, [(1, 3)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 3)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k, s = 1, [(1, 2)]",
      "mutated_line": "(k, s) = (1, [(1, 1)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 1)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k, s = 1, [(1, 2)]",
      "mutated_line": "(k, s) = (1, [(1, 0)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 0)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k, s = 1, [(1, 2)]",
      "mutated_line": "(k, s) = (1, [(1, 1)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 1)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k, s = 1, [(1, 2)]",
      "mutated_line": "(k, s) = (1, [(1, -2)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, -2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n + 2 and (s[-1][1] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 2 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n + 0 and (s[-1][1] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 0 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n + 0 and (s[-1][1] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 0 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n + -1 and (s[-1][1] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + -1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n + 1 and (s[-1][2] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][2] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n + 1 and (s[-1][0] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][0] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n + 1 and (s[-1][0] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][0] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n + 1 and (s[-1][-1] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][-1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 2 * (n - 2) if s else -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 2) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 2 * (n - 0) if s else -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 0) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 2 * (n - 0) if s else -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 0) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 2 * (n - 1) if s else -1",
      "mutated_line": "return 2 * (n - -1) if s else -1",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - -1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if u[i][1] <= v[j][0]:",
      "mutated_line": "if u[i][2] <= v[j][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][2] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if u[i][1] <= v[j][0]:",
      "mutated_line": "if u[i][0] <= v[j][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][0] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if u[i][1] <= v[j][0]:",
      "mutated_line": "if u[i][0] <= v[j][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][0] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if u[i][1] <= v[j][0]:",
      "mutated_line": "if u[i][-1] <= v[j][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][-1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if u[i][1] <= v[j][0]:",
      "mutated_line": "if u[i][1] <= v[j][1]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][1]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if u[i][1] <= v[j][0]:",
      "mutated_line": "if u[i][1] <= v[j][-1]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][-1]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if u[i][1] <= v[j][0]:",
      "mutated_line": "if u[i][1] <= v[j][1]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][1]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if u[i][0] >= v[j][0]:",
      "mutated_line": "if u[i][1] >= v[j][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][1] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if u[i][0] >= v[j][0]:",
      "mutated_line": "if u[i][-1] >= v[j][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][-1] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if u[i][0] >= v[j][0]:",
      "mutated_line": "if u[i][1] >= v[j][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][1] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if u[i][0] >= v[j][0]:",
      "mutated_line": "if u[i][0] >= v[j][1]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][1]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if u[i][0] >= v[j][0]:",
      "mutated_line": "if u[i][0] >= v[j][-1]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][-1]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if u[i][0] >= v[j][0]:",
      "mutated_line": "if u[i][0] >= v[j][1]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][1]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "t.append((i, n + 1))",
      "mutated_line": "t.append((i, n - 1))",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n - 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "t.append((i, n + 1))",
      "mutated_line": "t.append((i, n * 1))",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n * 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n + 1 and (s[+1][1] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[+1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j < l and v[j][1] <= u[i][0]:",
      "mutated_line": "while j < l and v[j][2] <= u[i][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][2] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j < l and v[j][1] <= u[i][0]:",
      "mutated_line": "while j < l and v[j][0] <= u[i][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][0] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j < l and v[j][1] <= u[i][0]:",
      "mutated_line": "while j < l and v[j][0] <= u[i][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][0] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j < l and v[j][1] <= u[i][0]:",
      "mutated_line": "while j < l and v[j][-1] <= u[i][0]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][-1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j < l and v[j][1] <= u[i][0]:",
      "mutated_line": "while j < l and v[j][1] <= u[i][1]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][1]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j < l and v[j][1] <= u[i][0]:",
      "mutated_line": "while j < l and v[j][1] <= u[i][-1]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][-1]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j < l and v[j][1] <= u[i][0]:",
      "mutated_line": "while j < l and v[j][1] <= u[i][1]:",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][1]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "t.append((i, n + 1))",
      "mutated_line": "t.append((i, n + 2))",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 2))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "t.append((i, n + 1))",
      "mutated_line": "t.append((i, n + 0))",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 0))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "t.append((i, n + 1))",
      "mutated_line": "t.append((i, n + 0))",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 0))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "t.append((i, n + 1))",
      "mutated_line": "t.append((i, n + -1))",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + -1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "s = f(p[x], [(s[0][0], n + 1)])",
      "mutated_line": "s = f(p[x], [(s[0][0], n - 1)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n - 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "s = f(p[x], [(s[0][0], n + 1)])",
      "mutated_line": "s = f(p[x], [(s[0][0], n * 1)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n * 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n + 1 and (s[-2][1] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-2][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n + 1 and (s[-0][1] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-0][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n + 1 and (s[-0][1] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-0][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if s and k == n + 1 and (s[-1][1] != k):",
      "mutated_line": "if s and k == n + 1 and (s[--1][1] != k):",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[--1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s.append((v[j][0], u[i][1]))",
      "mutated_line": "s.append((v[j][1], u[i][1]))",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][1], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s.append((v[j][0], u[i][1]))",
      "mutated_line": "s.append((v[j][-1], u[i][1]))",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][-1], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s.append((v[j][0], u[i][1]))",
      "mutated_line": "s.append((v[j][1], u[i][1]))",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][1], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s.append((v[j][0], u[i][1]))",
      "mutated_line": "s.append((v[j][0], u[i][2]))",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][2]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s.append((v[j][0], u[i][1]))",
      "mutated_line": "s.append((v[j][0], u[i][0]))",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][0]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s.append((v[j][0], u[i][1]))",
      "mutated_line": "s.append((v[j][0], u[i][0]))",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][0]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s.append((v[j][0], u[i][1]))",
      "mutated_line": "s.append((v[j][0], u[i][-1]))",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][-1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s = f(p[x], [(s[0][0], n + 1)])",
      "mutated_line": "s = f(p[x], [(s[0][1], n + 1)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][1], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s = f(p[x], [(s[0][0], n + 1)])",
      "mutated_line": "s = f(p[x], [(s[0][-1], n + 1)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][-1], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s = f(p[x], [(s[0][0], n + 1)])",
      "mutated_line": "s = f(p[x], [(s[0][1], n + 1)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][1], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s = f(p[x], [(s[0][0], n + 1)])",
      "mutated_line": "s = f(p[x], [(s[0][0], n + 2)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 2)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s = f(p[x], [(s[0][0], n + 1)])",
      "mutated_line": "s = f(p[x], [(s[0][0], n + 0)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 0)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s = f(p[x], [(s[0][0], n + 1)])",
      "mutated_line": "s = f(p[x], [(s[0][0], n + 0)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + 0)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s = f(p[x], [(s[0][0], n + 1)])",
      "mutated_line": "s = f(p[x], [(s[0][0], n + -1)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[0][0], n + -1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s = f(p[x], [(s[0][0], n + 1)])",
      "mutated_line": "s = f(p[x], [(s[1][0], n + 1)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[1][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s = f(p[x], [(s[0][0], n + 1)])",
      "mutated_line": "s = f(p[x], [(s[-1][0], n + 1)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[-1][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s = f(p[x], [(s[0][0], n + 1)])",
      "mutated_line": "s = f(p[x], [(s[1][0], n + 1)])",
      "code": "from collections import defaultdict\n\ndef minimum_time_to_reach_end(n, m, volcanoes):\n\n    def f(u, v):\n        (s, l) = ([], len(v))\n        i = j = 0\n        for i in range(len(u)):\n            while j < l and v[j][1] <= u[i][0]:\n                j += 1\n                if j == l:\n                    return s\n            if u[i][1] <= v[j][0]:\n                continue\n            if u[i][0] >= v[j][0]:\n                s.append(u[i])\n            else:\n                s.append((v[j][0], u[i][1]))\n        return s\n    p = defaultdict(list)\n    for (x, y) in volcanoes:\n        p[x].append(y)\n    for x in p:\n        if len(p[x]) > 1:\n            p[x].sort()\n        (t, i) = ([], 1)\n        for j in p[x]:\n            if i != j:\n                t.append((i, j))\n            i = j + 1\n        if i != n + 1:\n            t.append((i, n + 1))\n        p[x] = t\n    (k, s) = (1, [(1, 2)])\n    for x in sorted(p.keys()):\n        if x == k:\n            s = f(p[x], s)\n        else:\n            s = f(p[x], [(s[1][0], n + 1)])\n        if not s:\n            break\n        k = x + 1\n    if s and k == n + 1 and (s[-1][1] != k):\n        s = []\n    return 2 * (n - 1) if s else -1"
    }
  ]
}