{
  "task_id": "taco_2401",
  "entry_point": "wildcard_match",
  "mutant_count": 120,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return False\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if m == 0 and n == 0:",
      "mutated_line": "if m == 0 or n == 0:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 or n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n == 0:",
      "mutated_line": "if n != 0:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n != 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if m == 0 and unique(p[:n]):",
      "mutated_line": "if m == 0 or unique(p[:n]):",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 or unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if m == 0:",
      "mutated_line": "if m != 0:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m != 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if dp[m][n] != -1:",
      "mutated_line": "if dp[m][n] == -1:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] == -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n - 1] and p[n - 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] and p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if p[n - 1] == '*':",
      "mutated_line": "if p[n - 1] != '*':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] != '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[m][n] = False",
      "mutated_line": "dp[m][n] = True",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = True\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return 1 if solve(string, pattern, m, n, dp) else 0",
      "mutated_line": "return 2 if solve(string, pattern, m, n, dp) else 0",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 2 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return 1 if solve(string, pattern, m, n, dp) else 0",
      "mutated_line": "return 0 if solve(string, pattern, m, n, dp) else 0",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 0 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return 1 if solve(string, pattern, m, n, dp) else 0",
      "mutated_line": "return 0 if solve(string, pattern, m, n, dp) else 0",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 0 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return 1 if solve(string, pattern, m, n, dp) else 0",
      "mutated_line": "return -1 if solve(string, pattern, m, n, dp) else 0",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return -1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return 1 if solve(string, pattern, m, n, dp) else 0",
      "mutated_line": "return 1 if solve(string, pattern, m, n, dp) else 1",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return 1 if solve(string, pattern, m, n, dp) else 0",
      "mutated_line": "return 1 if solve(string, pattern, m, n, dp) else -1",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return 1 if solve(string, pattern, m, n, dp) else 0",
      "mutated_line": "return 1 if solve(string, pattern, m, n, dp) else 1",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 1"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if char != '*':",
      "mutated_line": "if char == '*':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char == '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if m == 0 and n == 0:",
      "mutated_line": "if m != 0 and n == 0:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m != 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if m == 0 and n == 0:",
      "mutated_line": "if m == 0 and n != 0:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n != 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return False\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 1:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n == 0:",
      "mutated_line": "if n == -1:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == -1:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 1:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return True\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if m == 0 and unique(p[:n]):",
      "mutated_line": "if m != 0 and unique(p[:n]):",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m != 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return False\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 1:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if m == 0:",
      "mutated_line": "if m == -1:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == -1:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 1:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return True\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "if dp[m][n] != -1:",
      "mutated_line": "if dp[m][n] != +1:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != +1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] != p[n - 1] or p[n - 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] != p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n - 1] or p[n - 1] != '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] != '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if p[n - 1] == '*':",
      "mutated_line": "if p[n - 1] == '':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "flag = False",
      "mutated_line": "flag = True",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = True\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[+1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[+1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if char != '*':",
      "mutated_line": "if char != '':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return True\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if m == 0 and n == 0:",
      "mutated_line": "if m == 1 and n == 0:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 1 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if m == 0 and n == 0:",
      "mutated_line": "if m == -1 and n == 0:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == -1 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if m == 0 and n == 0:",
      "mutated_line": "if m == 1 and n == 0:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 1 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if m == 0 and n == 0:",
      "mutated_line": "if m == 0 and n == 1:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 1:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if m == 0 and n == 0:",
      "mutated_line": "if m == 0 and n == -1:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == -1:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if m == 0 and n == 0:",
      "mutated_line": "if m == 0 and n == 1:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 1:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if m == 0 and unique(p[:n]):",
      "mutated_line": "if m == 1 and unique(p[:n]):",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 1 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if m == 0 and unique(p[:n]):",
      "mutated_line": "if m == -1 and unique(p[:n]):",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == -1 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if m == 0 and unique(p[:n]):",
      "mutated_line": "if m == 1 and unique(p[:n]):",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 1 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dp[m][n] != -1:",
      "mutated_line": "if dp[m][n] != -2:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -2:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dp[m][n] != -1:",
      "mutated_line": "if dp[m][n] != -0:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -0:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dp[m][n] != -1:",
      "mutated_line": "if dp[m][n] != -0:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -0:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dp[m][n] != -1:",
      "mutated_line": "if dp[m][n] != --1:",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != --1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[m][n] = solve(s, p, m - 1, n - 1, dp)",
      "mutated_line": "dp[m][n] = solve(s, p, m + 1, n - 1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m + 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[m][n] = solve(s, p, m - 1, n - 1, dp)",
      "mutated_line": "dp[m][n] = solve(s, p, m * 1, n - 1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m * 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[m][n] = solve(s, p, m - 1, n - 1, dp)",
      "mutated_line": "dp[m][n] = solve(s, p, m - 1, n + 1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n + 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[m][n] = solve(s, p, m - 1, n - 1, dp)",
      "mutated_line": "dp[m][n] = solve(s, p, m - 1, n * 1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n * 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if p[n - 1] == '*':",
      "mutated_line": "if p[n + 1] == '*':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n + 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if p[n - 1] == '*':",
      "mutated_line": "if p[n * 1] == '*':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n * 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(m + 1):",
      "mutated_line": "for i in range(m - 1):",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m - 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(m + 1):",
      "mutated_line": "for i in range(m * 1):",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m * 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "flag = flag or solve(s, p, m - i, n - 1, dp)",
      "mutated_line": "flag = flag and solve(s, p, m - i, n - 1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag and solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-2 for _ in range(n + 1)] for _ in range(m + 1)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-2 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-0 for _ in range(n + 1)] for _ in range(m + 1)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-0 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-0 for _ in range(n + 1)] for _ in range(m + 1)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-0 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[--1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[--1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m - 1)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m - 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m * 1)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m * 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m + 1] == p[n - 1] or p[n - 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m + 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m * 1] == p[n - 1] or p[n - 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m * 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n + 1] or p[n - 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n + 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n * 1] or p[n - 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n * 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n - 1] or p[n + 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n + 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n - 1] or p[n * 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n * 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[m][n] = solve(s, p, m - 1, n - 1, dp)",
      "mutated_line": "dp[m][n] = solve(s, p, m - 2, n - 1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 2, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[m][n] = solve(s, p, m - 1, n - 1, dp)",
      "mutated_line": "dp[m][n] = solve(s, p, m - 0, n - 1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 0, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[m][n] = solve(s, p, m - 1, n - 1, dp)",
      "mutated_line": "dp[m][n] = solve(s, p, m - 0, n - 1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 0, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[m][n] = solve(s, p, m - 1, n - 1, dp)",
      "mutated_line": "dp[m][n] = solve(s, p, m - -1, n - 1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - -1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[m][n] = solve(s, p, m - 1, n - 1, dp)",
      "mutated_line": "dp[m][n] = solve(s, p, m - 1, n - 2, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 2, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[m][n] = solve(s, p, m - 1, n - 1, dp)",
      "mutated_line": "dp[m][n] = solve(s, p, m - 1, n - 0, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 0, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[m][n] = solve(s, p, m - 1, n - 1, dp)",
      "mutated_line": "dp[m][n] = solve(s, p, m - 1, n - 0, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 0, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[m][n] = solve(s, p, m - 1, n - 1, dp)",
      "mutated_line": "dp[m][n] = solve(s, p, m - 1, n - -1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - -1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if p[n - 1] == '*':",
      "mutated_line": "if p[n - 2] == '*':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 2] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if p[n - 1] == '*':",
      "mutated_line": "if p[n - 0] == '*':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 0] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if p[n - 1] == '*':",
      "mutated_line": "if p[n - 0] == '*':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 0] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if p[n - 1] == '*':",
      "mutated_line": "if p[n - -1] == '*':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - -1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(m + 1):",
      "mutated_line": "for i in range(m + 2):",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 2):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(m + 1):",
      "mutated_line": "for i in range(m + 0):",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 0):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(m + 1):",
      "mutated_line": "for i in range(m + 0):",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 0):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(m + 1):",
      "mutated_line": "for i in range(m + -1):",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + -1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[m][n] = True",
      "mutated_line": "dp[m][n] = False",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = False\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(n - 1)] for _ in range(m + 1)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n - 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(n * 1)] for _ in range(m + 1)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n * 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 2)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 2)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 0)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 0)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 0)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 0)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + -1)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + -1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 2] == p[n - 1] or p[n - 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 2] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 0] == p[n - 1] or p[n - 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 0] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 0] == p[n - 1] or p[n - 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 0] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - -1] == p[n - 1] or p[n - 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - -1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n - 2] or p[n - 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 2] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n - 0] or p[n - 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 0] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n - 0] or p[n - 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 0] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n - -1] or p[n - 1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - -1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n - 1] or p[n - 2] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 2] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n - 1] or p[n - 0] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 0] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n - 1] or p[n - 0] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 0] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if s[m - 1] == p[n - 1] or p[n - 1] == '?':",
      "mutated_line": "if s[m - 1] == p[n - 1] or p[n - -1] == '?':",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - -1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "flag = flag or solve(s, p, m - i, n - 1, dp)",
      "mutated_line": "flag = flag or solve(s, p, m + i, n - 1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m + i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "flag = flag or solve(s, p, m - i, n - 1, dp)",
      "mutated_line": "flag = flag or solve(s, p, m * i, n - 1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m * i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "flag = flag or solve(s, p, m - i, n - 1, dp)",
      "mutated_line": "flag = flag or solve(s, p, m - i, n + 1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n + 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "flag = flag or solve(s, p, m - i, n - 1, dp)",
      "mutated_line": "flag = flag or solve(s, p, m - i, n * 1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n * 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(n + 2)] for _ in range(m + 1)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 2)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(n + 0)] for _ in range(m + 1)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 0)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(n + 0)] for _ in range(m + 1)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 0)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]",
      "mutated_line": "dp = [[-1 for _ in range(n + -1)] for _ in range(m + 1)]",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + -1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "flag = flag or solve(s, p, m - i, n - 1, dp)",
      "mutated_line": "flag = flag or solve(s, p, m - i, n - 2, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 2, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "flag = flag or solve(s, p, m - i, n - 1, dp)",
      "mutated_line": "flag = flag or solve(s, p, m - i, n - 0, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 0, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "flag = flag or solve(s, p, m - i, n - 1, dp)",
      "mutated_line": "flag = flag or solve(s, p, m - i, n - 0, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - 0, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "flag = flag or solve(s, p, m - i, n - 1, dp)",
      "mutated_line": "flag = flag or solve(s, p, m - i, n - -1, dp)",
      "code": "def wildcard_match(pattern: str, string: str) -> int:\n\n    def unique(p: str) -> bool:\n        for char in p:\n            if char != '*':\n                return False\n        return True\n\n    def solve(s: str, p: str, m: int, n: int, dp: list) -> bool:\n        if m == 0 and n == 0:\n            return True\n        if n == 0:\n            return False\n        if m == 0 and unique(p[:n]):\n            return True\n        if m == 0:\n            return False\n        if dp[m][n] != -1:\n            return dp[m][n]\n        if s[m - 1] == p[n - 1] or p[n - 1] == '?':\n            dp[m][n] = solve(s, p, m - 1, n - 1, dp)\n            return dp[m][n]\n        if p[n - 1] == '*':\n            flag = False\n            for i in range(m + 1):\n                flag = flag or solve(s, p, m - i, n - -1, dp)\n                if flag:\n                    dp[m][n] = True\n                    return dp[m][n]\n            dp[m][n] = flag\n            return dp[m][n]\n        dp[m][n] = False\n        return dp[m][n]\n    m = len(string)\n    n = len(pattern)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    return 1 if solve(string, pattern, m, n, dp) else 0"
    }
  ]
}