"""
QUESTION:
Let's consider some integer X. We will call the following sequence S a sequence generated by X:
for i = 1: S[i] = X 
for i > 1: S[i] equals to the minimal positive integer such that S[i] is not a divisor of S[i - 1]. If there is no such integer than S[i - 1] is the last element of S.

For example S = (10, 3, 2) is a sequence generated by 10.

Can you find the total sum of lengths of the sequnces generated by all the integers from A  to B inclusive.

Input
The only line contains two integers: A and B. (A ≤ B)

Output 
Output the only integer - answer to the question. It's guaranteed that this value can be stored in 64-bit integer.

Constraints 
1 < A ≤ B ≤ 10^17

SAMPLE INPUT
2 6

SAMPLE OUTPUT
12
"""

def total_sequence_length_sum(A: int, B: int) -> int:
    """
    Calculate the total sum of lengths of the sequences generated by all integers from A to B inclusive.

    Parameters:
    A (int): The starting integer of the range (inclusive).
    B (int): The ending integer of the range (inclusive).

    Returns:
    int: The total sum of lengths of the sequences generated by all integers from A to B.
    """
    
    def gcd(a, b):
        if b == 0:
            return a
        return gcd(b, a % b)
    
    def lcm(a, b):
        return a * (b // gcd(a, b))
    
    f = [1, 1, 1]
    for i in range(3, 100):
        for j in range(1, i + 1):
            if i % j != 0:
                f.append(1 + f[j])
                break
    
    def solve(x):
        if x == 0:
            return 0
        m = 1
        ans = 1
        for v in range(2, min(x + 1, 50)):
            inc = x // m - v // m
            m = lcm(m, v)
            inc -= x // m - v // m
            ans += inc * (1 + f[v])
        if 2 <= x:
            ans += 1
        return ans
    
    return solve(B) - solve(A - 1)