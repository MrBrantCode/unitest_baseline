{
  "task_id": "taco_4849",
  "entry_point": "find_maximal_xor_sum",
  "mutant_count": 87,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "seen = [0] * n",
      "mutated_line": "seen = [0] / n",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] / n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "seen = [0] * n",
      "mutated_line": "seen = [0] + n",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] + n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "seen = [0] * n",
      "mutated_line": "seen = [0] ** n",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] ** n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "seen[0] = 1",
      "mutated_line": "seen[0] = 2",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 2\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "seen[0] = 1",
      "mutated_line": "seen[0] = 0",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 0\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "seen[0] = 1",
      "mutated_line": "seen[0] = 0",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 0\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "seen[0] = 1",
      "mutated_line": "seen[0] = -1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = -1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 1\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = -1\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 1\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "seen[0] = 1",
      "mutated_line": "seen[1] = 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[1] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "seen[0] = 1",
      "mutated_line": "seen[-1] = 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[-1] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "seen[0] = 1",
      "mutated_line": "seen[1] = 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[1] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(32, -1, -1):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(32, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(30, -1, -1):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(30, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(0, -1, -1):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(0, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(1, -1, -1):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(1, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(-31, -1, -1):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(-31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, +1, -1):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, +1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, +1):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, +1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans = ans * 2 + 1",
      "mutated_line": "ans = ans * 2 - 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 - 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans = ans * 2 + 1",
      "mutated_line": "ans = ans * 2 * 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 * 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "ans -= 1",
      "mutated_line": "ans += 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "seen = [0] * n",
      "mutated_line": "seen = [1] * n",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [1] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "seen = [0] * n",
      "mutated_line": "seen = [-1] * n",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [-1] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "seen = [0] * n",
      "mutated_line": "seen = [1] * n",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [1] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(0, 0)]",
      "mutated_line": "stack = [(1, 0)]",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(1, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(0, 0)]",
      "mutated_line": "stack = [(-1, 0)]",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(-1, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(0, 0)]",
      "mutated_line": "stack = [(1, 0)]",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(1, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(0, 0)]",
      "mutated_line": "stack = [(0, 1)]",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 1)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(0, 0)]",
      "mutated_line": "stack = [(0, -1)]",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, -1)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(0, 0)]",
      "mutated_line": "stack = [(0, 1)]",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 1)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -2, -1):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -2, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -0, -1):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -0, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -0, -1):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -0, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, --1, -1):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, --1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, -2):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -2):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, -0):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -0):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, -0):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -0):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(31, -1, -1):",
      "mutated_line": "for i in range(31, -1, --1):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, --1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans = ans * 2 + 1",
      "mutated_line": "ans = ans / 2 + 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans / 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans = ans * 2 + 1",
      "mutated_line": "ans = ans + 2 + 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans + 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans = ans * 2 + 1",
      "mutated_line": "ans = ans ** 2 + 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans ** 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans = ans * 2 + 1",
      "mutated_line": "ans = ans * 2 + 2",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 2\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans = ans * 2 + 1",
      "mutated_line": "ans = ans * 2 + 0",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 0\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans = ans * 2 + 1",
      "mutated_line": "ans = ans * 2 + 0",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 0\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans = ans * 2 + 1",
      "mutated_line": "ans = ans * 2 + -1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + -1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 2",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 2\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 0",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 0\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 0",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 0\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= -1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= -1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "g[u - 1].append((v - 1, w))",
      "mutated_line": "g[u - 1].append((v + 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v + 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "g[u - 1].append((v - 1, w))",
      "mutated_line": "g[u - 1].append((v * 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v * 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "g[v - 1].append((u - 1, w))",
      "mutated_line": "g[v - 1].append((u + 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u + 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "g[v - 1].append((u - 1, w))",
      "mutated_line": "g[v - 1].append((u * 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u * 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "seen[v] = 1",
      "mutated_line": "seen[v] = 2",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 2\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "seen[v] = 1",
      "mutated_line": "seen[v] = 0",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 0\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "seen[v] = 1",
      "mutated_line": "seen[v] = 0",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 0\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "seen[v] = 1",
      "mutated_line": "seen[v] = -1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = -1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans = ans * 2 + 1",
      "mutated_line": "ans = ans * 3 + 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 3 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans = ans * 2 + 1",
      "mutated_line": "ans = ans * 1 + 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 1 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans = ans * 2 + 1",
      "mutated_line": "ans = ans * 0 + 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 0 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans = ans * 2 + 1",
      "mutated_line": "ans = ans * 1 + 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 1 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans = ans * 2 + 1",
      "mutated_line": "ans = ans * -2 + 1",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * -2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "g[u - 1].append((v - 1, w))",
      "mutated_line": "g[u + 1].append((v - 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u + 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "g[u - 1].append((v - 1, w))",
      "mutated_line": "g[u * 1].append((v - 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u * 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[u - 1].append((v - 1, w))",
      "mutated_line": "g[u - 1].append((v - 2, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 2, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[u - 1].append((v - 1, w))",
      "mutated_line": "g[u - 1].append((v - 0, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 0, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[u - 1].append((v - 1, w))",
      "mutated_line": "g[u - 1].append((v - 0, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 0, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[u - 1].append((v - 1, w))",
      "mutated_line": "g[u - 1].append((v - -1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - -1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "g[v - 1].append((u - 1, w))",
      "mutated_line": "g[v + 1].append((u - 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v + 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "g[v - 1].append((u - 1, w))",
      "mutated_line": "g[v * 1].append((u - 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v * 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[v - 1].append((u - 1, w))",
      "mutated_line": "g[v - 1].append((u - 2, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 2, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[v - 1].append((u - 1, w))",
      "mutated_line": "g[v - 1].append((u - 0, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 0, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[v - 1].append((u - 1, w))",
      "mutated_line": "g[v - 1].append((u - 0, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 0, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[v - 1].append((u - 1, w))",
      "mutated_line": "g[v - 1].append((u - -1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - -1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if not any((j ^ ans in c for j in c)):",
      "mutated_line": "if not any((j ^ ans not in c for j in c)):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans not in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[u - 1].append((v - 1, w))",
      "mutated_line": "g[u - 2].append((v - 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 2].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[u - 1].append((v - 1, w))",
      "mutated_line": "g[u - 0].append((v - 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 0].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[u - 1].append((v - 1, w))",
      "mutated_line": "g[u - 0].append((v - 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 0].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g[u - 1].append((v - 1, w))",
      "mutated_line": "g[u - -1].append((v - 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - -1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[v - 1].append((u - 1, w))",
      "mutated_line": "g[v - 2].append((u - 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 2].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[v - 1].append((u - 1, w))",
      "mutated_line": "g[v - 0].append((u - 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 0].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[v - 1].append((u - 1, w))",
      "mutated_line": "g[v - 0].append((u - 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 0].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g[v - 1].append((u - 1, w))",
      "mutated_line": "g[v - -1].append((u - 1, w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - -1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "stack.append((v, xor ^ w))",
      "mutated_line": "stack.append((v, xor | w))",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor | w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j ^ ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if not any((j ^ ans in c for j in c)):",
      "mutated_line": "if not any((j | ans in c for j in c)):",
      "code": "def find_maximal_xor_sum(test_cases):\n    results = []\n    for case in test_cases:\n        (n, edges) = case\n        g = [[] for _ in range(n)]\n        for (u, v, w) in edges:\n            g[u - 1].append((v - 1, w))\n            g[v - 1].append((u - 1, w))\n        z = []\n        seen = [0] * n\n        seen[0] = 1\n        stack = [(0, 0)]\n        while stack:\n            (u, xor) = stack.pop()\n            z.append(xor)\n            for (v, w) in g[u]:\n                if not seen[v]:\n                    seen[v] = 1\n                    stack.append((v, xor ^ w))\n        ans = 0\n        for i in range(31, -1, -1):\n            ans = ans * 2 + 1\n            c = {j >> i for j in z}\n            if not any((j | ans in c for j in c)):\n                ans -= 1\n        results.append(ans)\n    return results"
    }
  ]
}