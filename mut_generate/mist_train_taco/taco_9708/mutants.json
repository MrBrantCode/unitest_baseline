{
  "task_id": "taco_9708",
  "entry_point": "calculate_minimum_spanning_tree_weight",
  "mutant_count": 16,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "ans = -1",
      "mutated_line": "ans = +1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 1\n    ans = +1\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mp[key] = 1",
      "mutated_line": "mp[key] = 2",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 2\n    ans = -1\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mp[key] = 1",
      "mutated_line": "mp[key] = 0",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 0\n    ans = -1\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mp[key] = 1",
      "mutated_line": "mp[key] = 0",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 0\n    ans = -1\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mp[key] = 1",
      "mutated_line": "mp[key] = -1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = -1\n    ans = -1\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = -1",
      "mutated_line": "ans = -2",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 1\n    ans = -2\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = -1",
      "mutated_line": "ans = -0",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 1\n    ans = -0\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = -1",
      "mutated_line": "ans = -0",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 1\n    ans = -0\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = -1",
      "mutated_line": "ans = --1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 1\n    ans = --1\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i in points:",
      "mutated_line": "if i not in points:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 1\n    ans = -1\n    for i in range(n):\n        if i not in points:\n            dfs(i)\n            ans += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 1\n    ans = -1\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 1\n    ans = -1\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 1\n    ans = -1\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 1\n    ans = -1\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) not in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 1\n    ans = -1\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans += -1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if (min(i, j), max(i, j)) not in mp:",
      "mutated_line": "if (min(i, j), max(i, j)) in mp:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_spanning_tree_weight(n, m, edges):\n\n    def dfs(i):\n        s = [i]\n        points.remove(i)\n        while s:\n            i = s.pop()\n            for j in tuple(points):\n                if (min(i, j), max(i, j)) in mp:\n                    s.append(j)\n                    points.remove(j)\n    mp = defaultdict()\n    points = set(range(n))\n    for (x, y) in edges:\n        key = (min(x, y), max(x, y))\n        mp[key] = 1\n    ans = -1\n    for i in range(n):\n        if i in points:\n            dfs(i)\n            ans += 1\n    return ans"
    }
  ]
}