{
  "task_id": "taco_11191",
  "entry_point": "divide_collection",
  "mutant_count": 181,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "base = [-1] * 60",
      "mutated_line": "base = [-1] / 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] / 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "base = [-1] * 60",
      "mutated_line": "base = [-1] + 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] + 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "base = [-1] * 60",
      "mutated_line": "base = [-1] ** 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] ** 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "how = [-1] * 60",
      "mutated_line": "how = [-1] / 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] / 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "how = [-1] * 60",
      "mutated_line": "how = [-1] + 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] + 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "how = [-1] * 60",
      "mutated_line": "how = [-1] ** 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] ** 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "who = [-1] * 60",
      "mutated_line": "who = [-1] / 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] / 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "who = [-1] * 60",
      "mutated_line": "who = [-1] + 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] + 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "who = [-1] * 60",
      "mutated_line": "who = [-1] ** 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] ** 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 1\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x = 0",
      "mutated_line": "x = -1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = -1\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 1\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mapper = [-1] * 60",
      "mutated_line": "mapper = [-1] / 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] / 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mapper = [-1] * 60",
      "mutated_line": "mapper = [-1] + 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] + 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mapper = [-1] * 60",
      "mutated_line": "mapper = [-1] ** 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] ** 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ind = 59",
      "mutated_line": "ind = 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 60\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ind = 59",
      "mutated_line": "ind = 58",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 58\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ind = 59",
      "mutated_line": "ind = 0",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 0\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ind = 59",
      "mutated_line": "ind = 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 1\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ind = 59",
      "mutated_line": "ind = -59",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = -59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "ind_start = bin(x).count('1') - 1",
      "mutated_line": "ind_start = bin(x).count('1') + 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') + 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "ind_start = bin(x).count('1') - 1",
      "mutated_line": "ind_start = bin(x).count('1') * 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') * 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 1\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "x = 0",
      "mutated_line": "x = -1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = -1\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 1\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "temp = 0",
      "mutated_line": "temp = 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 1\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "temp = 0",
      "mutated_line": "temp = -1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = -1\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "temp = 0",
      "mutated_line": "temp = 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 1\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "result = [1] * n",
      "mutated_line": "result = [1] / n",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] / n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "result = [1] * n",
      "mutated_line": "result = [1] + n",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] + n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "result = [1] * n",
      "mutated_line": "result = [1] ** n",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] ** n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "base = [-1] * 60",
      "mutated_line": "base = [-1] * 61",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 61\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "base = [-1] * 60",
      "mutated_line": "base = [-1] * 59",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 59\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "base = [-1] * 60",
      "mutated_line": "base = [-1] * 0",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 0\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "base = [-1] * 60",
      "mutated_line": "base = [-1] * 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 1\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "base = [-1] * 60",
      "mutated_line": "base = [-1] * -60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * -60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "how = [-1] * 60",
      "mutated_line": "how = [-1] * 61",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 61\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "how = [-1] * 60",
      "mutated_line": "how = [-1] * 59",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 59\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "how = [-1] * 60",
      "mutated_line": "how = [-1] * 0",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 0\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "how = [-1] * 60",
      "mutated_line": "how = [-1] * 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 1\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "how = [-1] * 60",
      "mutated_line": "how = [-1] * -60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * -60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "who = [-1] * 60",
      "mutated_line": "who = [-1] * 61",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 61\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "who = [-1] * 60",
      "mutated_line": "who = [-1] * 59",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 59\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "who = [-1] * 60",
      "mutated_line": "who = [-1] * 0",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 0\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "who = [-1] * 60",
      "mutated_line": "who = [-1] * 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 1\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "who = [-1] * 60",
      "mutated_line": "who = [-1] * -60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * -60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mapper = [-1] * 60",
      "mutated_line": "mapper = [-1] * 61",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 61\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mapper = [-1] * 60",
      "mutated_line": "mapper = [-1] * 59",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 59\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mapper = [-1] * 60",
      "mutated_line": "mapper = [-1] * 0",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 0\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mapper = [-1] * 60",
      "mutated_line": "mapper = [-1] * 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 1\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mapper = [-1] * 60",
      "mutated_line": "mapper = [-1] * -60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * -60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ind_start = bin(x).count('1') - 1",
      "mutated_line": "ind_start = bin(x).count('1') - 2",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 2\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ind_start = bin(x).count('1') - 1",
      "mutated_line": "ind_start = bin(x).count('1') - 0",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 0\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ind_start = bin(x).count('1') - 1",
      "mutated_line": "ind_start = bin(x).count('1') - 0",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 0\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ind_start = bin(x).count('1') - 1",
      "mutated_line": "ind_start = bin(x).count('1') - -1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - -1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if 1 << bit & x:",
      "mutated_line": "if 1 << bit | x:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit | x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "ind_start -= 1",
      "mutated_line": "ind_start += 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start += 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "ind -= 1",
      "mutated_line": "ind += 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind += 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "temp = 0",
      "mutated_line": "temp = 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 1\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "temp = 0",
      "mutated_line": "temp = -1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = -1\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "temp = 0",
      "mutated_line": "temp = 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 1\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp_how = 0",
      "mutated_line": "temp_how = 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 1\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp_how = 0",
      "mutated_line": "temp_how = -1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = -1\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp_how = 0",
      "mutated_line": "temp_how = 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 1\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while x > 0:",
      "mutated_line": "while x >= 0:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x >= 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while x > 0:",
      "mutated_line": "while x <= 0:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x <= 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while x > 0:",
      "mutated_line": "while x != 0:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x != 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & 1 << bit == 0 or who[bit] != -1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 or who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for j in range(60):",
      "mutated_line": "for j in range(61):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(61):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for j in range(60):",
      "mutated_line": "for j in range(59):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(59):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for j in range(60):",
      "mutated_line": "for j in range(0):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(0):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for j in range(60):",
      "mutated_line": "for j in range(1):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(1):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for j in range(60):",
      "mutated_line": "for j in range(-60):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(-60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if temp & 1 << j:",
      "mutated_line": "if temp | 1 << j:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp | 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 2,
      "original_line": "base = [-1] * 60",
      "mutated_line": "base = [+1] * 60",
      "code": "def divide_collection(n, arr):\n    base = [+1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "how = [-1] * 60",
      "mutated_line": "how = [+1] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [+1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "who = [-1] * 60",
      "mutated_line": "who = [+1] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [+1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "mapper = [-1] * 60",
      "mutated_line": "mapper = [+1] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [+1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ind_start = bin(x).count('1') - 1",
      "mutated_line": "ind_start = bin(x).count('') - 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for bit in reversed(range(60)):",
      "mutated_line": "for bit in reversed(range(61)):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(61)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for bit in reversed(range(60)):",
      "mutated_line": "for bit in reversed(range(59)):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(59)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for bit in reversed(range(60)):",
      "mutated_line": "for bit in reversed(range(0)):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(0)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for bit in reversed(range(60)):",
      "mutated_line": "for bit in reversed(range(1)):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(1)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for bit in reversed(range(60)):",
      "mutated_line": "for bit in reversed(range(-60)):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(-60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ind_start -= 1",
      "mutated_line": "ind_start -= 2",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 2\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ind_start -= 1",
      "mutated_line": "ind_start -= 0",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 0\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ind_start -= 1",
      "mutated_line": "ind_start -= 0",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 0\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ind_start -= 1",
      "mutated_line": "ind_start -= -1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= -1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ind -= 1",
      "mutated_line": "ind -= 2",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 2\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ind -= 1",
      "mutated_line": "ind -= 0",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 0\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ind -= 1",
      "mutated_line": "ind -= 0",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 0\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ind -= 1",
      "mutated_line": "ind -= -1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= -1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for bit in range(60):",
      "mutated_line": "for bit in range(61):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(61):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for bit in range(60):",
      "mutated_line": "for bit in range(59):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(59):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for bit in range(60):",
      "mutated_line": "for bit in range(0):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(0):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for bit in range(60):",
      "mutated_line": "for bit in range(1):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(1):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for bit in range(60):",
      "mutated_line": "for bit in range(-60):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(-60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if 1 << bit & arr[i]:",
      "mutated_line": "if 1 << bit | arr[i]:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit | arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while x > 0:",
      "mutated_line": "while x > 1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 1:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while x > 0:",
      "mutated_line": "while x > -1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > -1:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while x > 0:",
      "mutated_line": "while x > 1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 1:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "b = x.bit_length() - 1",
      "mutated_line": "b = x.bit_length() + 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() + 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "b = x.bit_length() - 1",
      "mutated_line": "b = x.bit_length() * 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() * 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if who[b] != -1:",
      "mutated_line": "if who[b] == -1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] == -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for bit in reversed(range(60)):",
      "mutated_line": "for bit in reversed(range(61)):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(61)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for bit in reversed(range(60)):",
      "mutated_line": "for bit in reversed(range(59)):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(59)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for bit in reversed(range(60)):",
      "mutated_line": "for bit in reversed(range(0)):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(0)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for bit in reversed(range(60)):",
      "mutated_line": "for bit in reversed(range(1)):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(1)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for bit in reversed(range(60)):",
      "mutated_line": "for bit in reversed(range(-60)):",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(-60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & 1 << bit != 0 and who[bit] != -1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit != 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & 1 << bit == 0 and who[bit] == -1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] == -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [1] * n",
      "mutated_line": "result = [2] * n",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [2] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [1] * n",
      "mutated_line": "result = [0] * n",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [0] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [1] * n",
      "mutated_line": "result = [0] * n",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [0] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [1] * n",
      "mutated_line": "result = [-1] * n",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [-1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "result[who[j]] = 2",
      "mutated_line": "result[who[j]] = 3",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "result[who[j]] = 2",
      "mutated_line": "result[who[j]] = 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 1\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "result[who[j]] = 2",
      "mutated_line": "result[who[j]] = 0",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 0\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "result[who[j]] = 2",
      "mutated_line": "result[who[j]] = 1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 1\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "result[who[j]] = 2",
      "mutated_line": "result[who[j]] = -2",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = -2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "base = [-1] * 60",
      "mutated_line": "base = [-2] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-2] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "base = [-1] * 60",
      "mutated_line": "base = [-0] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-0] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "base = [-1] * 60",
      "mutated_line": "base = [-0] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-0] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "base = [-1] * 60",
      "mutated_line": "base = [--1] * 60",
      "code": "def divide_collection(n, arr):\n    base = [--1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "how = [-1] * 60",
      "mutated_line": "how = [-2] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-2] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "how = [-1] * 60",
      "mutated_line": "how = [-0] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-0] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "how = [-1] * 60",
      "mutated_line": "how = [-0] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-0] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "how = [-1] * 60",
      "mutated_line": "how = [--1] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [--1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "who = [-1] * 60",
      "mutated_line": "who = [-2] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-2] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "who = [-1] * 60",
      "mutated_line": "who = [-0] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-0] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "who = [-1] * 60",
      "mutated_line": "who = [-0] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-0] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "who = [-1] * 60",
      "mutated_line": "who = [--1] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [--1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mapper = [-1] * 60",
      "mutated_line": "mapper = [-2] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-2] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mapper = [-1] * 60",
      "mutated_line": "mapper = [-0] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-0] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mapper = [-1] * 60",
      "mutated_line": "mapper = [-0] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-0] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mapper = [-1] * 60",
      "mutated_line": "mapper = [--1] * 60",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [--1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 1 << bit & x:",
      "mutated_line": "if 2 << bit & x:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 2 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 1 << bit & x:",
      "mutated_line": "if 0 << bit & x:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 0 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 1 << bit & x:",
      "mutated_line": "if 0 << bit & x:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 0 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 1 << bit & x:",
      "mutated_line": "if -1 << bit & x:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if -1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = x.bit_length() - 1",
      "mutated_line": "b = x.bit_length() - 2",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 2\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = x.bit_length() - 1",
      "mutated_line": "b = x.bit_length() - 0",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 0\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = x.bit_length() - 1",
      "mutated_line": "b = x.bit_length() - 0",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 0\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = x.bit_length() - 1",
      "mutated_line": "b = x.bit_length() - -1",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - -1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "if who[b] != -1:",
      "mutated_line": "if who[b] != +1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != +1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "x = x ^ base[b]",
      "mutated_line": "x = x | base[b]",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x | base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "how[b] = temp_how | 1 << b",
      "mutated_line": "how[b] = temp_how & 1 << b",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how & 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "how[b] = temp_how | 1 << b",
      "mutated_line": "how[b] = temp_how ^ 1 << b",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how ^ 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x | 1 << bit == 0 and who[bit] != -1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x | 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & 1 << bit == 1 and who[bit] != -1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 1 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & 1 << bit == -1 and who[bit] != -1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == -1 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & 1 << bit == 1 and who[bit] != -1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 1 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & 1 << bit == 0 and who[bit] != +1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != +1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if temp & 1 << j:",
      "mutated_line": "if temp & 2 << j:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 2 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if temp & 1 << j:",
      "mutated_line": "if temp & 0 << j:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 0 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if temp & 1 << j:",
      "mutated_line": "if temp & 0 << j:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 0 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if temp & 1 << j:",
      "mutated_line": "if temp & -1 << j:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & -1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 1 << bit & arr[i]:",
      "mutated_line": "if 2 << bit & arr[i]:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 2 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 1 << bit & arr[i]:",
      "mutated_line": "if 0 << bit & arr[i]:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 0 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 1 << bit & arr[i]:",
      "mutated_line": "if 0 << bit & arr[i]:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 0 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 1 << bit & arr[i]:",
      "mutated_line": "if -1 << bit & arr[i]:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if -1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "temp ^= 1 << mapper[bit]",
      "mutated_line": "temp ^= 2 << mapper[bit]",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 2 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "temp ^= 1 << mapper[bit]",
      "mutated_line": "temp ^= 0 << mapper[bit]",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 0 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "temp ^= 1 << mapper[bit]",
      "mutated_line": "temp ^= 0 << mapper[bit]",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 0 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "temp ^= 1 << mapper[bit]",
      "mutated_line": "temp ^= -1 << mapper[bit]",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= -1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if who[b] != -1:",
      "mutated_line": "if who[b] != -2:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -2:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if who[b] != -1:",
      "mutated_line": "if who[b] != -0:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -0:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if who[b] != -1:",
      "mutated_line": "if who[b] != -0:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -0:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if who[b] != -1:",
      "mutated_line": "if who[b] != --1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != --1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & 1 << bit == 0 and who[bit] != -2:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -2:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & 1 << bit == 0 and who[bit] != -0:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -0:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & 1 << bit == 0 and who[bit] != -0:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -0:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & 1 << bit == 0 and who[bit] != --1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != --1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "how[b] = temp_how | 1 << b",
      "mutated_line": "how[b] = temp_how | 2 << b",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 2 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "how[b] = temp_how | 1 << b",
      "mutated_line": "how[b] = temp_how | 0 << b",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 0 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "how[b] = temp_how | 1 << b",
      "mutated_line": "how[b] = temp_how | 0 << b",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 0 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "how[b] = temp_how | 1 << b",
      "mutated_line": "how[b] = temp_how | -1 << b",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | -1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & 2 << bit == 0 and who[bit] != -1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 2 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & 0 << bit == 0 and who[bit] != -1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 0 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & 0 << bit == 0 and who[bit] != -1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & 0 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if x & 1 << bit == 0 and who[bit] != -1:",
      "mutated_line": "if x & -1 << bit == 0 and who[bit] != -1:",
      "code": "def divide_collection(n, arr):\n    base = [-1] * 60\n    how = [-1] * 60\n    who = [-1] * 60\n    x = 0\n    for a in arr:\n        x ^= a\n    mapper = [-1] * 60\n    ind = 59\n    ind_start = bin(x).count('1') - 1\n    for bit in reversed(range(60)):\n        if 1 << bit & x:\n            mapper[bit] = ind_start\n            ind_start -= 1\n        else:\n            mapper[bit] = ind\n            ind -= 1\n    for i in range(len(arr)):\n        temp = 0\n        for bit in range(60):\n            if 1 << bit & arr[i]:\n                temp ^= 1 << mapper[bit]\n        arr[i] = temp\n    for i in range(n):\n        x = arr[i]\n        temp_how = 0\n        while x > 0:\n            b = x.bit_length() - 1\n            if who[b] != -1:\n                temp_how ^= how[b]\n                x = x ^ base[b]\n            else:\n                who[b] = i\n                base[b] = x\n                how[b] = temp_how | 1 << b\n                break\n    x = 0\n    temp = 0\n    for bit in reversed(range(60)):\n        if x & -1 << bit == 0 and who[bit] != -1:\n            x ^= base[bit]\n            temp ^= how[bit]\n    result = [1] * n\n    for j in range(60):\n        if temp & 1 << j:\n            result[who[j]] = 2\n    return result"
    }
  ]
}