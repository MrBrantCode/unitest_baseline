{
  "task_id": "taco_920",
  "entry_point": "calculate_timeline_cost",
  "mutant_count": 30,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "total_steps = steps_row + steps_column",
      "mutated_line": "total_steps = steps_row - steps_column",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row - steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "total_steps = steps_row + steps_column",
      "mutated_line": "total_steps = steps_row * steps_column",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row * steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "total_cost = p * total_steps",
      "mutated_line": "total_cost = p / total_steps",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p / total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "total_cost = p * total_steps",
      "mutated_line": "total_cost = p + total_steps",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p + total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "total_cost = p * total_steps",
      "mutated_line": "total_cost = p ** total_steps",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p ** total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if total_cost <= 1000:",
      "mutated_line": "if total_cost < 1000:",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost < 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if total_cost <= 1000:",
      "mutated_line": "if total_cost > 1000:",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost > 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if total_cost <= 1000:",
      "mutated_line": "if total_cost == 1000:",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost == 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if x1 > x2:",
      "mutated_line": "if x1 >= x2:",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 >= x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if x1 > x2:",
      "mutated_line": "if x1 <= x2:",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 <= x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if x1 > x2:",
      "mutated_line": "if x1 != x2:",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 != x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if total_cost <= 1000:",
      "mutated_line": "if total_cost <= 1001:",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1001:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if total_cost <= 1000:",
      "mutated_line": "if total_cost <= 999:",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 999:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if total_cost <= 1000:",
      "mutated_line": "if total_cost <= 0:",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 0:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if total_cost <= 1000:",
      "mutated_line": "if total_cost <= 1:",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if total_cost <= 1000:",
      "mutated_line": "if total_cost <= -1000:",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= -1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "result_message = 'You saved the group.'",
      "mutated_line": "result_message = ''",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = ''\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "result_message = 'Let go of the group.'",
      "mutated_line": "result_message = ''",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = ''\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return abs(limit - x1) + x2",
      "mutated_line": "return abs(limit - x1) - x2",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) - x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return abs(limit - x1) + x2",
      "mutated_line": "return abs(limit - x1) * x2",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) * x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return abs(limit - x2) + x1",
      "mutated_line": "return abs(limit - x2) - x1",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) - x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return abs(limit - x2) + x1",
      "mutated_line": "return abs(limit - x2) * x1",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) * x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))",
      "mutated_line": "steps_row = min(abs(x1 + x2), wrapped_distance(x1, x2, N))",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 + x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))",
      "mutated_line": "steps_row = min(abs(x1 * x2), wrapped_distance(x1, x2, N))",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 * x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))",
      "mutated_line": "steps_column = min(abs(y1 + y2), wrapped_distance(y1, y2, M))",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 + y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))",
      "mutated_line": "steps_column = min(abs(y1 * y2), wrapped_distance(y1, y2, M))",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 * y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return abs(limit - x1) + x2",
      "mutated_line": "return abs(limit + x1) + x2",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit + x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return abs(limit - x1) + x2",
      "mutated_line": "return abs(limit * x1) + x2",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit * x1) + x2\n        else:\n            return abs(limit - x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return abs(limit - x2) + x1",
      "mutated_line": "return abs(limit + x2) + x1",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit + x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return abs(limit - x2) + x1",
      "mutated_line": "return abs(limit * x2) + x1",
      "code": "def calculate_timeline_cost(N, M, x1, y1, x2, y2, p):\n\n    def wrapped_distance(x1, x2, limit):\n        if x1 > x2:\n            return abs(limit - x1) + x2\n        else:\n            return abs(limit * x2) + x1\n    steps_row = min(abs(x1 - x2), wrapped_distance(x1, x2, N))\n    steps_column = min(abs(y1 - y2), wrapped_distance(y1, y2, M))\n    total_steps = steps_row + steps_column\n    total_cost = p * total_steps\n    if total_cost <= 1000:\n        result_message = 'You saved the group.'\n    else:\n        result_message = 'Let go of the group.'\n    return (total_cost, result_message)"
    }
  ]
}