{
  "task_id": "taco_16830",
  "entry_point": "process_queries",
  "mutant_count": 177,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "N = q + 2",
      "mutated_line": "N = q - 2",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q - 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "N = q + 2",
      "mutated_line": "N = q * 2",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q * 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [0] / N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] / N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [0] + N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] + N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [0] ** N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] ** N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "C = [0] * N",
      "mutated_line": "C = [0] / N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] / N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "C = [0] * N",
      "mutated_line": "C = [0] + N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] + N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "C = [0] * N",
      "mutated_line": "C = [0] ** N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] ** N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "P = [0] * N",
      "mutated_line": "P = [0] / N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] / N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "P = [0] * N",
      "mutated_line": "P = [0] + N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] + N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "P = [0] * N",
      "mutated_line": "P = [0] ** N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] ** N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "pref = [0] * N",
      "mutated_line": "pref = [0] / N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] / N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "pref = [0] * N",
      "mutated_line": "pref = [0] + N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] + N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "pref = [0] * N",
      "mutated_line": "pref = [0] ** N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] ** N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-1] = [-1] / 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] / 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-1] = [-1] + 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] + 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-1] = [-1] ** 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] ** 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "root = 0",
      "mutated_line": "root = 1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 1\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "root = 0",
      "mutated_line": "root = -1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = -1\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "root = 0",
      "mutated_line": "root = 1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 1\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "P[root] = -1",
      "mutated_line": "P[root] = +1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = +1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "anc[root] = [-1] * 20",
      "mutated_line": "anc[root] = [-1] / 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] / 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "anc[root] = [-1] * 20",
      "mutated_line": "anc[root] = [-1] + 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] + 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "anc[root] = [-1] * 20",
      "mutated_line": "anc[root] = [-1] ** 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] ** 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = q + 2",
      "mutated_line": "N = q + 3",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 3\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = q + 2",
      "mutated_line": "N = q + 1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 1\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = q + 2",
      "mutated_line": "N = q + 0",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 0\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = q + 2",
      "mutated_line": "N = q + 1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 1\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = q + 2",
      "mutated_line": "N = q + -2",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + -2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[+1] = [-1] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[+1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-1] = [-1] * 21",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 21\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-1] = [-1] * 19",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 19\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-1] = [-1] * 0",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 0\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-1] = [-1] * 1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 1\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-1] = [-1] * -20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * -20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "P[root] = -1",
      "mutated_line": "P[root] = -2",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -2\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "P[root] = -1",
      "mutated_line": "P[root] = -0",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -0\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "P[root] = -1",
      "mutated_line": "P[root] = -0",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -0\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "P[root] = -1",
      "mutated_line": "P[root] = --1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = --1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "anc[root] = [-1] * 20",
      "mutated_line": "anc[root] = [-1] * 21",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 21\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "anc[root] = [-1] * 20",
      "mutated_line": "anc[root] = [-1] * 19",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 19\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "anc[root] = [-1] * 20",
      "mutated_line": "anc[root] = [-1] * 0",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 0\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "anc[root] = [-1] * 20",
      "mutated_line": "anc[root] = [-1] * 1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 1\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "anc[root] = [-1] * 20",
      "mutated_line": "anc[root] = [-1] * -20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * -20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "jumps = [0] * 20",
      "mutated_line": "jumps = [0] / 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] / 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "jumps = [0] * 20",
      "mutated_line": "jumps = [0] + 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] + 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "jumps = [0] * 20",
      "mutated_line": "jumps = [0] ** 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] ** 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, q + 1):",
      "mutated_line": "for i in range(2, q + 1):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(2, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, q + 1):",
      "mutated_line": "for i in range(0, q + 1):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(0, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, q + 1):",
      "mutated_line": "for i in range(0, q + 1):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(0, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, q + 1):",
      "mutated_line": "for i in range(-1, q + 1):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(-1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for i in range(1, q + 1):",
      "mutated_line": "for i in range(1, q - 1):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q - 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for i in range(1, q + 1):",
      "mutated_line": "for i in range(1, q * 1):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q * 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] != 1:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] != 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [1] * N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [1] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [-1] * N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [-1] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [1] * N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [1] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "C = [0] * N",
      "mutated_line": "C = [1] * N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [1] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "C = [0] * N",
      "mutated_line": "C = [-1] * N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [-1] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "C = [0] * N",
      "mutated_line": "C = [1] * N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [1] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "P = [0] * N",
      "mutated_line": "P = [1] * N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [1] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "P = [0] * N",
      "mutated_line": "P = [-1] * N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [-1] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "P = [0] * N",
      "mutated_line": "P = [1] * N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [1] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "pref = [0] * N",
      "mutated_line": "pref = [1] * N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [1] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "pref = [0] * N",
      "mutated_line": "pref = [-1] * N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [-1] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "pref = [0] * N",
      "mutated_line": "pref = [1] * N",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [1] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-2] = [-1] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-2] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-0] = [-1] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-0] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-0] = [-1] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-0] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[--1] = [-1] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[--1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-1] = [+1] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [+1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "anc[root] = [-1] * 20",
      "mutated_line": "anc[root] = [+1] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [+1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "jumps = [0] * 20",
      "mutated_line": "jumps = [0] * 21",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 21\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "jumps = [0] * 20",
      "mutated_line": "jumps = [0] * 19",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 19\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "jumps = [0] * 20",
      "mutated_line": "jumps = [0] * 0",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 0\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "jumps = [0] * 20",
      "mutated_line": "jumps = [0] * 1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 1\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "jumps = [0] * 20",
      "mutated_line": "jumps = [0] * -20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * -20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "jumps[0] = parent",
      "mutated_line": "jumps[1] = parent",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[1] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "jumps[0] = parent",
      "mutated_line": "jumps[-1] = parent",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[-1] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "jumps[0] = parent",
      "mutated_line": "jumps[1] = parent",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[1] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(2, 20):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(2, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(0, 20):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(0, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(0, 20):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(0, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(-1, 20):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(-1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(1, 21):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 21):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(1, 19):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 19):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(1, 0):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 0):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(1, 1):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 1):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(1, -20):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, -20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if k & 1 << i:",
      "mutated_line": "if k | 1 << i:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k | 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, q + 1):",
      "mutated_line": "for i in range(1, q + 2):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 2):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, q + 1):",
      "mutated_line": "for i in range(1, q + 0):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 0):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, q + 1):",
      "mutated_line": "for i in range(1, q + 0):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 0):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, q + 1):",
      "mutated_line": "for i in range(1, q + -1):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + -1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "query = queries[i - 1]",
      "mutated_line": "query = queries[i + 1]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i + 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "query = queries[i - 1]",
      "mutated_line": "query = queries[i * 1]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i * 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] == 2:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 2:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] == 0:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 0:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] == 0:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 0:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] == -1:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == -1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "pref[i] = pref[p] + A[i]",
      "mutated_line": "pref[i] = pref[p] - A[i]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] - A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "pref[i] = pref[p] + A[i]",
      "mutated_line": "pref[i] = pref[p] * A[i]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] * A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] != 2:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] != 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-1] = [-2] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-2] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-1] = [-0] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-0] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-1] = [-0] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-0] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "anc[-1] = [-1] * 20",
      "mutated_line": "anc[-1] = [--1] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [--1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "anc[root] = [-1] * 20",
      "mutated_line": "anc[root] = [-2] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-2] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "anc[root] = [-1] * 20",
      "mutated_line": "anc[root] = [-0] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-0] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "anc[root] = [-1] * 20",
      "mutated_line": "anc[root] = [-0] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-0] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "anc[root] = [-1] * 20",
      "mutated_line": "anc[root] = [--1] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [--1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "jumps = [0] * 20",
      "mutated_line": "jumps = [1] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [1] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "jumps = [0] * 20",
      "mutated_line": "jumps = [-1] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [-1] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "jumps = [0] * 20",
      "mutated_line": "jumps = [1] * 20",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [1] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "jumps[i] = anc[jumps[i - 1]][i - 1]",
      "mutated_line": "jumps[i] = anc[jumps[i - 1]][i + 1]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i + 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "jumps[i] = anc[jumps[i - 1]][i - 1]",
      "mutated_line": "jumps[i] = anc[jumps[i - 1]][i * 1]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i * 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in reversed(range(20)):",
      "mutated_line": "for i in reversed(range(21)):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(21)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in reversed(range(20)):",
      "mutated_line": "for i in reversed(range(19)):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(19)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in reversed(range(20)):",
      "mutated_line": "for i in reversed(range(0)):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(0)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in reversed(range(20)):",
      "mutated_line": "for i in reversed(range(1)):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(1)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in reversed(range(20)):",
      "mutated_line": "for i in reversed(range(-20)):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(-20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in reversed(range(20)):",
      "mutated_line": "for i in reversed(range(21)):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(21)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in reversed(range(20)):",
      "mutated_line": "for i in reversed(range(19)):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(19)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in reversed(range(20)):",
      "mutated_line": "for i in reversed(range(0)):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(0)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in reversed(range(20)):",
      "mutated_line": "for i in reversed(range(1)):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(1)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in reversed(range(20)):",
      "mutated_line": "for i in reversed(range(-20)):",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(-20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "query = queries[i - 1]",
      "mutated_line": "query = queries[i - 2]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 2]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "query = queries[i - 1]",
      "mutated_line": "query = queries[i - 0]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 0]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "query = queries[i - 1]",
      "mutated_line": "query = queries[i - 0]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 0]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "query = queries[i - 1]",
      "mutated_line": "query = queries[i - -1]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - -1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[1] == 1:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[1] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[-1] == 1:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[-1] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[1] == 1:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[1] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == 3:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 3:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == 1:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 1:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == 0:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 0:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == 1:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 1:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == -2:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == -2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "gold = 0",
      "mutated_line": "gold = 1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 1\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "gold = 0",
      "mutated_line": "gold = -1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = -1\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "gold = 0",
      "mutated_line": "gold = 1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 1\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "spend = 0",
      "mutated_line": "spend = 1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 1\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "spend = 0",
      "mutated_line": "spend = -1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = -1\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "spend = 0",
      "mutated_line": "spend = 1",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 1\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 48,
      "original_line": "while A[v] != 0 and want:",
      "mutated_line": "while A[v] != 0 or want:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 or want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "A[u] -= take",
      "mutated_line": "A[u] += take",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] += take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "gold += take",
      "mutated_line": "gold -= take",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold -= take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "spend += C[u] * take",
      "mutated_line": "spend -= C[u] * take",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend -= C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 54,
      "original_line": "want -= take",
      "mutated_line": "want += take",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want += take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "jumps[i] = anc[jumps[i - 1]][i - 1]",
      "mutated_line": "jumps[i] = anc[jumps[i - 1]][i - 2]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 2]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "jumps[i] = anc[jumps[i - 1]][i - 1]",
      "mutated_line": "jumps[i] = anc[jumps[i - 1]][i - 0]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 0]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "jumps[i] = anc[jumps[i - 1]][i - 1]",
      "mutated_line": "jumps[i] = anc[jumps[i - 1]][i - 0]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 0]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "jumps[i] = anc[jumps[i - 1]][i - 1]",
      "mutated_line": "jumps[i] = anc[jumps[i - 1]][i - -1]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - -1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k & 1 << i:",
      "mutated_line": "if k & 2 << i:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 2 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k & 1 << i:",
      "mutated_line": "if k & 0 << i:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 0 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k & 1 << i:",
      "mutated_line": "if k & 0 << i:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 0 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k & 1 << i:",
      "mutated_line": "if k & -1 << i:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & -1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[1] == 2:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[1] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[-1] == 2:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[-1] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[1] == 2:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[1] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while A[v] != 0 and want:",
      "mutated_line": "while A[v] == 0 and want:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] == 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "spend += C[u] * take",
      "mutated_line": "spend += C[u] / take",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] / take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "spend += C[u] * take",
      "mutated_line": "spend += C[u] + take",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] + take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "spend += C[u] * take",
      "mutated_line": "spend += C[u] ** take",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] ** take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "jumps[i] = anc[jumps[i - 1]][i - 1]",
      "mutated_line": "jumps[i] = anc[jumps[i + 1]][i - 1]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i + 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "jumps[i] = anc[jumps[i - 1]][i - 1]",
      "mutated_line": "jumps[i] = anc[jumps[i * 1]][i - 1]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i * 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while A[v] != 0 and want:",
      "mutated_line": "while A[v] != 1 and want:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 1 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while A[v] != 0 and want:",
      "mutated_line": "while A[v] != -1 and want:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != -1 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while A[v] != 0 and want:",
      "mutated_line": "while A[v] != 1 and want:",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 1 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "jumps[i] = anc[jumps[i - 1]][i - 1]",
      "mutated_line": "jumps[i] = anc[jumps[i - 2]][i - 1]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 2]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "jumps[i] = anc[jumps[i - 1]][i - 1]",
      "mutated_line": "jumps[i] = anc[jumps[i - 0]][i - 1]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 0]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "jumps[i] = anc[jumps[i - 1]][i - 1]",
      "mutated_line": "jumps[i] = anc[jumps[i - 0]][i - 1]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 0]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "jumps[i] = anc[jumps[i - 1]][i - 1]",
      "mutated_line": "jumps[i] = anc[jumps[i - -1]][i - 1]",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - -1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "u = get_last(v, lambda node: A[node] != 0)",
      "mutated_line": "u = get_last(v, lambda node: A[node] == 0)",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] == 0)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "u = get_last(v, lambda node: A[node] != 0)",
      "mutated_line": "u = get_last(v, lambda node: A[node] != 1)",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 1)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "u = get_last(v, lambda node: A[node] != 0)",
      "mutated_line": "u = get_last(v, lambda node: A[node] != -1)",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != -1)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "u = get_last(v, lambda node: A[node] != 0)",
      "mutated_line": "u = get_last(v, lambda node: A[node] != 1)",
      "code": "def process_queries(q, a_0, c_0, queries):\n    N = q + 2\n    A = [0] * N\n    C = [0] * N\n    P = [0] * N\n    pref = [0] * N\n    anc = [None for _ in range(N)]\n    anc[-1] = [-1] * 20\n    root = 0\n    A[root] = a_0\n    C[root] = c_0\n    P[root] = -1\n    pref[root] = a_0\n    anc[root] = [-1] * 20\n\n    def build_jumps(u, parent):\n        jumps = [0] * 20\n        jumps[0] = parent\n        for i in range(1, 20):\n            jumps[i] = anc[jumps[i - 1]][i - 1]\n        anc[u] = jumps\n\n    def get_ancestor(u, k):\n        for i in reversed(range(20)):\n            if k & 1 << i:\n                u = anc[u][i]\n        return u\n\n    def get_last(u, f):\n        for i in reversed(range(20)):\n            if f(anc[u][i]):\n                u = anc[u][i]\n        return u\n    results = []\n    for i in range(1, q + 1):\n        query = queries[i - 1]\n        if query[0] == 1:\n            (_, p, A[i], C[i]) = query\n            P[i] = p\n            pref[i] = pref[p] + A[i]\n            build_jumps(i, p)\n        elif query[0] == 2:\n            (_, v, want) = query\n            gold = 0\n            spend = 0\n            while A[v] != 0 and want:\n                u = get_last(v, lambda node: A[node] != 1)\n                take = min(want, A[u])\n                A[u] -= take\n                gold += take\n                spend += C[u] * take\n                want -= take\n            results.append((gold, spend))\n    return results"
    }
  ]
}