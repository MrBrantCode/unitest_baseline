{
  "task_id": "taco_723",
  "entry_point": "find_largest_composite_subset",
  "mutant_count": 89,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = 2",
      "mutated_line": "p = 3",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 3\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = 2",
      "mutated_line": "p = 1",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 1\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = 2",
      "mutated_line": "p = 0",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 0\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = 2",
      "mutated_line": "p = 1",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 1\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = 2",
      "mutated_line": "p = -2",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = -2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while p * p <= n:",
      "mutated_line": "while p * p < n:",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p < n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while p * p <= n:",
      "mutated_line": "while p * p > n:",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p > n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while p * p <= n:",
      "mutated_line": "while p * p == n:",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p == n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "p += 1",
      "mutated_line": "p -= 1",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p -= 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prime[0] = False",
      "mutated_line": "prime[0] = True",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = True\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "prime[1] = False",
      "mutated_line": "prime[1] = True",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = True\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "primes = sieve(200001)",
      "mutated_line": "primes = sieve(200002)",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200002)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "primes = sieve(200001)",
      "mutated_line": "primes = sieve(200000)",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200000)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "primes = sieve(200001)",
      "mutated_line": "primes = sieve(0)",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(0)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "primes = sieve(200001)",
      "mutated_line": "primes = sieve(1)",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(1)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "primes = sieve(200001)",
      "mutated_line": "primes = sieve(-200001)",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(-200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if arr_s not in primes:",
      "mutated_line": "if arr_s in primes:",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prime = [True for _ in range(n + 1)]",
      "mutated_line": "prime = [False for _ in range(n + 1)]",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [False for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "while p * p <= n:",
      "mutated_line": "while p / p <= n:",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p / p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "while p * p <= n:",
      "mutated_line": "while p + p <= n:",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p + p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "while p * p <= n:",
      "mutated_line": "while p ** p <= n:",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p ** p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p += 1",
      "mutated_line": "p += 2",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 2\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 0\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 0\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p += 1",
      "mutated_line": "p += -1",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += -1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prime[0] = False",
      "mutated_line": "prime[1] = False",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[1] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prime[0] = False",
      "mutated_line": "prime[-1] = False",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[-1] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prime[0] = False",
      "mutated_line": "prime[1] = False",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[1] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "prime[1] = False",
      "mutated_line": "prime[2] = False",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[2] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "prime[1] = False",
      "mutated_line": "prime[0] = False",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[0] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "prime[1] = False",
      "mutated_line": "prime[0] = False",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[0] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "prime[1] = False",
      "mutated_line": "prime[-1] = False",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[-1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for p in range(n + 1):",
      "mutated_line": "for p in range(n - 1):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n - 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for p in range(n + 1):",
      "mutated_line": "for p in range(n * 1):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n * 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "excluded = -1",
      "mutated_line": "excluded = +1",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = +1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for p in range(n + 1):",
      "mutated_line": "for p in range(n + 2):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 2):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for p in range(n + 1):",
      "mutated_line": "for p in range(n + 0):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 0):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for p in range(n + 1):",
      "mutated_line": "for p in range(n + 0):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 0):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for p in range(n + 1):",
      "mutated_line": "for p in range(n + -1):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + -1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "excluded = -1",
      "mutated_line": "excluded = -2",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -2\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "excluded = -1",
      "mutated_line": "excluded = -0",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -0\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "excluded = -1",
      "mutated_line": "excluded = -0",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -0\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "excluded = -1",
      "mutated_line": "excluded = --1",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = --1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if arr_s - arr[x] not in primes:",
      "mutated_line": "if arr_s - arr[x] in primes:",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "prime = [True for _ in range(n + 1)]",
      "mutated_line": "prime = [True for _ in range(n - 1)]",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n - 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "prime = [True for _ in range(n + 1)]",
      "mutated_line": "prime = [True for _ in range(n * 1)]",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n * 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(p ** 2, n + 1, p):",
      "mutated_line": "for i in range(p * 2, n + 1, p):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p * 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(p ** 2, n + 1, p):",
      "mutated_line": "for i in range(p + 2, n + 1, p):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p + 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(p ** 2, n + 1, p):",
      "mutated_line": "for i in range(p ** 2, n - 1, p):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n - 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(p ** 2, n + 1, p):",
      "mutated_line": "for i in range(p ** 2, n * 1, p):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n * 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "prime[i] = False",
      "mutated_line": "prime[i] = True",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = True\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if arr_s - arr[x] not in primes:",
      "mutated_line": "if arr_s + arr[x] not in primes:",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s + arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if arr_s - arr[x] not in primes:",
      "mutated_line": "if arr_s * arr[x] not in primes:",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s * arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))",
      "mutated_line": "results.append((n + 1, [x + 1 for x in range(n) if x != excluded]))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n + 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))",
      "mutated_line": "results.append((n * 1, [x + 1 for x in range(n) if x != excluded]))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n * 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prime = [True for _ in range(n + 1)]",
      "mutated_line": "prime = [True for _ in range(n + 2)]",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 2)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prime = [True for _ in range(n + 1)]",
      "mutated_line": "prime = [True for _ in range(n + 0)]",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 0)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prime = [True for _ in range(n + 1)]",
      "mutated_line": "prime = [True for _ in range(n + 0)]",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 0)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prime = [True for _ in range(n + 1)]",
      "mutated_line": "prime = [True for _ in range(n + -1)]",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + -1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(p ** 2, n + 1, p):",
      "mutated_line": "for i in range(p ** 3, n + 1, p):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 3, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(p ** 2, n + 1, p):",
      "mutated_line": "for i in range(p ** 1, n + 1, p):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 1, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(p ** 2, n + 1, p):",
      "mutated_line": "for i in range(p ** 0, n + 1, p):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 0, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(p ** 2, n + 1, p):",
      "mutated_line": "for i in range(p ** 1, n + 1, p):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 1, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(p ** 2, n + 1, p):",
      "mutated_line": "for i in range(p ** -2, n + 1, p):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** -2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(p ** 2, n + 1, p):",
      "mutated_line": "for i in range(p ** 2, n + 2, p):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 2, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(p ** 2, n + 1, p):",
      "mutated_line": "for i in range(p ** 2, n + 0, p):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 0, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(p ** 2, n + 1, p):",
      "mutated_line": "for i in range(p ** 2, n + 0, p):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 0, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(p ** 2, n + 1, p):",
      "mutated_line": "for i in range(p ** 2, n + -1, p):",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + -1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))",
      "mutated_line": "results.append((n - 2, [x + 1 for x in range(n) if x != excluded]))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 2, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))",
      "mutated_line": "results.append((n - 0, [x + 1 for x in range(n) if x != excluded]))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 0, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))",
      "mutated_line": "results.append((n - 0, [x + 1 for x in range(n) if x != excluded]))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 0, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))",
      "mutated_line": "results.append((n - -1, [x + 1 for x in range(n) if x != excluded]))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - -1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))",
      "mutated_line": "results.append((n - 1, [x - 1 for x in range(n) if x != excluded]))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x - 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))",
      "mutated_line": "results.append((n - 1, [x * 1 for x in range(n) if x != excluded]))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x * 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "results.append((n, list(range(1, n + 1))))",
      "mutated_line": "results.append((n, list(range(2, n + 1))))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(2, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "results.append((n, list(range(1, n + 1))))",
      "mutated_line": "results.append((n, list(range(0, n + 1))))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(0, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "results.append((n, list(range(1, n + 1))))",
      "mutated_line": "results.append((n, list(range(0, n + 1))))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(0, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "results.append((n, list(range(1, n + 1))))",
      "mutated_line": "results.append((n, list(range(-1, n + 1))))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(-1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "results.append((n, list(range(1, n + 1))))",
      "mutated_line": "results.append((n, list(range(1, n - 1))))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n - 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "results.append((n, list(range(1, n + 1))))",
      "mutated_line": "results.append((n, list(range(1, n * 1))))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n * 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))",
      "mutated_line": "results.append((n - 1, [x + 2 for x in range(n) if x != excluded]))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 2 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))",
      "mutated_line": "results.append((n - 1, [x + 0 for x in range(n) if x != excluded]))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 0 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))",
      "mutated_line": "results.append((n - 1, [x + 0 for x in range(n) if x != excluded]))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 0 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))",
      "mutated_line": "results.append((n - 1, [x + -1 for x in range(n) if x != excluded]))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + -1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))",
      "mutated_line": "results.append((n - 1, [x + 1 for x in range(n) if x == excluded]))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x == excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "results.append((n, list(range(1, n + 1))))",
      "mutated_line": "results.append((n, list(range(1, n + 2))))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 2))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "results.append((n, list(range(1, n + 1))))",
      "mutated_line": "results.append((n, list(range(1, n + 0))))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 0))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "results.append((n, list(range(1, n + 1))))",
      "mutated_line": "results.append((n, list(range(1, n + 0))))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + 0))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "results.append((n, list(range(1, n + 1))))",
      "mutated_line": "results.append((n, list(range(1, n + -1))))",
      "code": "def find_largest_composite_subset(test_cases):\n\n    def sieve(n):\n        prime = [True for _ in range(n + 1)]\n        p = 2\n        ret = []\n        while p * p <= n:\n            if prime[p]:\n                for i in range(p ** 2, n + 1, p):\n                    prime[i] = False\n            p += 1\n        prime[0] = False\n        prime[1] = False\n        for p in range(n + 1):\n            if prime[p]:\n                ret.append(p)\n        return ret\n    primes = sieve(200001)\n    results = []\n    for (n, arr) in test_cases:\n        arr_s = sum(arr)\n        if arr_s not in primes:\n            results.append((n, list(range(1, n + -1))))\n        else:\n            excluded = -1\n            for x in range(n):\n                if arr_s - arr[x] not in primes:\n                    excluded = x\n                    break\n            results.append((n - 1, [x + 1 for x in range(n) if x != excluded]))\n    return results"
    }
  ]
}